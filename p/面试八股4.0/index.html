<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="面试八股4.0 介绍RocketMQ中常用的组件 在 RocketMQ 的架构中，有四个最核心的组件，它们各司其职，共同支撑起整个消息系统的高性能和高可用。\n我们可以把 RocketMQ 想象成一个 “邮政系统” 来理解这些组件：\n1. NameServer (邮局总管 / 路由中心) 角色定位： 它是整个系统的大脑，是一个非常轻量级的注册中心（类似于 ZooKeeper，但更简单，无状态，节点之间互不通信）。\n">
<title>面试八股4.0</title>

<link rel='canonical' href='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A14.0/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="面试八股4.0">
<meta property='og:description' content="面试八股4.0 介绍RocketMQ中常用的组件 在 RocketMQ 的架构中，有四个最核心的组件，它们各司其职，共同支撑起整个消息系统的高性能和高可用。\n我们可以把 RocketMQ 想象成一个 “邮政系统” 来理解这些组件：\n1. NameServer (邮局总管 / 路由中心) 角色定位： 它是整个系统的大脑，是一个非常轻量级的注册中心（类似于 ZooKeeper，但更简单，无状态，节点之间互不通信）。\n">
<meta property='og:url' content='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A14.0/'>
<meta property='og:site_name' content='LuciusWan'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-12-06T15:00:20&#43;08:00'/><meta property='article:modified_time' content='2025-12-06T15:00:20&#43;08:00'/>
<meta name="twitter:title" content="面试八股4.0">
<meta name="twitter:description" content="面试八股4.0 介绍RocketMQ中常用的组件 在 RocketMQ 的架构中，有四个最核心的组件，它们各司其职，共同支撑起整个消息系统的高性能和高可用。\n我们可以把 RocketMQ 想象成一个 “邮政系统” 来理解这些组件：\n1. NameServer (邮局总管 / 路由中心) 角色定位： 它是整个系统的大脑，是一个非常轻量级的注册中心（类似于 ZooKeeper，但更简单，无状态，节点之间互不通信）。\n">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_a00c4178710685fc.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🎇</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">LuciusWan</a></h1>
            <h2 class="site-description">欢迎来到我的blog</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/440554295'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v6a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4v-6z" /><path d="M8 3l2 3" /><path d="M16 3l-2 3" /><path d="M9 13v-2" /><path d="M15 11v2" /></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/LuciusWan'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#介绍rocketmq中常用的组件">介绍RocketMQ中常用的组件</a>
      <ol>
        <li><a href="#1-nameserver-邮局总管--路由中心">1. NameServer (邮局总管 / 路由中心)</a></li>
        <li><a href="#2-broker-邮递员--分拣站">2. Broker (邮递员 / 分拣站)</a></li>
        <li><a href="#3-producer-寄件人">3. Producer (寄件人)</a></li>
        <li><a href="#4-consumer-收件人">4. Consumer (收件人)</a></li>
        <li><a href="#辅助的重要概念">辅助的重要概念</a></li>
      </ol>
    </li>
    <li><a href="#rocketmq的死信队列是怎样的">RocketMQ的死信队列是怎样的？</a>
      <ol>
        <li><a href="#1-死信是如何产生的生命周期">1. 死信是如何产生的？（生命周期）</a></li>
        <li><a href="#2-死信队列的关键特征">2. 死信队列的关键特征</a></li>
        <li><a href="#3-我们该怎么处理死信消息">3. 我们该怎么处理死信消息？</a></li>
        <li><a href="#总结">总结</a></li>
      </ol>
    </li>
    <li><a href="#介绍tcp的流量控制和拥塞控制">介绍TCP的流量控制和拥塞控制</a>
      <ol>
        <li><a href="#1-流量控制-flow-control">1. 流量控制 (Flow Control)</a></li>
        <li><a href="#2-拥塞控制-congestion-control">2. 拥塞控制 (Congestion Control)</a>
          <ol>
            <li><a href="#a-慢启动-slow-start">A. 慢启动 (Slow Start)</a></li>
            <li><a href="#b-拥塞避免-congestion-avoidance">B. 拥塞避免 (Congestion Avoidance)</a></li>
            <li><a href="#c-快重传-fast-retransmit">C. 快重传 (Fast Retransmit)</a></li>
            <li><a href="#d-快恢复-fast-recovery">D. 快恢复 (Fast Recovery)</a></li>
          </ol>
        </li>
        <li><a href="#总结对比">总结对比</a></li>
      </ol>
    </li>
    <li><a href="#http3-quic-可靠传输核心">HTTP/3 (QUIC) 可靠传输核心</a>
      <ol>
        <li><a href="#1-核心设计传输-id-与数据-id-分离">1. 核心设计：传输 ID 与数据 ID 分离</a></li>
        <li><a href="#2-丢包发现机制-loss-detection">2. 丢包发现机制 (Loss Detection)</a></li>
        <li><a href="#3-什么时候重传threshold">3. 什么时候重传？(Threshold)</a></li>
        <li><a href="#4-误判与虚假重传-spurious-retransmission">4. 误判与虚假重传 (Spurious Retransmission)</a></li>
        <li><a href="#形象记忆法快递寄书">形象记忆法：快递寄书</a></li>
      </ol>
    </li>
    <li><a href="#redis-持久化机制-rdb">Redis 持久化机制 (RDB)</a>
      <ol>
        <li><a href="#1-核心误区修正">1. 核心误区修正</a></li>
        <li><a href="#2-bgsave-标准执行流程-6步">2. BGSAVE 标准执行流程 (6步)</a></li>
        <li><a href="#3-save-vs-bgsave">3. SAVE vs BGSAVE</a></li>
      </ol>
    </li>
    <li><a href="#kafka--rocketmq-存储底层原理">Kafka &amp; RocketMQ 存储底层原理</a>
      <ol>
        <li><a href="#1-写入与刷盘机制">1. 写入与刷盘机制</a></li>
        <li><a href="#2-存储结构lsm-tree-还是-log">2. 存储结构：LSM Tree 还是 Log？</a></li>
        <li><a href="#3-消费者读取机制-读写分离">3. 消费者读取机制 (读写分离？)</a></li>
      </ol>
    </li>
    <li><a href="#rocketmq-主节点挂了怎么办高可用-ha">RocketMQ 主节点挂了怎么办？(高可用 HA)</a>
      <ol>
        <li><a href="#1-传统主从架构-master-slave">1. 传统主从架构 (Master-Slave)</a></li>
        <li><a href="#2-dledger-架构-rocketmq-45">2. Dledger 架构 (RocketMQ 4.5+)</a></li>
        <li><a href="#3-controller-模式-rocketmq-50">3. Controller 模式 (RocketMQ 5.0+)</a></li>
        <li><a href="#-核心总结-one-liner">💡 核心总结 (One Liner)</a></li>
      </ol>
    </li>
    <li><a href="#介绍copy-on-write写时复制">介绍Copy-On-Write（写时复制）</a>
      <ol>
        <li><a href="#1-为什么需要-cow传统的-fork-太慢了">1. 为什么需要 COW？（传统的 Fork 太慢了）</a></li>
        <li><a href="#2-cow-的执行原理核心-4-步">2. COW 的执行原理（核心 4 步）</a>
          <ol>
            <li><a href="#第一步fork-瞬间只复制页表"><strong>第一步：Fork 瞬间（只复制页表）</strong></a></li>
            <li><a href="#第二步读取数据相安无事"><strong>第二步：读取数据（相安无事）</strong></a></li>
            <li><a href="#第三步尝试写入触发异常"><strong>第三步：尝试写入（触发异常）</strong></a></li>
            <li><a href="#第四步复制与分离copy-发生"><strong>第四步：复制与分离（Copy 发生）</strong></a></li>
          </ol>
        </li>
        <li><a href="#3-cow-在-redis-bgsave-中的实战表现">3. COW 在 Redis BGSAVE 中的实战表现</a></li>
        <li><a href="#4-进阶考点cow-的天敌hugepage-大页内存">4. 进阶考点：COW 的“天敌”——HugePage (大页内存)</a></li>
        <li><a href="#thp是什么transparent-huge-pages-thp">THP是什么：Transparent Huge Pages (THP)</a></li>
      </ol>
    </li>
    <li><a href="#mysql的char和varchar的区别是什么">MySQL的char和varchar的区别是什么</a></li>
    <li><a href="#介绍常见的jvm实现介绍他们的区别">介绍常见的JVM实现，介绍他们的区别</a>
      <ol>
        <li><a href="#1-hotspot-vm-oracleopenjdk--绝对的霸主">1. HotSpot VM (Oracle/OpenJDK) —— &ldquo;绝对的霸主&rdquo;</a></li>
        <li><a href="#2-j9-openj9--ibm-j9--内存管理的艺术大师">2. J9 (OpenJ9 / IBM J9) —— &ldquo;内存管理的艺术大师&rdquo;</a></li>
        <li><a href="#3-graalvm--多语言通天塔--原生镜像">3. GraalVM —— &ldquo;多语言通天塔 &amp; 原生镜像&rdquo;</a></li>
      </ol>
    </li>
    <li><a href="#为什么j9比graalvm还省内存">为什么J9比GraalVM还省内存？</a>
      <ol>
        <li><a href="#1-杀手锏类共享缓存-shared-classes-cache-scc">1. 杀手锏：类共享缓存 (Shared Classes Cache, SCC)</a></li>
        <li><a href="#2-内存管理策略吝啬-vs-豪横">2. 内存管理策略：吝啬 vs. 豪横</a></li>
        <li><a href="#3-对象头与指针压缩-compressed-references">3. 对象头与指针压缩 (Compressed References)</a></li>
        <li><a href="#4-编译器线程的开销">4. 编译器线程的开销</a></li>
        <li><a href="#总结-1">总结</a></li>
        <li><a href="#物理真相page-cache-才是真正的幕后金主">物理真相：Page Cache 才是真正的“幕后金主”</a></li>
        <li><a href="#为什么比自己解析还要快">为什么比“自己解析”还要快？</a></li>
      </ol>
    </li>
    <li><a href="#1-业务场景ai-流式响应的同步化">1. 业务场景：AI 流式响应的同步化</a></li>
    <li><a href="#2-juc-工具对比completablefuture-vs-countdownlatch">2. JUC 工具对比：CompletableFuture vs CountDownLatch</a></li>
    <li><a href="#3-并发基石aqs-abstractqueuedsynchronizer">3. 并发基石：AQS (AbstractQueuedSynchronizer)</a>
      <ol>
        <li><a href="#31-核心三要素"><strong>3.1 核心三要素</strong></a></li>
        <li><a href="#32-工作机制"><strong>3.2 工作机制</strong></a></li>
        <li><a href="#33-概念辨析"><strong>3.3 概念辨析</strong></a></li>
      </ol>
    </li>
    <li><a href="#4-线程模型kernel-level-threads-klt">4. 线程模型：Kernel-Level Threads (KLT)</a>
      <ol>
        <li><a href="#41-运行位置辨析易错点"><strong>4.1 运行位置辨析（易错点）</strong></a></li>
        <li><a href="#42-运行机制"><strong>4.2 运行机制</strong></a></li>
      </ol>
    </li>
    <li><a href="#5-jni-与系统调用-system-call">5. JNI 与系统调用 (System Call)</a>
      <ol>
        <li><a href="#51-jni-java-native-interface"><strong>5.1 JNI (Java Native Interface)</strong></a></li>
        <li><a href="#52-系统调用-system-call"><strong>5.2 系统调用 (System Call)</strong></a></li>
        <li><a href="#53-完整链路以-file-read-为例"><strong>5.3 完整链路（以 File Read 为例）</strong></a></li>
      </ol>
    </li>
    <li><a href="#1-spring-boottomcat-的核心网络模型">1. Spring Boot/Tomcat 的核心网络模型</a>
      <ol>
        <li><a href="#11-工作流程">1.1 工作流程</a></li>
        <li><a href="#12-关键区分">1.2 关键区分</a></li>
      </ol>
    </li>
    <li><a href="#2-架构对比tomcat-nio-vs-redis-60">2. 架构对比：Tomcat NIO vs Redis 6.0+</a></li>
    <li><a href="#3-java-io-模型演进-bio-vs-nio-vs-aio">3. Java I/O 模型演进 (BIO vs NIO vs AIO)</a>
      <ol>
        <li><a href="#31-bio-blocking-io---jdk-14-前">3.1 BIO (Blocking I/O) - JDK 1.4 前</a></li>
        <li><a href="#32-nio-non-blocking-io---jdk-14-tomcat-默认">3.2 NIO (Non-blocking I/O) - JDK 1.4+ (Tomcat 默认)</a></li>
        <li><a href="#33-aio-asynchronous-io---jdk-17">3.3 AIO (Asynchronous I/O) - JDK 1.7+</a></li>
      </ol>
    </li>
    <li><a href="#4-操作系统底层差异-linux-vs-windows">4. 操作系统底层差异 (Linux vs Windows)</a>
      <ol>
        <li><a href="#41-bio-的线程代价">4.1 BIO 的线程代价</a></li>
        <li><a href="#42-为什么服务器首选-linux">4.2 为什么服务器首选 Linux？</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A14.0/">面试八股4.0</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-12-06</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 27 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="面试八股40">面试八股4.0
</h1><h2 id="介绍rocketmq中常用的组件">介绍RocketMQ中常用的组件
</h2><p>在 RocketMQ 的架构中，有四个最核心的组件，它们各司其职，共同支撑起整个消息系统的高性能和高可用。</p>
<p>我们可以把 RocketMQ 想象成一个 <strong>“邮政系统”</strong> 来理解这些组件：</p>
<h3 id="1-nameserver-邮局总管--路由中心">1. NameServer (邮局总管 / 路由中心)
</h3><ul>
<li>
<p><strong>角色定位：</strong> 它是整个系统的<strong>大脑</strong>，是一个非常轻量级的<strong>注册中心</strong>（类似于 ZooKeeper，但更简单，无状态，节点之间互不通信）。</p>
</li>
<li>
<p><strong>核心功能：</strong></p>
<ul>
<li>
<p><strong>服务注册：</strong> 所有的 Broker 都要定期向 NameServer 汇报自己的“家庭住址”（IP、端口）和“能送哪些信”（Topic 信息）。</p>
</li>
<li>
<p><strong>路由发现：</strong> Producer 和 Consumer 启动时，先问 NameServer：“我要发信/收信，请给我一份最新的 Broker 地址名单。”</p>
</li>
</ul>
</li>
<li>
<p><strong>特点：</strong> 如果 NameServer 挂了，只要集群里还有一台存活，系统就能正常工作。如果全挂了，已有连接的收发不受影响，但无法建立新连接或扩容。</p>
</li>
</ul>
<h3 id="2-broker-邮递员--分拣站">2. Broker (邮递员 / 分拣站)
</h3><ul>
<li>
<p><strong>角色定位：</strong> 它是系统的<strong>核心</strong>，干活最累的角色。负责<strong>存储消息、转发消息</strong>。</p>
</li>
<li>
<p><strong>核心功能：</strong></p>
<ul>
<li>
<p><strong>存信：</strong> 接收 Producer 发来的消息，持久化到硬盘（CommitLog）。</p>
</li>
<li>
<p><strong>送信：</strong> 响应 Consumer 的拉取请求，把消息发给它们。</p>
</li>
<li>
<p><strong>管理：</strong> 处理死信队列、重试队列、定时消息等复杂逻辑。</p>
</li>
</ul>
</li>
<li>
<p><strong>部署架构：</strong></p>
<ul>
<li>
<p><strong>Master (主)：</strong> 负责读和写。</p>
</li>
<li>
<p><strong>Slave (从)：</strong> 负责备份数据，也可以分担读压力（当主负载高时）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-producer-寄件人">3. Producer (寄件人)
</h3><ul>
<li>
<p><strong>角色定位：</strong> 业务系统中的<strong>消息发送方</strong>（比如：订单系统、支付系统）。</p>
</li>
<li>
<p><strong>核心功能：</strong></p>
<ul>
<li>
<p>它从 NameServer 获取路由信息，知道哪个 Topic 在哪些 Broker 上。</p>
</li>
<li>
<p>它通过负载均衡算法，把消息发给具体的 Broker。</p>
</li>
<li>
<p><strong>发送方式：</strong> 支持同步发送（要回执）、异步发送（回调）、单向发送（发完不管，如日志）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-consumer-收件人">4. Consumer (收件人)
</h3><ul>
<li>
<p><strong>角色定位：</strong> 业务系统中的<strong>消息接收方</strong>（比如：库存系统、积分系统）。</p>
</li>
<li>
<p><strong>核心功能：</strong></p>
<ul>
<li>
<p>从 Broker 获取消息并进行业务处理（消费）。</p>
</li>
<li>
<p><strong>消费模式：</strong></p>
<ul>
<li>
<p><strong>Clustering (集群模式)：</strong> 默认模式。同一个消费者组里的机器<strong>平分</strong>消息（你一条我一条，不重复）。</p>
</li>
<li>
<p><strong>Broadcasting (广播模式)：</strong> 每一条消息都会发给组里的<strong>所有</strong>机器（就像广播一样，大家都能听到）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="辅助的重要概念">辅助的重要概念
</h3><p>除了上面四个“物理组件”，还有几个“逻辑概念”必须知道：</p>
<ul>
<li>
<p><strong>Topic (主题)：</strong> 消息的一级分类。比如“订单交易”是一个 Topic，“用户注册”是另一个 Topic。寄件人必须指定把信投到哪个 Topic。</p>
</li>
<li>
<p><strong>Tag (标签)：</strong> 消息的二级分类。在同一个 Topic 下，可以用 Tag 进一步过滤。比如在“订单交易”Topic 下，可以用 Tag 区分 <code>TagA=食品订单</code>，<code>TagB=服装订单</code>。Consumer 可以只订阅 <code>TagA</code>。</p>
</li>
<li>
<p><strong>Message Queue (消息队列)：</strong> 这是物理存储单元。一个 Topic 通常被切分成多个 Message Queue，分布在不同的 Broker 上，以此实现<strong>并行发送和消费</strong>（提高吞吐量的关键）。</p>
</li>
<li>
<p><strong>Consumer Group (消费者组)：</strong> 一组逻辑行为一致的 Consumer。RocketMQ 很多机制（如负载均衡、重试、死信）都是以“组”为单位管理的。</p>
</li>
</ul>
<p><strong>一句话总结它们的协作：</strong> <strong>Producer</strong> 问 <strong>NameServer</strong> 拿到路由，把信（Message）分类（Topic/Tag）后寄给 <strong>Broker</strong>；<strong>Broker</strong> 把信存好；<strong>Consumer</strong> 从 <strong>Broker</strong> 拿信并拆开阅读。</p>
<h2 id="rocketmq的死信队列是怎样的">RocketMQ的死信队列是怎样的？
</h2><p>RocketMQ 的<strong>死信队列 (Dead Letter Queue, 简称 DLQ)</strong> 可以被理解为消息的<strong>ICU或者最终归宿</strong>。</p>
<p>当一条消息被消费者不断重试消费，但仍然失败，达到最大重试次数（默认 16 次）后，RocketMQ 就认为这条消息“没救了”。为了不让这条失败的消息一直堵塞正常业务或无限占用资源，Broker 会把它扔到一个特殊的队列里，这个队列就是死信队列。</p>
<p>以下是关于它的核心机制、特征和使用场景的详细拆解：</p>
<h3 id="1-死信是如何产生的生命周期">1. 死信是如何产生的？（生命周期）
</h3><p>整个过程可以分为三个阶段：</p>
<ol>
<li>
<p><strong>正常消费阶段：</strong> 生产者发送消息到 Topic，消费者尝试消费。</p>
</li>
<li>
<p><strong>重试阶段 (Retry)：</strong></p>
<ul>
<li>
<p>如果你在代码里抛出异常或返回 <code>RECONSUME_LATER</code>（消费失败），Broker 不会立刻丢弃消息，而是把消息发到一个内部的<strong>重试 Topic</strong>（名字叫 <code>%RETRY%消费者组名</code>）。</p>
</li>
<li>
<p>RocketMQ 会按照梯队时间（1s, 5s, 10s, 30s&hellip; 2h）进行<strong>默认 16 次</strong>重试。</p>
</li>
</ul>
</li>
<li>
<p><strong>死信阶段 (DLQ)：</strong></p>
<ul>
<li>如果第 16 次重试依然失败，Broker 就会把这条消息从重试队列移出，发送到<strong>死信 Topic</strong>。</li>
</ul>
</li>
</ol>
<h3 id="2-死信队列的关键特征">2. 死信队列的关键特征
</h3><p>你需要记住以下几个非常具有 RocketMQ 特色的点：</p>
<ul>
<li>
<p><strong>对应关系：</strong> 死信队列是<strong>基于消费者组 (Consumer Group)</strong> 的，而不是基于 Topic 的。</p>
<ul>
<li>
<p>假设你有一个 Topic 叫 <code>Order_Topic</code>，被 <code>Group_A</code> 和 <code>Group_B</code> 订阅。</p>
</li>
<li>
<p>如果 <code>Group_A</code> 消费失败，死信会进 <code>Group_A</code> 专属的死信队列。</p>
</li>
<li>
<p><code>Group_B</code> 不受影响。</p>
</li>
</ul>
</li>
<li>
<p><strong>命名规则：</strong> 死信 Topic 的名字是固定的：<code>%DLQ%消费者组名</code>。</p>
</li>
<li>
<p><strong>默认不可见：</strong> 正常的消费者在启动时，<strong>不会</strong>自动订阅死信 Topic。也就是说，进入死信队列的消息，默认情况下<strong>不再会被消费</strong>，静静地躺在那里。</p>
</li>
<li>
<p><strong>有效期：</strong> 死信队列里的消息也是有有效期的（和普通消息一样，通常 Broker 设置为 3 天）。如果 3 天没人管，它就被物理删除了，数据就真丢了。</p>
</li>
</ul>
<h3 id="3-我们该怎么处理死信消息">3. 我们该怎么处理死信消息？
</h3><p>既然消息进了死信队列，说明你的程序可能有 Bug，或者这条消息的数据有问题（也就是所谓的“毒丸消息”）。</p>
<p>处理死信的标准流程通常是 <strong>“人工干预”</strong>：</p>
<ol>
<li>
<p><strong>告警 (Alert)：</strong></p>
<ul>
<li>你应该监控 <code>%DLQ%</code> 开头的 Topic。一旦发现里面有消息（offset 增加了），立刻给开发人员发告警。</li>
</ul>
</li>
<li>
<p><strong>排查问题 (Debug)：</strong></p>
<ul>
<li>开发人员登录 RocketMQ 控制台（Dashboard），查看死信消息的内容，分析为什么会消费失败（是代码逻辑错了？还是上游发的数据格式不对？）。</li>
</ul>
</li>
<li>
<p><strong>处理 (Action)：</strong></p>
<ul>
<li>
<p><strong>场景 A（Bug 修复了）：</strong> 在控制台上点击**“重发消息” (Resend)**。这会让消息重新回到正常 Topic，再次被消费者消费。</p>
</li>
<li>
<p><strong>场景 B（脏数据）：</strong> 确认数据本身就是错的，没法消费，直接在控制台<strong>跳过/忽略</strong>该消息。</p>
</li>
</ul>
</li>
</ol>
<h3 id="总结">总结
</h3><p>你可以把 RocketMQ 的机制看作一个<strong>分诊系统</strong>：</p>
<ul>
<li>
<p><strong>普通队列：</strong> 普通门诊，处理正常病人。</p>
</li>
<li>
<p><strong>重试队列 (%RETRY%)：</strong> 急诊留观室，病人情况不好，多观察几次，过一会再治治看。</p>
</li>
<li>
<p><strong>死信队列 (%DLQ%)：</strong> 太平间/ICU。常规手段治不好了，将其移出，以免占用医生资源，等待专家（开发者）专门来做尸检（排查问题）或最后决定。</p>
</li>
</ul>
<h2 id="介绍tcp的流量控制和拥塞控制">介绍TCP的流量控制和拥塞控制
</h2><p>虽然这两个概念经常一起出现，但它们的<strong>保护对象</strong>完全不同，这一点是面试时区分的关键：</p>
<ul>
<li>
<p><strong>流量控制 (Flow Control)：</strong> 是为了不把<strong>接收端</strong>填满。是一个<strong>点对点</strong>（Sender to Receiver）的问题。</p>
</li>
<li>
<p><strong>拥塞控制 (Congestion Control)：</strong> 是为了不把<strong>整个网络</strong>（路由器、链路）堵死。是一个<strong>全局性</strong>的问题。</p>
</li>
</ul>
<hr>
<h3 id="1-流量控制-flow-control">1. 流量控制 (Flow Control)
</h3><p><strong>核心机制：滑动窗口 (Sliding Window)</strong></p>
<p>想象一下，你（Sender）在往一个水缸（Receiver 的缓存）里倒水。</p>
<ul>
<li>
<p>接收端有一个<strong>接收窗口 (rwnd, Receive Window)</strong>，代表它的水缸还剩多少空间。</p>
</li>
<li>
<p>接收端会在每次回传 ACK 时，顺便把这个 <code>rwnd</code> 的值带给你，告诉你：“我还剩 100字节 的空间，你最多只能发这么多。”</p>
</li>
<li>
<p>如果接收端处理不过来了，把 <code>rwnd</code> 设为 0，你（发送端）就会停止发送，进入等待状态，直到收到新的窗口更新通知。</p>
<ul>
<li><em>注：为了防止死锁（接收端有了空间发了通知，但通知丢包了），发送端会定期发送“探测包”去问一下接收端。</em></li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-拥塞控制-congestion-control">2. 拥塞控制 (Congestion Control)
</h3><p><strong>核心机制：拥塞窗口 (cwnd, Congestion Window) + 四大算法</strong></p>
<p>流量控制只管接收端能不能吃得消，不管中间的网线、路由器堵不堵。如果网络已经很堵了，你发得越快，丢包越多，网络就越堵（正反馈雪崩）。</p>
<p>为了解决这个问题，发送端自己维护了一个拥塞窗口 (cwnd)。</p>
<p>最终发送窗口 = min(接收端 rwnd, 自身 cwnd)。</p>
<p>TCP 使用以下四个经典算法来动态调整 <code>cwnd</code>：</p>
<h4 id="a-慢启动-slow-start">A. 慢启动 (Slow Start)
</h4><ul>
<li>
<p><strong>原理：</strong> 刚建立连接时，不知道网络深浅，不能一上来就全速发送。</p>
</li>
<li>
<p><strong>过程：</strong></p>
<ul>
<li>
<p>先把 <code>cwnd</code> 设为 1（个 MSS）。</p>
</li>
<li>
<p>收到一个 ACK，<code>cwnd</code> 加 1。</p>
</li>
<li>
<p>收到一轮 ACK 后，<code>cwnd</code> 翻倍（1 $\rightarrow$ 2 $\rightarrow$ 4 $\rightarrow$ 8&hellip;）。</p>
</li>
<li>
<p><strong>呈指数增长</strong>，直到达到一个阈值 (<strong>ssthresh</strong>, slow start threshold)。</p>
</li>
</ul>
</li>
</ul>
<h4 id="b-拥塞避免-congestion-avoidance">B. 拥塞避免 (Congestion Avoidance)
</h4><ul>
<li>
<p><strong>原理：</strong> 当 <code>cwnd</code> 超过 <code>ssthresh</code> 后，说明网络可能快饱和了，不能再翻倍了，要小心翼翼地加。</p>
</li>
<li>
<p><strong>过程：</strong></p>
<ul>
<li>
<p>每经过一个 RTT（往返时间），<code>cwnd</code> 只加 1。</p>
</li>
<li>
<p><strong>呈线性增长</strong>（加法增大），慢慢试探网络的底线。</p>
</li>
</ul>
</li>
</ul>
<h4 id="c-快重传-fast-retransmit">C. 快重传 (Fast Retransmit)
</h4><ul>
<li>
<p><strong>触发条件：</strong> 发送端连续收到 <strong>3 个重复的 ACK</strong>。</p>
<ul>
<li>
<p>比如你发了包 1, 2, 3, 4, 5。接收端收到了 1，没收到 2，收到了 3, 4, 5。</p>
</li>
<li>
<p>接收端收到 3, 4, 5 时，都会回复“我想要 2”（ACK 2）。</p>
</li>
<li>
<p>发送端一连收到 3 个“ACK 2”，就知道包 2 肯定丢了，不用等超时定时器（Timeout），<strong>立刻重传</strong>包 2。</p>
</li>
</ul>
</li>
</ul>
<h4 id="d-快恢复-fast-recovery">D. 快恢复 (Fast Recovery)
</h4><ul>
<li>
<p><strong>原理：</strong> 既然能收到 3 个重复 ACK，说明网络虽然有点堵（丢了个包），但还没完全断（后续的包还能到），不需要像“超时”那样惨烈地重回“慢启动”。</p>
</li>
<li>
<p><strong>过程：</strong></p>
<ul>
<li>
<p>把 <code>ssthresh</code> 设为当前 <code>cwnd</code> 的一半。</p>
</li>
<li>
<p>把 <code>cwnd</code> 也设为当前的一半（或者一半 + 3）。</p>
</li>
<li>
<p>直接进入<strong>拥塞避免</strong>阶段（线性增长）。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 如果是发生<strong>超时 (Timeout)</strong>，说明网络真的很烂了，连 ACK 都回不来。TCP 会判定为严重拥塞，直接把 <code>cwnd</code> 重置为 1，重新开始<strong>慢启动</strong>。</p>
</blockquote>
<hr>
<h3 id="总结对比">总结对比
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>流量控制 (Flow Control)</strong></th>
          <th><strong>拥塞控制 (Congestion Control)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>保护对象</strong></td>
          <td><strong>接收端</strong> (Receiver)</td>
          <td><strong>网络环境</strong> (Network)</td>
      </tr>
      <tr>
          <td><strong>通信范围</strong></td>
          <td>点对点</td>
          <td>全局性</td>
      </tr>
      <tr>
          <td><strong>反馈机制</strong></td>
          <td>接收端在 TCP Header 里显式告诉发送端 (<code>rwnd</code>)</td>
          <td>发送端根据丢包或延迟自己推测 (<code>cwnd</code>)</td>
      </tr>
      <tr>
          <td><strong>核心算法</strong></td>
          <td>滑动窗口 (Sliding Window)</td>
          <td>慢启动、拥塞避免、快重传、快恢复</td>
      </tr>
      <tr>
          <td><strong>发送上限</strong></td>
          <td>取决于接收端的缓冲区大小</td>
          <td>取决于网络带宽和拥塞程度</td>
      </tr>
  </tbody>
</table></div>
<h2 id="http3-quic-可靠传输核心">HTTP/3 (QUIC) 可靠传输核心
</h2><h3 id="1-核心设计传输-id-与数据-id-分离">1. 核心设计：传输 ID 与数据 ID 分离
</h3><p>这是 QUIC 区别于 TCP 最关键的设计，解决了 <strong>重传歧义 (Retransmission Ambiguity)</strong> 问题。</p>
<ul>
<li>
<p><strong>TCP 的做法（混淆）：</strong> 序列号 (Seq) 既代表数据顺序，也代表包的身份。重传时序列号不变，导致发送端无法区分 ACK 到底是回给“原包”的还是“重传包”的，RTT 计算不准。</p>
</li>
<li>
<p><strong>QUIC 的做法（分离）：</strong></p>
<ul>
<li>
<p><strong>Packet Number (包号)：</strong> 这里的“快递单号”。严格递增，<strong>只增不减</strong>。即使是重传，也会用一个新的、更大的 Packet Number。</p>
</li>
<li>
<p><strong>Stream Offset (流偏移量)：</strong> 这里的“书页码”。代表数据在流中的位置，永远不变。</p>
</li>
</ul>
</li>
<li>
<p><strong>重传策略：</strong> 当包 #100 丢了，QUIC 会把 #100 里的旧数据（Offset），装进新的包 #103 里发出去。</p>
</li>
</ul>
<h3 id="2-丢包发现机制-loss-detection">2. 丢包发现机制 (Loss Detection)
</h3><ul>
<li>
<p><strong>接收端的角色：</strong> 接收端<strong>不主动请求</strong>重传，它只是一个诚实的记录员。</p>
</li>
<li>
<p><strong>ACK Ranges (SACK)：</strong> 接收端回复的 ACK 会明确指出收到的范围。例如：“我收到了 #1-#2，以及 #4”。</p>
</li>
<li>
<p><strong>跳号检测：</strong> 发送端收到 ACK 后，发现中间缺了 #3（跳号了），从而意识到可能发生了丢包。</p>
</li>
</ul>
<h3 id="3-什么时候重传threshold">3. 什么时候重传？(Threshold)
</h3><p>发送端发现缺口后，不会立刻重传（防止网络只是抖动/乱序），而是基于阈值判断：</p>
<ul>
<li>
<p><strong>包数量阈值 (Packet Threshold)：</strong> 比如后续又有 3 个包（#4, #5, #6）都到了，#3 还没到，判定 #3 丢失。</p>
</li>
<li>
<p><strong>时间阈值 (Time Threshold)：</strong> 超过一定时间的 RTT 还没到，判定丢失。</p>
</li>
<li>
<p><strong>触发动作：</strong> 发送端主动将丢失的数据取出，封装到新包中发送。</p>
</li>
</ul>
<h3 id="4-误判与虚假重传-spurious-retransmission">4. 误判与虚假重传 (Spurious Retransmission)
</h3><p>针对“如果包传输太慢，会不会被误判为丢失”的问题：</p>
<ul>
<li>
<p><strong>MTU 限制：</strong> 物理传输中不存在“巨大的包”，所有包最大约为 1.5KB (MTU)。包慢通常是因为<strong>排队或路径拥堵</strong>，而不是包太大。</p>
</li>
<li>
<p><strong>确实会误判：</strong> 如果网络抖动过大（超过阈值），发送端会误以为丢包并重传。</p>
</li>
<li>
<p><strong>后果（QUIC 优于 TCP）：</strong></p>
<ul>
<li>
<p>接收端会收到两份数据（旧包迟到了，新包也到了）。</p>
</li>
<li>
<p><strong>QUIC 能完美处理：</strong> 因为两个包的 Packet Number 不同，发送端能区分哪个 ACK 对应哪个包。接收端只需根据 Offset 去重即可。这不会导致 TCP 那样的 RTT 计算混乱。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="形象记忆法快递寄书">形象记忆法：快递寄书
</h3><ol>
<li>
<p><strong>发货：</strong> 用“快递盒 #100”装“第 10 页”。</p>
</li>
<li>
<p><strong>丢包：</strong> 接收端说“收到 #101, #102，没看到 #100”。</p>
</li>
<li>
<p><strong>重传：</strong> 发送端拿个<strong>新盒子</strong> “快递盒 #103”，装入<strong>旧复印件</strong> “第 10 页” 发出去。</p>
</li>
<li>
<p><strong>确认：</strong> 发送端收到“收到 #103”的回执，精确计算耗时，不会搞混。</p>
</li>
</ol>
<h2 id="redis-持久化机制-rdb">Redis 持久化机制 (RDB)
</h2><h3 id="1-核心误区修正">1. 核心误区修正
</h3><ul>
<li>
<p><strong>Page Cache 归属</strong>：Redis 没有自己维护类似 MySQL Buffer Pool 的 Page Cache。所谓的 Page Cache 完全由<strong>操作系统内核 (OS Kernel)</strong> 管理。</p>
</li>
<li>
<p><strong>写入流程</strong>：Redis 只是把数据从堆内存写入到了 OS Page Cache，具体的物理刷盘由 OS 调度。</p>
</li>
</ul>
<h3 id="2-bgsave-标准执行流程-6步">2. BGSAVE 标准执行流程 (6步)
</h3><ol>
<li>
<p><strong>判断</strong>：检查是否有正在执行的 save/bgsave。</p>
</li>
<li>
<p><strong>Fork (阻塞点)</strong>：主线程执行 <code>fork()</code> 创建子进程。<strong>此时主线程阻塞</strong>（仅阻塞页表复制的时间）。</p>
</li>
<li>
<p><strong>COW (写时复制)</strong>：子进程共享父进程物理内存，父进程修改数据时会复制副本，子进程读取的是 fork 瞬间的快照。</p>
</li>
<li>
<p><strong>写入内核</strong>：子进程遍历内存，调用 <code>write()</code> 将数据写入 <strong>OS Page Cache</strong>。</p>
</li>
<li>
<p><strong>替换文件</strong>：写入完成后，原子替换旧的 RDB 文件。</p>
</li>
<li>
<p><strong>异步刷盘</strong>：操作系统负责将 OS Page Cache 中的数据最终刷入磁盘。</p>
</li>
</ol>
<h3 id="3-save-vs-bgsave">3. SAVE vs BGSAVE
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>SAVE</strong></th>
          <th><strong>BGSAVE (生产标准)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>线程</strong></td>
          <td>主线程直接执行</td>
          <td>子进程执行</td>
      </tr>
      <tr>
          <td><strong>阻塞</strong></td>
          <td><strong>全程阻塞</strong> (Stop the World)</td>
          <td>仅 <strong>Fork 瞬间</strong> 阻塞</td>
      </tr>
      <tr>
          <td><strong>场景</strong></td>
          <td>关机维护/迁移</td>
          <td>自动快照/主从复制/日常备份</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h2 id="kafka--rocketmq-存储底层原理">Kafka &amp; RocketMQ 存储底层原理
</h2><h3 id="1-写入与刷盘机制">1. 写入与刷盘机制
</h3><p>两者都利用了<strong>顺序写 (Sequential Write)</strong> 和 <strong>OS Page Cache</strong> 来提升吞吐量。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>Kafka</strong></th>
          <th><strong>RocketMQ</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>写入核心</strong></td>
          <td><code>FileChannel</code> (Buffered IO)</td>
          <td><code>mmap</code> (内存映射)</td>
      </tr>
      <tr>
          <td><strong>刷盘策略</strong></td>
          <td><strong>异步刷盘</strong> (完全依赖 OS)</td>
          <td><strong>异步</strong> (默认) / <strong>同步</strong> (Sync Flush)</td>
      </tr>
      <tr>
          <td><strong>零拷贝技术</strong></td>
          <td><code>sendfile</code> (读路径)</td>
          <td><code>mmap</code> (读写路径)</td>
      </tr>
  </tbody>
</table></div>
<h3 id="2-存储结构lsm-tree-还是-log">2. 存储结构：LSM Tree 还是 Log？
</h3><ul>
<li>
<p><strong>结论</strong>：它们<strong>都不是</strong> LSM Tree。</p>
</li>
<li>
<p><strong>实质</strong>：它们是 <strong>Partitioned Log (分区日志)</strong> 或 <strong>Append-only Log</strong>。</p>
</li>
<li>
<p><strong>区别</strong>：</p>
<ul>
<li>
<p><strong>LSM (HBase/RocksDB)</strong>：为了<strong>随机读 (Get Key)</strong>，需要排序、合并 (Merge/Compaction)。</p>
</li>
<li>
<p><strong>MQ (Kafka/RocketMQ)</strong>：为了<strong>顺序消费 (Stream)</strong>，只追加写，不排序，不合并。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-消费者读取机制-读写分离">3. 消费者读取机制 (读写分离？)
</h3><ul>
<li>
<p><strong>是否等落盘？</strong>：<strong>不需要</strong>。</p>
</li>
<li>
<p><strong>热读 (Hot Read)</strong>：数据刚写入 Page Cache，消费者直接从 Page Cache 读取 (Zero Copy)，此时数据可能还没落盘。</p>
</li>
<li>
<p><strong>可见性控制</strong>：</p>
<ul>
<li>
<p><strong>Kafka</strong>：由 <strong>High Watermark (HW)</strong> 决定，等 ISR 副本同步完即可读。</p>
</li>
<li>
<p><strong>RocketMQ</strong>：由 <strong>Dispatch (构建索引)</strong> 决定，等消息位置写入 <code>ConsumeQueue</code> 即可读。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="rocketmq-主节点挂了怎么办高可用-ha">RocketMQ 主节点挂了怎么办？(高可用 HA)
</h2><p>RocketMQ 的容灾能力取决于部署架构：</p>
<h3 id="1-传统主从架构-master-slave">1. 传统主从架构 (Master-Slave)
</h3><ul>
<li>
<p><strong>表现</strong>：Master 挂掉后，<strong>无法写入</strong>，只能读（Consumer 自动切到 Slave）。</p>
</li>
<li>
<p><strong>恢复</strong>：<strong>无法自动切换</strong>，需要人工运维介入，修改配置重启。</p>
</li>
</ul>
<h3 id="2-dledger-架构-rocketmq-45">2. Dledger 架构 (RocketMQ 4.5+)
</h3><ul>
<li>
<p><strong>原理</strong>：引入 <strong>Raft 协议</strong>。</p>
</li>
<li>
<p><strong>表现</strong>：Master 挂掉后，Broker 组内自动投票选举出新的 Master。</p>
</li>
<li>
<p><strong>结果</strong>：<strong>自动故障转移 (Failover)</strong>，保证写入高可用。</p>
</li>
</ul>
<h3 id="3-controller-模式-rocketmq-50">3. Controller 模式 (RocketMQ 5.0+)
</h3><ul>
<li>
<p><strong>原理</strong>：类似 Kafka Controller，由独立的管控节点监控并指定 Master。</p>
</li>
<li>
<p><strong>优势</strong>：解耦了存储和选主逻辑，更轻量。</p>
</li>
</ul>
<hr>
<h3 id="-核心总结-one-liner">💡 核心总结 (One Liner)
</h3><blockquote>
<p><strong>Redis、Kafka、RocketMQ 的快很大程度上都归功于“借力”——借用操作系统的 Page Cache 和顺序写能力，而不是自己造轮子去管理磁盘 IO；而高可用则是从“人工介入”向“算法自动选举 (Raft)”进化的过程。</strong></p>
</blockquote>
<h2 id="介绍copy-on-write写时复制">介绍Copy-On-Write（写时复制）
</h2><p><strong>Copy-On-Write (COW，写时复制)</strong> 是一种**“拖延战术”**（Lazy Optimization）。</p>
<p>用一句大白话解释就是：<strong>“既然大家读的数据都一样，那就别费劲复制两份了，先共用一份。直到谁真正想修改数据时，再单独给它复制一份出来。”</strong></p>
<p>下面我从<strong>原理、流程、在 Redis 中的体现</strong>以及<strong>潜在坑点</strong>四个方面详细拆解。</p>
<hr>
<h3 id="1-为什么需要-cow传统的-fork-太慢了">1. 为什么需要 COW？（传统的 Fork 太慢了）
</h3><p>在早期的 Unix 系统中，当一个进程执行 <code>fork()</code> 创建子进程时，操作系统会把父进程的所有内存数据**完整拷贝（Deep Copy）**一份给子进程。</p>
<ul>
<li>
<p><strong>后果</strong>：</p>
<ul>
<li>
<p><strong>慢</strong>：如果父进程占用 10GB 内存，拷贝这 10GB 数据需要很长时间，期间 CPU 满载，父进程阻塞。</p>
</li>
<li>
<p><strong>浪费</strong>：很多时候子进程只是为了读取数据（比如 Redis 生成快照），并不修改数据。这时候复制出来的 10GB 数据和父进程的一模一样，纯属浪费内存。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-cow-的执行原理核心-4-步">2. COW 的执行原理（核心 4 步）
</h3><p>现代 Linux 系统在 <code>fork()</code> 时默认开启 COW 机制。</p>
<h4 id="第一步fork-瞬间只复制页表"><strong>第一步：Fork 瞬间（只复制页表）</strong>
</h4><p>当主线程执行 <code>fork()</code> 时，内核<strong>不复制物理内存</strong>，而是只复制<strong>页表 (Page Table)</strong>。</p>
<ul>
<li>
<p><strong>页表</strong>就像是内存的“目录”或“指针”。</p>
</li>
<li>
<p><strong>结果</strong>：父子进程的虚拟内存空间不同，但它们指向的<strong>物理内存地址是完全一样</strong>的。</p>
</li>
<li>
<p><strong>关键动作</strong>：内核会将这些共享的物理内存页标记为 <strong>Read-Only（只读）</strong>。</p>
</li>
</ul>
<h4 id="第二步读取数据相安无事"><strong>第二步：读取数据（相安无事）</strong>
</h4><p>如果父进程和子进程都只是<strong>读</strong>数据：</p>
<ul>
<li>
<p>大家访问同一个物理内存地址，速度极快，互不干扰。</p>
</li>
<li>
<p>内存占用量几乎没有增加（10GB 父进程 + 微量子进程页表 ≈ 10GB）。</p>
</li>
</ul>
<h4 id="第三步尝试写入触发异常"><strong>第三步：尝试写入（触发异常）</strong>
</h4><p>当父进程（或子进程）试图<strong>修改</strong>某个数据页（比如修改 Key <code>user:100</code> 的值）：</p>
<ol>
<li>
<p>CPU 的内存管理单元 (MMU) 发现该页被标记为 <strong>Read-Only</strong>。</p>
</li>
<li>
<p>触发一个<strong>缺页中断 (Page Fault)</strong> 或 <strong>保护异常</strong>，通知操作系统内核。</p>
</li>
</ol>
<h4 id="第四步复制与分离copy-发生"><strong>第四步：复制与分离（Copy 发生）</strong>
</h4><p>操作系统内核捕获这个中断后，执行以下操作：</p>
<ol>
<li>
<p><strong>分配内存</strong>：申请一个新的物理内存页。</p>
</li>
<li>
<p><strong>复制数据</strong>：把旧页面的数据<strong>复制</strong>一份到新页面中。</p>
</li>
<li>
<p><strong>修改映射</strong>：把发起修改的进程的页表指向这个<strong>新页面</strong>，并将权限改为 <strong>Read-Write</strong>。</p>
</li>
<li>
<p><strong>恢复执行</strong>：进程重新执行写入操作，这次就写入到自己的私有页面了。</p>
</li>
</ol>
<blockquote>
<p><strong>结果</strong>：只有被修改的那一小块内存页（通常是 4KB）被复制了，其他未修改的数据依然共享。</p>
</blockquote>
<hr>
<h3 id="3-cow-在-redis-bgsave-中的实战表现">3. COW 在 Redis BGSAVE 中的实战表现
</h3><p>回到 Redis 的场景，假设你的 Redis 占用了 <strong>8GB</strong> 内存。</p>
<ul>
<li>
<p><strong>场景 A：读多写少（绝大部分数据不变更）</strong></p>
<ul>
<li>
<p>Fork 出来的子进程做快照时，大部分内存页面一直未被修改。</p>
</li>
<li>
<p><strong>实际内存开销</strong>：可能只比 8GB 多一点点（比如 8.1GB）。Redis 几乎不需要额外消耗物理内存。</p>
</li>
<li>
<p><strong>性能</strong>：极快，主线程几乎不感觉卡顿。</p>
</li>
</ul>
</li>
<li>
<p><strong>场景 B：写多读少（疯狂修改数据）</strong></p>
<ul>
<li>
<p>在子进程做快照期间，主线程接收了海量写请求，把这 8GB 里的数据几乎全改了一遍。</p>
</li>
<li>
<p><strong>触发 COW</strong>：每改一个页，OS 就要复制一个页。</p>
</li>
<li>
<p><strong>实际内存开销</strong>：随着修改量的增加，内存占用会迅速逼近 <strong>16GB</strong>（8GB 原数据 + 8GB 新数据）。</p>
</li>
<li>
<p><strong>性能</strong>：主线程在写入时会产生轻微的延迟（因为要处理缺页中断和内存拷贝）。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>面试金句</strong>：
&ldquo;Redis 的 BGSAVE 利用了操作系统的 COW 机制。Fork 子进程时并不复制数据，而是共享内存。只有当主线程修改数据时，才会在物理内存中复制被修改的数据页。这使得 Redis 在生成快照时，内存开销通常远小于 2 倍。&rdquo;</p>
</blockquote>
<hr>
<h3 id="4-进阶考点cow-的天敌hugepage-大页内存">4. 进阶考点：COW 的“天敌”——HugePage (大页内存)
</h3><p>这是面试中的一个高阶坑点。</p>
<ul>
<li>
<p><strong>背景</strong>：Linux 默认内存页大小是 <strong>4KB</strong>。但也支持 <strong>2MB</strong> 甚至 1GB 的 HugePage。</p>
</li>
<li>
<p><strong>问题</strong>：</p>
<ul>
<li>
<p>如果你开启了 2MB 的 HugePage。</p>
</li>
<li>
<p>当你只修改了 Redis 中一个 <strong>10 字节</strong> 的 Key。</p>
</li>
<li>
<p>COW 机制为了隔离数据，必须复制整个 <strong>2MB</strong> 的大页。</p>
</li>
</ul>
</li>
<li>
<p><strong>后果</strong>：</p>
<ol>
<li>
<p><strong>内存写放大</strong>：明明只改了一点点，却拷贝了大量内存。</p>
</li>
<li>
<p><strong>延迟增加</strong>：拷贝 2MB 显然比拷贝 4KB 慢得多，会导致主线程在写操作时出现明显的阻塞（Latency Spike）。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p><strong>最佳实践</strong>：
在运行 Redis 的机器上，<strong>强烈建议关闭系统级的 Transparent Huge Pages (THP)</strong>。
命令通常是：<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code></p>
</blockquote>
<h3 id="thp是什么transparent-huge-pages-thp">THP是什么：Transparent Huge Pages (THP)
</h3><ul>
<li>
<p><strong>Huge Pages (大页内存)</strong>：
Linux 默认的内存页大小是 <strong>4KB</strong>。为了提高内存访问效率（减少 TLB 缓存未命中），Linux 支持 <strong>2MB</strong> 甚至 1GB 的“大页”。</p>
</li>
<li>
<p><strong>Transparent (透明)</strong>：
以前使用大页需要手动配置，很麻烦。后来 Linux 搞了个 <strong>THP (Transparent Huge Pages)</strong> 功能。
它作为一个后台线程，会自动扫描内存，如果发现有连续的 4KB 页面，就自动把它们合并成一个 2MB 的大页。这对用户是“透明”的，应用程序不用改代码就能享受大页的好处。</p>
</li>
</ul>
<p><strong>这听起来是个好功能，对吧？但在 Redis 场景下，它变成了“好心办坏事”。</strong></p>
<h2 id="mysql的char和varchar的区别是什么">MySQL的char和varchar的区别是什么
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性 (Feature)</strong></th>
          <th><strong>CHAR(M)</strong></th>
          <th><strong>VARCHAR(M)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>存储方式</strong></td>
          <td><strong>固定长度</strong> (Fixed-length)</td>
          <td><strong>可变长度</strong> (Variable-length)</td>
      </tr>
      <tr>
          <td><strong>空间占用</strong></td>
          <td>始终占用 <strong>M</strong> 个字符的存储空间。</td>
          <td>占用 <strong>实际字符串长度</strong> + <strong>1 或 2 字节</strong>的长度前缀。</td>
      </tr>
      <tr>
          <td><strong>空间填充 (Padding)</strong></td>
          <td>当存储的字符串长度小于 M 时，会在<strong>右侧填充空格</strong> (Trailing spaces)。</td>
          <td>存储时<strong>不会填充</strong>空格，只占用实际需要的空间。</td>
      </tr>
      <tr>
          <td><strong>检索处理</strong></td>
          <td>检索时通常会<strong>自动移除</strong>末尾填充的空格 (除非启用特殊模式)。</td>
          <td>检索时会<strong>保留</strong>所有尾随空格。</td>
      </tr>
      <tr>
          <td><strong>最大长度</strong></td>
          <td><strong>0 到 255</strong> 个字符。</td>
          <td><strong>0 到 65,535</strong> 个字符 (受限于行最大长度 65535 字节)。</td>
      </tr>
      <tr>
          <td><strong>性能/适用场景</strong></td>
          <td>适用于长度<strong>固定不变</strong>的数据 (如：MD5 散列、状态码、性别)。 查询和索引速度通常<strong>更快</strong>。</td>
          <td>适用于长度<strong>变化较大</strong>的数据 (如：姓名、地址、描述)。 <strong>更节省</strong>存储空间。</td>
      </tr>
  </tbody>
</table></div>
<h2 id="介绍常见的jvm实现介绍他们的区别">介绍常见的JVM实现，介绍他们的区别
</h2><h3 id="1-hotspot-vm-oracleopenjdk--绝对的霸主">1. HotSpot VM (Oracle/OpenJDK) —— &ldquo;绝对的霸主&rdquo;
</h3><p>这是目前世界上使用最广泛的 JVM，也是你我日常开发、绝大多数公司生产环境默认使用的版本。</p>
<ul>
<li>
<p><strong>厂商：</strong> Oracle（最初由 Sun 收购的 Longview Technologies 开发）。</p>
</li>
<li>
<p><strong>核心特点：</strong></p>
<ul>
<li>
<p><strong>热点探测 (Hot Spot Detection)：</strong> 它的名字由来。它不预先编译所有代码，而是像侦探一样通过计数器找到执行最频繁的“热点代码”，然后用 JIT (Just-In-Time) 编译器把它们编译成高度优化的本地机器码。</p>
</li>
<li>
<p><strong>双编译器架构：</strong> 拥有 C1 (Client Compiler，编译快但在优化上较保守) 和 C2 (Server Compiler，编译慢但在优化上极其激进) 两个编译器，现在通常混合使用（分层编译）。</p>
</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong> 通杀。从桌面应用到大型微服务集群。</p>
</li>
<li>
<p><strong>现状：</strong> OpenJDK 的默认虚拟机。</p>
</li>
</ul>
<h3 id="2-j9-openj9--ibm-j9--内存管理的艺术大师">2. J9 (OpenJ9 / IBM J9) —— &ldquo;内存管理的艺术大师&rdquo;
</h3><p>如果你在 IBM 的体系（如 AIX 系统、WebSphere 中间件）下工作过，你一定见过它。现在已经贡献给 Eclipse 基金会，改名为 <strong>Eclipse OpenJ9</strong>。</p>
<ul>
<li>
<p><strong>厂商：</strong> IBM（现 Eclipse 基金会）。</p>
</li>
<li>
<p><strong>核心区别 (vs HotSpot)：</strong></p>
<ul>
<li>
<p><strong>内存占用极低：</strong> J9 的设计初衷之一就是为了嵌入式和受限环境。同样的 Spring Boot 应用，跑在 OpenJ9 上通常比 HotSpot <strong>节省 30%~50% 的内存</strong>。</p>
</li>
<li>
<p><strong>启动速度快：</strong> 它利用了 <strong>AOT (Ahead-Of-Time)</strong> 编译技术和<strong>类共享 (Shared Classes)</strong> 机制，使得应用启动非常快。</p>
</li>
<li>
<p><strong>吞吐量稍弱：</strong> 在长时间运行的极限吞吐量测试中，通常略逊于 HotSpot 的 C2 编译器。</p>
</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong> 容器化环境（Docker/K8s）、微服务（因为省内存=省钱）、命令行工具。</p>
</li>
</ul>
<h3 id="3-graalvm--多语言通天塔--原生镜像">3. GraalVM —— &ldquo;多语言通天塔 &amp; 原生镜像&rdquo;
</h3><p>这是 Oracle 实验室搞出来的“新物种”，近年来热度极高。严格来说，它不仅是一个 JVM，更是一个多语言运行时平台。</p>
<ul>
<li>
<p><strong>厂商：</strong> Oracle Labs。</p>
</li>
<li>
<p><strong>核心区别：</strong></p>
<ul>
<li>
<p><strong>Graal Compiler：</strong> 它是用 <strong>Java 写的一个新的 JIT 编译器</strong>，旨在替代 HotSpot 老旧的 C++ 写的 C2 编译器。它的优化能力非常强，尤其是在通过逃逸分析消除对象分配方面。</p>
</li>
<li>
<p><strong>Native Image (原生镜像)：</strong> 这是它最杀手级的功能。它可以把 Java 代码<strong>直接编译成独立的二进制可执行文件</strong>（就像 C++ 编译出来的那样）。</p>
<ul>
<li><strong>结果：</strong> 启动时间从几秒变成 <strong>毫秒级</strong>，内存占用极小。但失去了动态加载类的能力（反射受限）。</li>
</ul>
</li>
<li>
<p><strong>多语言互通：</strong> 你可以在 Java 里无缝调用 Python、R、JavaScript 代码，且性能极高（因为它们最终都变成了 Graal 的中间表示 IR）。</p>
</li>
</ul>
</li>
<li>
<p><strong>适用场景：</strong> Serverless (AWS Lambda 等冷启动敏感场景)、云原生应用、多语言混合开发。</p>
</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>JVM 实现</strong></th>
          <th><strong>别名/特点</strong></th>
          <th><strong>内存占用</strong></th>
          <th><strong>启动速度</strong></th>
          <th><strong>极限吞吐量</strong></th>
          <th><strong>典型场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>HotSpot</strong></td>
          <td>标准版</td>
          <td>中</td>
          <td>中</td>
          <td><strong>极高</strong></td>
          <td>通用，绝大多数互联网后端</td>
      </tr>
      <tr>
          <td><strong>OpenJ9</strong></td>
          <td>省钱版</td>
          <td><strong>极低</strong></td>
          <td><strong>快</strong></td>
          <td>高</td>
          <td>容器、微服务、受限环境</td>
      </tr>
      <tr>
          <td><strong>GraalVM</strong></td>
          <td>未来版/原生版</td>
          <td>低 (Native)</td>
          <td><strong>极快</strong> (Native)</td>
          <td>高</td>
          <td>Serverless、云原生、多语言</td>
      </tr>
      <tr>
          <td><strong>Azul Zing</strong></td>
          <td>氪金版</td>
          <td>高</td>
          <td>快 (ReadyNow)</td>
          <td><strong>极高</strong></td>
          <td>金融高频交易、超大堆内存</td>
      </tr>
  </tbody>
</table></div>
<h2 id="为什么j9比graalvm还省内存">为什么J9比GraalVM还省内存？
</h2><h3 id="1-杀手锏类共享缓存-shared-classes-cache-scc">1. 杀手锏：类共享缓存 (Shared Classes Cache, SCC)
</h3><p>这是 OpenJ9 最核心的黑科技。</p>
<ul>
<li>
<p>HotSpot/GraalVM 的做法：</p>
<p>如果你在同一个机器（或容器宿主机）上启动了 5 个 Spring Boot 应用，HotSpot 会把 java.lang.String、ArrayList 这些基础类的元数据加载 5 次，存在 5 个不同的 Metaspace（元空间）里。这是极大的浪费。</p>
</li>
<li>
<p>OpenJ9 的做法：</p>
<p>它会在磁盘或内存中创建一个 SCC (Shared Classes Cache) 文件。</p>
<p>第一个启动的进程把类加载进来，解析好，扔进 SCC。</p>
<p>后面启动的第 2、3、4、5 个进程，直接映射（mmap）这块内存。它们不需要重新解析类，甚至不需要占用自己的私有内存，直接共用那一份只读内存。</p>
</li>
</ul>
<p><strong>结果：</strong> 在微服务容器化场景下，OpenJ9 能节省惊人的内存（通常 30%~50%），因为 80% 的基础类大家都是一样的。</p>
<h3 id="2-内存管理策略吝啬-vs-豪横">2. 内存管理策略：吝啬 vs. 豪横
</h3><ul>
<li>
<p>HotSpot (GraalVM) —— “占地为王”：</p>
<p>HotSpot 的堆内存策略是为了减少和操作系统的交互。</p>
<p>一旦它向操作系统申请了内存（比如堆涨到了 2GB），即便后来 GC 回收了对象，堆里空了 1.5GB，HotSpot 也往往不愿意把这块物理内存还给操作系统。它会留着，“万一等会儿又要用呢？”</p>
<p>这就导致它的 RSS (常驻集大小，真正的物理内存占用) 一直很高。</p>
</li>
<li>
<p>OpenJ9 —— “用多少借多少”：</p>
<p>OpenJ9 的堆扩容极其“吝啬”。它启动时只申请极小的内存。</p>
<p>更重要的是，GC 发生后，如果发现有空闲内存，它会非常积极地把物理内存归还给操作系统。</p>
<p>这使得它的 RSS 曲线非常贴合实际使用量，而不是像 HotSpot 那样一直顶着上限跑。</p>
</li>
</ul>
<h3 id="3-对象头与指针压缩-compressed-references">3. 对象头与指针压缩 (Compressed References)
</h3><p>虽然 HotSpot 也有指针压缩，但 IBM 在这方面做得更绝。</p>
<ul>
<li>
<p><strong>设计渊源：</strong> J9 最早是 IBM 为小型机甚至嵌入式设备设计的（VisualAge Smalltalk 虚拟机演变而来）。</p>
</li>
<li>
<p><strong>实现细节：</strong> OpenJ9 的对象头（Object Header）设计得非常紧凑，甚至在某些复杂的继承结构和锁状态下，它用的辅助数据结构都比 HotSpot 小。对于成千上万个对象来说，每个少几个字节，总量就很客观了。</p>
</li>
</ul>
<h3 id="4-编译器线程的开销">4. 编译器线程的开销
</h3><ul>
<li>
<p>GraalVM (JIT)：</p>
<p>Graal 编译器本身是用 Java 写的。这意味着 JIT 编译器本身就在消耗 Java 堆内存。当应用刚启动在这个“编译热潮”期，Graal 编译器会产生大量的对象，导致堆内存瞬间飙升。</p>
</li>
<li>
<p>OpenJ9：</p>
<p>它的 JIT 编译器（Testarossa）是用 C++ 写的，而且对线程资源的调度非常克制。它不会为了追求极速启动而瞬间吃掉大量资源（除非你开启了激进模式）。</p>
</li>
</ul>
<hr>
<h3 id="总结-1">总结
</h3><p>为什么 J9 比 GraalVM (JIT模式) 更省内存？</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>OpenJ9</strong></th>
          <th><strong>GraalVM (HotSpot Based)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>多进程复用</strong></td>
          <td><strong>SCC 技术</strong> (多个 JVM 共用一份类元数据)</td>
          <td>无 (每个 JVM 独占一份)</td>
      </tr>
      <tr>
          <td><strong>归还内存</strong></td>
          <td><strong>极度积极</strong> (GC 后立刻还给 OS)</td>
          <td><strong>保守</strong> (倾向于持有内存以换取吞吐量)</td>
      </tr>
      <tr>
          <td><strong>JIT 开销</strong></td>
          <td>C++ 编写，且优化了内存占用</td>
          <td>Java 编写，编译过程本身消耗堆内存</td>
      </tr>
      <tr>
          <td><strong>设计基因</strong></td>
          <td><strong>嵌入式/受限环境</strong> (够用就好)</td>
          <td><strong>服务器/高性能</strong> (性能至上，空间换时间)</td>
      </tr>
  </tbody>
</table></div>
<h3 id="物理真相page-cache-才是真正的幕后金主">物理真相：Page Cache 才是真正的“幕后金主”
</h3><p>当 OpenJ9 调用 <code>mmap</code> 将 SCC 文件映射到内存时，发生了以下事情：</p>
<ol>
<li>
<p><strong>文件映射：</strong> 操作系统并不会立刻把整个 SCC 文件读进内存，而是建立了一个“映射关系”。</p>
</li>
<li>
<p><strong>缺页中断 (Page Fault)：</strong> 当 JVM A 试图读取某个类（比如 <code>java.lang.String</code>）时，CPU 发现这块虚拟地址没有对应物理内存，触发缺页中断。</p>
</li>
<li>
<p><strong>内核加载 (Kernel Load)：</strong> 操作系统内核接管，从磁盘读取这部分数据，放入 <strong>内核管理的 Page Cache（物理 RAM）</strong> 中。</p>
</li>
<li>
<p><strong>建立页表 (Page Table)：</strong> 操作系统修改 JVM A 的页表，让 JVM A 的虚拟地址直接指向这块 <strong>Page Cache 的物理页</strong>。</p>
</li>
</ol>
<p><strong>关键点来了：</strong> 当 <strong>JVM B</strong> 启动并也 <code>mmap</code> 同一个 SCC 文件时：</p>
<ul>
<li>
<p>它也要读 <code>java.lang.String</code>。</p>
</li>
<li>
<p>操作系统一看：“嘿，这个文件的这部分数据已经在 <strong>Page Cache</strong> 里了（因为 JVM A 读过了）。”</p>
</li>
<li>
<p>操作系统直接修改 JVM B 的页表，把它也指向 <strong>同一块 Page Cache 物理页</strong>。</p>
</li>
</ul>
<h3 id="为什么比自己解析还要快">为什么比“自己解析”还要快？
</h3><p>你可能会问：<em>“都在 Page Cache 里，那也只是省了从磁盘读的时间，JVM 不需要解析吗？”</em></p>
<p><strong>这正是 OpenJ9 SCC 的高明之处：</strong> SCC 文件里存的<strong>不是</strong>原始的 <code>.class</code> 字节码（bytecodes），而是<strong>经过 JVM 解析处理后的内部数据结构（ROMClasses）</strong>，甚至包含了 <strong>AOT 编译后的本地机器码</strong>。</p>
<ul>
<li>
<p><strong>普通 JVM (HotSpot)：</strong> 磁盘 <code>.class</code> -&gt; <code>Page Cache</code> -&gt; <strong>Copy 到堆内存</strong> -&gt; <strong>解析验证</strong> -&gt; <strong>生成内部 Class 对象</strong>。 <em>(每个 JVM 都要把这个流程走一遍，并在自己的堆里存一份)</em></p>
</li>
<li>
<p><strong>OpenJ9 (SCC)：</strong> 磁盘 <code>SCC文件</code> (已经是解析好的结构) -&gt; <code>Page Cache</code> -&gt; <strong>JVM 直接指针引用</strong>。 <em>(JVM 不需要解析，不需要 Verify，直接拿指针指过去就能用。这就是所谓的 &ldquo;Pointer Swizzling&rdquo; 技术)</em></p>
</li>
</ul>
<h2 id="1-业务场景ai-流式响应的同步化">1. 业务场景：AI 流式响应的同步化
</h2><p><strong>场景</strong>：在后端调用 AI 模型，既要向前端推送 SSE 流（实时），又要等待完整结果存库（同步）。</p>
<ul>
<li>
<p><strong>解决方案</strong>：<code>CompletableFuture</code> (异步执行 AI 请求) + <code>CountDownLatch</code> (主线程阻塞等待)。</p>
</li>
<li>
<p><strong>核心逻辑</strong>：</p>
<ul>
<li>
<p>主线程 <code>latch.await(30s)</code> 阻塞。</p>
</li>
<li>
<p>异步线程收到 AI 完成信号或报错时，执行 <code>latch.countDown()</code>。</p>
</li>
<li>
<p><strong>优缺</strong>：将异步流强行转为同步阻塞，适合必须存库的场景，但高并发下会占用 Servlet 容器线程。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-juc-工具对比completablefuture-vs-countdownlatch">2. JUC 工具对比：CompletableFuture vs CountDownLatch
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>CompletableFuture</strong></th>
          <th><strong>CountDownLatch</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>本质</strong></td>
          <td><strong>异步编排工具</strong></td>
          <td><strong>同步协作工具</strong></td>
      </tr>
      <tr>
          <td><strong>核心作用</strong></td>
          <td>任务链式处理、回调、组合 (Future 的增强版)</td>
          <td>多线程间的倒计时协调 (A 等 B、C、D 做完)</td>
      </tr>
      <tr>
          <td><strong>阻塞性</strong></td>
          <td><strong>非阻塞</strong> (基于回调 Callback)</td>
          <td><strong>阻塞</strong> (调用 <code>await</code> 的线程被挂起)</td>
      </tr>
      <tr>
          <td><strong>底层</strong></td>
          <td>基于 ForkJoinPool (默认)</td>
          <td>基于 AQS (共享锁模式)</td>
      </tr>
      <tr>
          <td><strong>适用</strong></td>
          <td>复杂的异步任务流 (如调用 AI、微服务聚合)</td>
          <td>并发流程控制 (如压测发令枪、主线程等子线程)</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h2 id="3-并发基石aqs-abstractqueuedsynchronizer">3. 并发基石：AQS (AbstractQueuedSynchronizer)
</h2><p>AQS 是 Java 并发包（Lock, Latch, Semaphore）的<strong>通用骨架</strong>。</p>
<h3 id="31-核心三要素"><strong>3.1 核心三要素</strong>
</h3><ol>
<li>
<p><strong>State (volatile int)</strong>：</p>
<ul>
<li>
<p>同步状态资源。</p>
</li>
<li>
<p>ReentrantLock 中代表“锁占用情况”；CountDownLatch 中代表“倒计时剩余次数”。</p>
</li>
</ul>
</li>
<li>
<p><strong>CLH 队列 (FIFO)</strong>：</p>
<ul>
<li>双向链表，存放抢不到资源、需要排队的线程（Node）。</li>
</ul>
</li>
<li>
<p><strong>Owner Thread</strong>：</p>
<ul>
<li>当前持有资源的线程。</li>
</ul>
</li>
</ol>
<h3 id="32-工作机制"><strong>3.2 工作机制</strong>
</h3><ul>
<li>
<p><strong>抢锁 (Acquire)</strong>：线程尝试用 <strong>CAS</strong> 修改 <code>state</code>。</p>
<ul>
<li>
<p>成功 -&gt; 执行业务。</p>
</li>
<li>
<p>失败 -&gt; 封装成 Node 入队 -&gt; <strong>自旋</strong>重试 -&gt; <strong>阻塞</strong> (<code>LockSupport.park</code>)。</p>
</li>
</ul>
</li>
<li>
<p><strong>释放 (Release)</strong>：修改 <code>state</code> -&gt; 唤醒 (<code>unpark</code>) 队列头部的线程。</p>
</li>
</ul>
<h3 id="33-概念辨析"><strong>3.3 概念辨析</strong>
</h3><ul>
<li>
<p><strong>CAS (砖块)</strong>：CPU 指令 (<code>cmpxchg</code>)，无锁原子操作，是实现 AQS 的基础工具。</p>
</li>
<li>
<p><strong>AQS (图纸)</strong>：定义了排队、阻塞、唤醒的逻辑框架。</p>
</li>
<li>
<p><strong>CountDownLatch (大门)</strong>：基于 AQS 实现的具体工具类。</p>
</li>
<li>
<p><strong>synchronized (房间)</strong>：JVM 层面的互斥锁（Monitor），与 AQS 体系独立。</p>
</li>
</ul>
<hr>
<h2 id="4-线程模型kernel-level-threads-klt">4. 线程模型：Kernel-Level Threads (KLT)
</h2><p>Java 线程与操作系统线程是 <strong>1:1</strong> 映射关系。</p>
<h3 id="41-运行位置辨析易错点"><strong>4.1 运行位置辨析（易错点）</strong>
</h3><ul>
<li>
<p><strong>身份</strong>：Java 线程是<strong>内核级线程</strong>（由 OS 内核管理、调度、发工资）。</p>
</li>
<li>
<p><strong>工作地点</strong>：</p>
<ul>
<li>
<p><strong>90% 时间</strong>：在<strong>用户态 (User Mode)</strong> 运行，执行 JVM 里的 Java 字节码（如 <code>i++</code>, <code>Map.put</code>）。</p>
</li>
<li>
<p><strong>10% 时间</strong>：在<strong>内核态 (Kernel Mode)</strong> 运行，当发起<strong>系统调用</strong>（如 IO、Thread Park）时。</p>
</li>
</ul>
</li>
</ul>
<h3 id="42-运行机制"><strong>4.2 运行机制</strong>
</h3><ul>
<li>
<p><strong>双栈结构</strong>：每个线程拥有 <strong>User Stack</strong> (运行 Java 代码) 和 <strong>Kernel Stack</strong> (运行内核代码)。</p>
</li>
<li>
<p><strong>陷阱 (Trap)</strong>：线程从用户态切换到内核态的过程。</p>
</li>
<li>
<p><strong>开销</strong>：上下文切换 (Context Switch) 成本高，因为涉及 TLB 刷新、寄存器保存、特权级切换 (Ring 3 -&gt; Ring 0)。</p>
</li>
</ul>
<hr>
<h2 id="5-jni-与系统调用-system-call">5. JNI 与系统调用 (System Call)
</h2><h3 id="51-jni-java-native-interface"><strong>5.1 JNI (Java Native Interface)</strong>
</h3><ul>
<li>
<p><strong>本质</strong>：Java 调用 C/C++ 代码的桥梁。</p>
</li>
<li>
<p><strong>通信方式</strong>：<strong>进程内直接调用</strong>，非 IPC（进程间通信）。Java 和 C++ 代码在同一个进程地址空间。</p>
</li>
<li>
<p><strong>是否陷入内核？</strong>：<strong>否</strong>。调用 JNI 方法本身只是 CPU 指令跳转，依然在用户态。</p>
</li>
</ul>
<h3 id="52-系统调用-system-call"><strong>5.2 系统调用 (System Call)</strong>
</h3><ul>
<li>
<p><strong>本质</strong>：用户态程序请求操作系统服务的接口（如 <code>read</code>, <code>write</code>, <code>futex</code>）。</p>
</li>
<li>
<p><strong>触发</strong>：通常由 JNI 调用的 C++ 代码（如 glibc 库）发起汇编指令（<code>SYSCALL</code>/<code>INT 0x80</code>）。</p>
</li>
<li>
<p><strong>结果</strong>：CPU 发生<strong>陷入 (Trap)</strong>，切换到内核态，在内核栈执行 OS 代码。</p>
</li>
</ul>
<h3 id="53-完整链路以-file-read-为例"><strong>5.3 完整链路（以 File Read 为例）</strong>
</h3><ol>
<li>
<p><strong>Java</strong>: <code>FileInputStream.read()</code> (用户态)</p>
</li>
<li>
<p><strong>JNI</strong>: <code>read0()</code> -&gt; <code>JVM_Read</code> (用户态，跳转到 C++)</p>
</li>
<li>
<p><strong>C/C++</strong>: 调用 glibc <code>read()</code> (用户态)</p>
</li>
<li>
<p><strong>Assembly</strong>: 执行 <code>SYSCALL</code> 指令 (触发点)</p>
</li>
<li>
<p><strong>Kernel</strong>: CPU 陷入内核态 -&gt; 执行文件系统驱动 -&gt; 读取硬盘 (内核态)</p>
</li>
<li>
<p><strong>Return</strong>: 数据拷回用户缓冲区 -&gt; 返回 Java (回到用户态)</p>
</li>
</ol>
<h2 id="1-spring-boottomcat-的核心网络模型">1. Spring Boot/Tomcat 的核心网络模型
</h2><p><strong>结论</strong>：Spring Boot（默认 Tomcat）底层确实使用了 <strong>I/O 多路复用</strong>。</p>
<h3 id="11-工作流程">1.1 工作流程
</h3><p>在 Linux 环境下，Tomcat（NioEndpoint）通过 JDK NIO 映射到内核的 <strong><code>epoll</code></strong> 机制。</p>
<ol>
<li>
<p><strong>监听 (<code>Poller</code>)</strong>：Tomcat 使用少量的 <code>Poller</code> 线程（持有 <code>Selector</code>）通过 <code>epoll_wait</code> 监听成千上万个连接。</p>
</li>
<li>
<p><strong>触发</strong>：仅当网卡接收到数据，并通过中断写入内核缓冲区后，<code>epoll</code> 才会唤醒 <code>Poller</code> 线程。</p>
</li>
<li>
<p><strong>分发 (<code>Dispatch</code>)</strong>：<code>Poller</code> 将就绪的 Socket 封装成任务，丢给 <strong>Worker 线程池</strong>。</p>
</li>
<li>
<p><strong>处理</strong>：Worker 线程执行 <code>read()</code>（将数据从内核态拷贝到用户态）、解析 HTTP、执行 Controller 业务逻辑。</p>
</li>
</ol>
<h3 id="12-关键区分">1.2 关键区分
</h3><ul>
<li>
<p><strong>硬件层</strong>：网卡到内核的数据传输由 <strong>硬中断/软中断</strong> 处理（不涉及 epoll）。</p>
</li>
<li>
<p><strong>应用层</strong>：内核通知应用“有数据了”，才是 <strong>epoll</strong> 发挥作用的地方。</p>
</li>
</ul>
<hr>
<h2 id="2-架构对比tomcat-nio-vs-redis-60">2. 架构对比：Tomcat NIO vs Redis 6.0+
</h2><p>两者都利用多线程来减轻主线程在 <strong>“内核态 -&gt; 用户态”数据拷贝 (<code>read/write</code>)</strong> 上的 CPU 开销，但业务处理模型截然不同。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>Tomcat (NIO + ThreadPool)</strong></th>
          <th><strong>Redis 6.0+ (IO Threads)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>IO 读写执行者</strong></td>
          <td><strong>Worker 线程</strong> (并发)</td>
          <td><strong>辅助 IO 线程</strong> (并发)</td>
      </tr>
      <tr>
          <td><strong>业务逻辑执行者</strong></td>
          <td><strong>Worker 线程</strong> (并发)</td>
          <td><strong>Main 线程</strong> (单线程)</td>
      </tr>
      <tr>
          <td><strong>并发安全性</strong></td>
          <td><strong>需考虑锁</strong> (多线程并发执行业务)</td>
          <td><strong>无需锁</strong> (业务逻辑串行)</td>
      </tr>
      <tr>
          <td><strong>设计哲学</strong></td>
          <td><strong>全栈代理</strong>：Worker 负责从读写到业务的全流程。</td>
          <td><strong>工具人模式</strong>：IO 线程只负责搬运数据，主线程独掌大权。</td>
      </tr>
  </tbody>
</table></div>
<ul>
<li>
<p><strong>形象比喻</strong>：</p>
<ul>
<li>
<p><strong>Tomcat</strong>：多个服务员同时接待客人，每个人既负责点菜也负责炒菜（并发高，需解决资源竞争）。</p>
</li>
<li>
<p><strong>Redis</strong>：多个帮厨只负责洗菜切菜，所有菜都由同一个主厨亲自炒（无竞争，速度极快）。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3-java-io-模型演进-bio-vs-nio-vs-aio">3. Java I/O 模型演进 (BIO vs NIO vs AIO)
</h2><p>核心区别在于 <strong>“谁在等数据”</strong> 和 <strong>“谁在拷贝数据”</strong>。</p>
<h3 id="31-bio-blocking-io---jdk-14-前">3.1 BIO (Blocking I/O) - JDK 1.4 前
</h3><ul>
<li>
<p><strong>机制</strong>：<strong>One Thread Per Connection</strong>。</p>
</li>
<li>
<p><strong>痛点</strong>：线程在 <code>read()</code> 时，如果没数据会<strong>死等</strong>（阻塞）。</p>
</li>
<li>
<p><strong>状态</strong>：1000 个连接需要 1000 个线程，资源消耗极大。Tomcat 已弃用。</p>
</li>
</ul>
<h3 id="32-nio-non-blocking-io---jdk-14-tomcat-默认">3.2 NIO (Non-blocking I/O) - JDK 1.4+ (Tomcat 默认)
</h3><ul>
<li>
<p><strong>机制</strong>：<strong>多路复用 (Epoll/Selector)</strong>。</p>
</li>
<li>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p><strong>等数据</strong>：由 <code>Selector</code>（内核 epoll）负责，线程不阻塞。</p>
</li>
<li>
<p><strong>拷贝数据</strong>：数据就绪后，<strong>Worker 线程自己</strong>负责调用 <code>read()</code> 拷贝数据（此处是同步的）。</p>
</li>
</ol>
</li>
<li>
<p><strong>优势</strong>：少量线程管理海量连接。</p>
</li>
</ul>
<h3 id="33-aio-asynchronous-io---jdk-17">3.3 AIO (Asynchronous I/O) - JDK 1.7+
</h3><ul>
<li>
<p><strong>机制</strong>：<strong>Proactor (异步回调)</strong>。</p>
</li>
<li>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>应用发起读请求后<strong>直接返回</strong>。</p>
</li>
<li>
<p><strong>操作系统</strong>负责等待数据 <strong>并</strong> 将数据拷贝到用户内存。</p>
</li>
<li>
<p>全部做完后，操作系统回调通知应用。</p>
</li>
</ol>
</li>
<li>
<p><strong>现状</strong>：</p>
<ul>
<li>
<p>Windows (<code>IOCP</code>) 支持完美。</p>
</li>
<li>
<p>Linux 底层缺乏真正 AIO 支持（本质还是 epoll 模拟），性能提升不明显且复杂。</p>
</li>
<li>
<p>因此 <strong>Tomcat 和 Netty 均未采用 AIO</strong>。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="4-操作系统底层差异-linux-vs-windows">4. 操作系统底层差异 (Linux vs Windows)
</h2><h3 id="41-bio-的线程代价">4.1 BIO 的线程代价
</h3><ul>
<li>
<p><strong>1:1 模型</strong>：Java 的一个用户线程 = 操作系统的一个内核线程 (LWP)。</p>
</li>
<li>
<p><strong>阻塞后果</strong>：BIO 模式下，如果有 N 个 Socket，内核中就有 N 个线程处于阻塞状态，导致<strong>上下文切换</strong>和<strong>内存占用</strong>极高。</p>
</li>
</ul>
<h3 id="42-为什么服务器首选-linux">4.2 为什么服务器首选 Linux？
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>Linux</strong></th>
          <th><strong>Windows</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>核心机制</strong></td>
          <td><strong>epoll</strong> (高效、被动通知)</td>
          <td><strong>IOCP</strong> (异步、主动通知)</td>
      </tr>
      <tr>
          <td><strong>内核设计</strong></td>
          <td>专为服务器吞吐量优化，系统调用开销低。</td>
          <td>兼顾桌面响应性，内核对象复杂，高频 Syscall 开销较大。</td>
      </tr>
      <tr>
          <td><strong>生态</strong></td>
          <td>Java/Tomcat/Redis 等中间件原生适配度最高。</td>
          <td>虽然支持，但在高并发网络 I/O 场景下通常不如 Linux 高效。</td>
      </tr>
  </tbody>
</table></div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 LuciusWan
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
