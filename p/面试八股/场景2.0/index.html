<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="上一个太庞大了，新开一个（">
<title>面试八股/场景2.0</title>

<link rel='canonical' href='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="面试八股/场景2.0">
<meta property='og:description' content="上一个太庞大了，新开一个（">
<meta property='og:url' content='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/'>
<meta property='og:site_name' content='LuciusWan'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-11-25T11:43:54&#43;08:00'/><meta property='article:modified_time' content='2025-11-25T11:43:54&#43;08:00'/>
<meta name="twitter:title" content="面试八股/场景2.0">
<meta name="twitter:description" content="上一个太庞大了，新开一个（">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_9fb38d5acaa6ba70.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🎇</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">LuciusWan</a></h1>
            <h2 class="site-description">欢迎来到我的blog</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/440554295'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v6a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4v-6z" /><path d="M8 3l2 3" /><path d="M16 3l-2 3" /><path d="M9 13v-2" /><path d="M15 11v2" /></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/LuciusWan'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#介绍一下rdb和aof">介绍一下RDB和AOF</a>
      <ol>
        <li><a href="#1-rdb-redis-database--快照模式">1. RDB (Redis Database) —— 快照模式</a>
          <ol>
            <li><a href="#工作原理"><strong>工作原理</strong></a></li>
            <li><a href="#-优点"><strong>✅ 优点</strong></a></li>
            <li><a href="#-缺点"><strong>❌ 缺点</strong></a></li>
          </ol>
        </li>
        <li><a href="#2-aof-append-only-file--日志模式">2. AOF (Append Only File) —— 日志模式</a>
          <ol>
            <li><a href="#工作原理-1"><strong>工作原理</strong></a></li>
            <li><a href="#-优点-1"><strong>✅ 优点</strong></a></li>
            <li><a href="#-缺点-1"><strong>❌ 缺点</strong></a></li>
          </ol>
        </li>
        <li><a href="#3-rdb-vs-aof-核心对比">3. RDB vs AOF 核心对比</a></li>
        <li><a href="#1-rdb-redis-database--快照模式-1">1. RDB (Redis Database) —— 快照模式</a>
          <ol>
            <li><a href="#工作原理-2"><strong>工作原理</strong></a></li>
            <li><a href="#-优点-2"><strong>✅ 优点</strong></a></li>
            <li><a href="#-缺点-2"><strong>❌ 缺点</strong></a></li>
          </ol>
        </li>
        <li><a href="#2-aof-append-only-file--日志模式-1">2. AOF (Append Only File) —— 日志模式</a>
          <ol>
            <li><a href="#工作原理-3"><strong>工作原理</strong></a></li>
            <li><a href="#-优点-3"><strong>✅ 优点</strong></a></li>
            <li><a href="#-缺点-3"><strong>❌ 缺点</strong></a></li>
          </ol>
        </li>
        <li><a href="#3-rdb-vs-aof-核心对比-1">3. RDB vs AOF 核心对比</a></li>
        <li><a href="#4-最佳实践混合持久化-redis-40">4. 最佳实践：混合持久化 (Redis 4.0+)</a></li>
      </ol>
    </li>
    <li><a href="#进程和线程的区别">进程和线程的区别</a>
      <ol>
        <li><a href="#核心区别详解">核心区别详解</a>
          <ol>
            <li><a href="#1-资源的拥有权resource-ownership">1. 资源的拥有权（Resource Ownership）</a></li>
            <li><a href="#2-调度与开销overhead--switching">2. 调度与开销（Overhead &amp; Switching）</a></li>
            <li><a href="#3-通信方式communication">3. 通信方式（Communication）</a></li>
            <li><a href="#4-健壮性与隔离性stability">4. 健壮性与隔离性（Stability）</a></li>
          </ol>
        </li>
        <li><a href="#对比总结表">对比总结表</a></li>
      </ol>
    </li>
    <li><a href="#redis的内存淘汰机制">Redis的内存淘汰机制</a>
      <ol>
        <li><a href="#1-两个核心维度">1. 两个核心维度</a></li>
        <li><a href="#redis-的-lru-是真的-lru-吗">Redis 的 LRU 是真的 LRU 吗？</a></li>
        <li><a href="#redis的各种淘汰策略">Redis的各种淘汰策略</a></li>
      </ol>
    </li>
    <li><a href="#java的双亲委派模型是什么">Java的双亲委派模型是什么？</a>
      <ol>
        <li><a href="#1-谁是双亲类加载器的层级">1. 谁是“双亲”？（类加载器的层级）</a></li>
        <li><a href="#2-委派流程怎么工作">2. 委派流程（怎么工作？）</a></li>
        <li><a href="#3-为什么要这么设计核心作用">3. 为什么要这么设计？（核心作用）</a>
          <ol>
            <li><a href="#-1-安全性-security--防止核心-api-被篡改">✅ 1. 安全性 (Security) —— 防止核心 API 被篡改</a></li>
            <li><a href="#-2-避免重复加载-uniqueness">✅ 2. 避免重复加载 (Uniqueness)</a></li>
          </ol>
        </li>
        <li><a href="#4-什么时候需要打破双亲委派">4. 什么时候需要打破双亲委派？</a></li>
      </ol>
    </li>
    <li><a href="#hashmap与concurenthashmap的区别">HashMap与ConcurentHashMap的区别</a>
      <ol>
        <li><a href="#核心区别详解-1">核心区别详解</a>
          <ol>
            <li><a href="#-线程安全性-thread-safety">① 线程安全性 (Thread Safety)</a></li>
            <li><a href="#-锁的粒度-locking-granularity--性能的关键">② 锁的粒度 (Locking Granularity) —— 性能的关键</a></li>
          </ol>
        </li>
        <li><a href="#1-cas-compare-and-swap--冲锋在前的轻骑兵">1. CAS (Compare And Swap) —— 冲锋在前的“轻骑兵”</a>
          <ol>
            <li><a href="#cas-在哪里用"><strong>CAS 在哪里用？</strong></a></li>
            <li><a href="#cas-的潜在问题"><strong>CAS 的潜在问题：</strong></a></li>
          </ol>
        </li>
        <li><a href="#2-synchronized--坐镇后方的重装卫士">2. Synchronized —— 坐镇后方的“重装卫士”</a>
          <ol>
            <li><a href="#synchronized-在哪里用"><strong>Synchronized 在哪里用？</strong></a></li>
          </ol>
        </li>
        <li><a href="#底层实现深度对比-jdk-17-vs-jdk-18">底层实现深度对比 (JDK 1.7 vs JDK 1.8)</a>
          <ol>
            <li><a href="#hashmap">HashMap</a></li>
            <li><a href="#concurrenthashmap-进化史">ConcurrentHashMap (进化史)</a></li>
          </ol>
        </li>
        <li><a href="#3-总结对比表">3. 总结对比表</a></li>
        <li><a href="#为什么要用synchronized去处理hash冲突">为什么要用synchronized去处理hash冲突</a>
          <ol>
            <li><a href="#cas-的射程只有-1-个变量-one-word">CAS 的“射程”只有 1 个变量 (One Word)</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#redis挂了rocketmq挂了都怎么处理">Redis挂了RocketMQ挂了都怎么处理</a>
      <ol>
        <li><a href="#redis-挂了怎么处理">Redis 挂了怎么处理？</a>
          <ol>
            <li><a href="#1-架构层面事前别让它挂">1. 架构层面（事前：别让它挂）</a></li>
            <li><a href="#2-应用层面事中挂了怎么办">2. 应用层面（事中：挂了怎么办）</a></li>
            <li><a href="#3-关于分布式锁">3. 关于分布式锁</a></li>
          </ol>
        </li>
        <li><a href="#mq-消息队列-挂了怎么处理">MQ (消息队列) 挂了怎么处理？</a>
          <ol>
            <li><a href="#1-架构层面事前别让它挂-1">1. 架构层面（事前：别让它挂）</a></li>
            <li><a href="#2-应用层面事中生产者发不出去怎么办">2. 应用层面（事中：生产者发不出去怎么办？）</a></li>
            <li><a href="#3-应用层面事中消费者收不到怎么办">3. 应用层面（事中：消费者收不到怎么办？）</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#介绍tidb的计算与存储分离和mysql的区别是什么">介绍TiDB的计算与存储分离，和MySQL的区别是什么</a>
      <ol>
        <li><a href="#一-tidb-的计算与存储分离架构">一、 TiDB 的计算与存储分离架构</a>
          <ol>
            <li><a href="#1-计算层tidb-server无状态的大脑">1. 计算层：TiDB Server（无状态的“大脑”）</a></li>
            <li><a href="#2-存储层tikv分布式的肚子">2. 存储层：TiKV（分布式的“肚子”）</a></li>
            <li><a href="#3-调度层pd-placement-driver总指挥">3. 调度层：PD (Placement Driver)（“总指挥”）</a></li>
          </ol>
        </li>
        <li><a href="#二-tidb-与-mysql-的核心区别">二、 TiDB 与 MySQL 的核心区别</a></li>
      </ol>
    </li>
    <li><a href="#为什么lua脚本能保证原子性">为什么lua脚本能保证原子性？</a>
      <ol>
        <li><a href="#1-核心机制单线程--独占模式">1. 核心机制：单线程 + 独占模式</a></li>
        <li><a href="#面试高阶陷阱此原子性非彼原子性">面试高阶陷阱：此“原子性”非彼“原子性”</a></li>
        <li><a href="#为什么这比-redis原生事务更强">为什么这比 Redis原生事务更强？</a></li>
      </ol>
    </li>
    <li><a href="#介绍一下虚拟内存">介绍一下虚拟内存</a>
      <ol>
        <li><a href="#二-虚拟内存的机制怎么圆这个谎">二、 虚拟内存的机制（怎么圆这个谎？）</a>
          <ol>
            <li><a href="#1-核心道具页表-page-table--mmu">1. 核心道具：页表 (Page Table) &amp; MMU</a></li>
            <li><a href="#2-工作流程">2. 工作流程</a></li>
            <li><a href="#缺页中断-page-fault--空手套白狼">缺页中断 (Page Fault) —— “空手套白狼”</a></li>
            <li><a href="#交换-swap--硬盘来凑数">交换 (Swap) —— 硬盘来凑数</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#进程切换和线程切换的区别">进程切换和线程切换的区别?</a></li>
    <li><a href="#线程切换为什么比进程切换快节省了什么资源">线程切换为什么比进程切换快，节省了什么资源?</a></li>
    <li><a href="#jni是什么">JNI 是什么？</a>
      <ol>
        <li><a href="#jni-的核心概念与作用">JNI 的核心概念与作用</a>
          <ol>
            <li><a href="#1-核心定义">1. 核心定义</a></li>
            <li><a href="#2-主要作用">2. 主要作用</a></li>
          </ol>
        </li>
        <li><a href="#jni-的缺点">JNI 的缺点</a></li>
      </ol>
    </li>
    <li><a href="#springboot程序的jdbc连接到了mysql用的是uds请问流程是什么">SpringBoot程序的JDBC连接到了MySQL，用的是UDS，请问流程是什么</a>
      <ol>
        <li><a href="#场景准备">场景准备</a></li>
        <li><a href="#二-详细连接流程从发起请求到拿到数据">二、 详细连接流程（从发起请求到拿到数据）</a>
          <ol>
            <li><a href="#第一阶段建立连接握手">第一阶段：建立连接（握手）</a></li>
            <li><a href="#第二阶段发送-sql写数据">第二阶段：发送 SQL（写数据）</a></li>
            <li><a href="#第三阶段返回结果读数据">第三阶段：返回结果（读数据）</a></li>
          </ol>
        </li>
        <li><a href="#如果用-tcp-127001-流程有啥区别">如果用 TCP (127.0.0.1) 流程有啥区别？</a></li>
      </ol>
    </li>
    <li><a href="#redis把数据从内核内存区拷贝到用户内存的过程">Redis把数据从内核内存区拷贝到用户内存的过程</a>
      <ol>
        <li><a href="#详细流程图解从-socket-到-redis">详细流程图解（从 Socket 到 Redis）</a>
          <ol>
            <li><a href="#第一步数据到达内核">第一步：数据到达内核</a></li>
            <li><a href="#第二步redis-醒来">第二步：Redis 醒来</a></li>
            <li><a href="#第三步读取与执行">第三步：读取与执行</a></li>
            <li><a href="#第四步回复客户端">第四步：回复客户端</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#操作系统的io多路复用selectpollepoll">操作系统的IO多路复用select，poll，epoll</a>
      <ol>
        <li><a href="#1-物理位置">1. 物理位置</a></li>
        <li><a href="#2-发送过程-write">2. 发送过程 (write)</a></li>
        <li><a href="#3-接收过程-read">3. 接收过程 (read)</a></li>
      </ol>
    </li>
    <li><a href="#内核内存和socket是什么">内核内存和Socket是什么？</a>
      <ol>
        <li><a href="#内核内存-kernel-memory--皇宫禁地">内核内存 (Kernel Memory) —— “皇宫禁地”</a></li>
        <li><a href="#socket-是什么-插座与缓冲区">Socket 是什么？—— “插座与缓冲区”</a></li>
      </ol>
    </li>
    <li><a href="#传统的java17是用户级线程和内核级线程一对一处理">传统的Java17，是用户级线程和内核级线程一对一处理</a>
      <ol>
        <li><a href="#一-核心关系傀儡与真身">一、 核心关系：傀儡与真身</a></li>
        <li><a href="#二-它们怎么通信控制权传递">二、 它们怎么“通信”？（控制权传递）</a>
          <ol>
            <li><a href="#1-启动指令start">1. 启动指令：<code>start()</code></a></li>
            <li><a href="#2-行为控制sleep--yield--park">2. 行为控制：<code>sleep()</code> / <code>yield()</code> / <code>park()</code></a></li>
            <li><a href="#3-阻塞同步io-操作">3. 阻塞同步：IO 操作</a></li>
          </ol>
        </li>
        <li><a href="#三-它们怎么调度谁说了算">三、 它们怎么调度？（谁说了算？）</a>
          <ol>
            <li><a href="#1-调度者os-调度器比如-linux-的-cfs">1. 调度者：OS 调度器（比如 Linux 的 CFS）</a></li>
            <li><a href="#2-调度方式抢占式-preemptive">2. 调度方式：抢占式 (Preemptive)</a></li>
            <li><a href="#3-java-优先级的尴尬">3. Java 优先级的尴尬</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#synchronized的底层原理">synchronized的底层原理</a>
      <ol>
        <li><a href="#第一层数据结构层--mark-word-的比特位舞步">第一层：数据结构层 —— Mark Word 的比特位舞步</a></li>
        <li><a href="#第二层栈帧层--lock-record-锁记录">第二层：栈帧层 —— Lock Record (锁记录)</a></li>
        <li><a href="#第三层jvm-实现层--c-里的-objectmonitor">第三层：JVM 实现层 —— C++ 里的 ObjectMonitor</a></li>
        <li><a href="#第四层操作系统与硬件层--futex-与-内存屏障">第四层：操作系统与硬件层 —— Futex 与 内存屏障</a>
          <ol>
            <li><a href="#1-操作系统mutex-与-futex">1. 操作系统：Mutex 与 Futex</a></li>
            <li><a href="#2-cpu-硬件内存语义-jmm">2. CPU 硬件：内存语义 (JMM)</a></li>
          </ol>
        </li>
        <li><a href="#总结一条线程的黑化之路">总结：一条线程的“黑化”之路</a></li>
      </ol>
    </li>
    <li><a href="#介绍一下java里的volatile">介绍一下Java里的volatile</a>
      <ol>
        <li><a href="#1-核心特性">1. 核心特性</a>
          <ol>
            <li><a href="#a-保证可见性-visibility">A. 保证可见性 (Visibility)</a></li>
            <li><a href="#b-禁止指令重排序-ordering">B. 禁止指令重排序 (Ordering)</a></li>
            <li><a href="#c-不保证原子性-no-atomicity">C. 不保证原子性 (No Atomicity)</a></li>
          </ol>
        </li>
        <li><a href="#3-什么时候使用-volatile">3. 什么时候使用 volatile？</a>
          <ol>
            <li><a href="#常见场景-1状态标记量-flag">常见场景 1：状态标记量 (Flag)</a></li>
            <li><a href="#常见场景-2单例模式-double-checked-locking">常见场景 2：单例模式 (Double-Checked Locking)</a></li>
          </ol>
        </li>
        <li><a href="#4-总结volatile-vs-synchronized">4. 总结：volatile vs synchronized</a></li>
        <li><a href="#它保证的顺序禁止内部瞎优化指令重排">它保证的“顺序”：禁止<strong>内部</strong>瞎优化（指令重排）</a></li>
        <li><a href="#2-它无法改变的并发无法阻止外部线程的插队">2. 它无法改变的“并发”：无法阻止<strong>外部</strong>线程的“插队”</a></li>
      </ol>
    </li>
    <li><a href="#讲解java的threadlocal">讲解Java的ThreadLocal</a>
      <ol>
        <li><a href="#1-核心概念">1. 核心概念</a></li>
        <li><a href="#2-核心应用场景">2. 核心应用场景</a></li>
        <li><a href="#3-底层原理重点threadlocalmap">3. 底层原理（重点：ThreadLocalMap）</a>
          <ol>
            <li><a href="#31-真实的存储结构">3.1 真实的存储结构</a></li>
            <li><a href="#32-引用关系图">3.2 引用关系图</a></li>
            <li><a href="#33-hash-冲突解决">3.3 Hash 冲突解决</a></li>
          </ol>
        </li>
        <li><a href="#4-著名的内存泄漏问题">4. 著名的内存泄漏问题</a>
          <ol>
            <li><a href="#41-为什么会泄漏">4.1 为什么会泄漏？</a></li>
            <li><a href="#42-各种补救措施探测式清理">4.2 各种补救措施（探测式清理）</a></li>
            <li><a href="#43-终极解决方案">4.3 终极解决方案</a></li>
          </ol>
        </li>
        <li><a href="#5-最佳实践代码示例">5. 最佳实践代码示例</a></li>
        <li><a href="#6-父子线程传递-inheritablethreadlocal">6. 父子线程传递 (<code>InheritableThreadLocal</code>)</a></li>
        <li><a href="#总结">总结</a></li>
      </ol>
    </li>
    <li><a href="#redo-log是什么">Redo Log是什么</a>
      <ol>
        <li><a href="#1-为什么需要-redo-log">1. 为什么需要 Redo Log？</a></li>
        <li><a href="#2-redo-log-的工作原理">2. Redo Log 的工作原理</a>
          <ol>
            <li><a href="#物理结构">物理结构</a></li>
            <li><a href="#写入流程-循环写入">写入流程 (循环写入)</a></li>
          </ol>
        </li>
        <li><a href="#3-关键参数innodb_flush_log_at_trx_commit">3. 关键参数：innodb_flush_log_at_trx_commit</a></li>
        <li><a href="#4-重点区分redo-log-vs-binlog">4. 重点区分：Redo Log vs Binlog</a></li>
        <li><a href="#5-总结">5. 总结</a></li>
      </ol>
    </li>
    <li><a href="#bin-log是什么">Bin Log是什么</a>
      <ol>
        <li><a href="#1-核心作用">1. 核心作用</a></li>
        <li><a href="#2-记录格式-binlog_format">2. 记录格式 (binlog_format)</a></li>
        <li><a href="#3-写入机制-append-only">3. 写入机制 (Append Only)</a></li>
        <li><a href="#4-关键参数sync_binlog">4. 关键参数：sync_binlog</a></li>
        <li><a href="#5-再次对比redo-log-vs-binlog">5. 再次对比：Redo Log vs Binlog</a></li>
        <li><a href="#6-一个经典问题为什么需要两份日志">6. 一个经典问题：为什么需要两份日志？</a></li>
      </ol>
    </li>
    <li><a href="#介绍一下kafka和rocketmq的刷盘策略">介绍一下kafka和RocketMQ的刷盘策略</a>
      <ol>
        <li><a href="#1-rocketmq-的刷盘策略">1. RocketMQ 的刷盘策略</a>
          <ol>
            <li><a href="#a-异步刷盘-async_flush--默认策略">A. 异步刷盘 (ASYNC_FLUSH) —— <strong>默认策略</strong></a></li>
            <li><a href="#b-同步刷盘-sync_flush">B. 同步刷盘 (SYNC_FLUSH)</a></li>
          </ol>
        </li>
        <li><a href="#2-kafka-的刷盘策略">2. Kafka 的刷盘策略</a>
          <ol>
            <li><a href="#a-异步刷盘-依赖-os-page-cache--核心策略">A. 异步刷盘 (依赖 OS Page Cache) —— <strong>核心策略</strong></a></li>
            <li><a href="#b-同步刷盘-可配置但很少用">B. 同步刷盘 (可配置，但很少用)</a></li>
          </ol>
        </li>
        <li><a href="#3-横向对比总结-面试必杀技">3. 横向对比总结 (面试必杀技)</a></li>
        <li><a href="#4-深度思考为什么-kafka-敢不刷盘">4. 深度思考：为什么 Kafka 敢不刷盘？</a></li>
      </ol>
    </li>
    <li><a href="#page-cache是什么">Page Cache是什么？</a>
      <ol>
        <li><a href="#1-存储在哪里">1. 存储在哪里？</a></li>
        <li><a href="#2-它是干啥的为什么要用它">2. 它是干啥的？（为什么要用它？）</a>
          <ol>
            <li><a href="#a-写操作write的加速-骗你写完了">A. 写操作（Write）的加速： “骗”你写完了</a></li>
            <li><a href="#b-读操作read的加速-猜你会再用">B. 读操作（Read）的加速： “猜”你会再用</a></li>
          </ol>
        </li>
        <li><a href="#3-一个直观的现象linux-内存占用">3. 一个直观的现象（Linux 内存占用）</a></li>
        <li><a href="#4-总结">4. 总结</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/">面试八股/场景2.0</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            上一个太庞大了，新开一个（
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-11-25</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 60 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="面试八股场景20">面试八股/场景2.0
</h1><h2 id="介绍一下rdb和aof">介绍一下RDB和AOF
</h2><p>Redis 是一个基于内存的数据库，为了防止服务器宕机导致数据丢失，Redis 提供了两种主要的持久化机制：<strong>RDB (Redis Database)</strong> 和 <strong>AOF (Append Only File)</strong>。</p>
<p>这两者分别代表了两种不同的思路：<strong>快照（Snapshotting）</strong> 和 <strong>日志（Logging）</strong>。</p>
<h3 id="1-rdb-redis-database--快照模式">1. RDB (Redis Database) —— 快照模式
</h3><p>RDB 是 Redis 默认的持久化方式。它会在指定的时间间隔内，将内存中的数据集快照写入磁盘。</p>
<h4 id="工作原理"><strong>工作原理</strong>
</h4><ul>
<li>
<p><strong>触发方式：</strong> 可以通过配置文件（如 <code>save 900 1</code>，表示900秒内有1个key变动则触发）自动触发，也可以手动执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令。</p>
</li>
<li>
<p><strong>核心流程（BGSAVE）：</strong></p>
<ol>
<li>
<p>Redis 主进程 <strong>fork</strong> 一个子进程。</p>
</li>
<li>
<p>子进程共享主进程的内存数据（利用操作系统的 <strong>Copy-on-Write / 写时复制</strong> 技术）。</p>
</li>
<li>
<p>子进程将数据写入到一个临时的 RDB 文件中。</p>
</li>
<li>
<p>写入完成后，用新文件替换旧的 RDB 文件。</p>
</li>
</ol>
</li>
</ul>
<h4 id="-优点"><strong>✅ 优点</strong>
</h4><ul>
<li>
<p><strong>恢复速度快：</strong> RDB 是一个紧凑的二进制文件，非常适合用于灾难恢复和备份。Redis 加载 RDB 文件恢复数据的速度远快于 AOF。</p>
</li>
<li>
<p><strong>文件体积小：</strong> 相比 AOF，RDB 文件更小，节省磁盘空间。</p>
</li>
<li>
<p><strong>性能影响小：</strong> 父进程在 <code>fork</code> 子进程后继续处理请求，持久化工作由子进程完成，最大化了 Redis 的性能。</p>
</li>
</ul>
<h4 id="-缺点"><strong>❌ 缺点</strong>
</h4><ul>
<li>
<p><strong>数据丢失风险较高：</strong> RDB 是间隔执行的（例如每5分钟一次）。如果 Redis 在两次快照之间宕机，这期间产生的数据将会丢失。</p>
</li>
<li>
<p><strong>大数据集下的停顿：</strong> 当数据集非常大（如几十 GB）时，<code>fork</code> 子进程的操作可能会比较耗时，导致 Redis 主进程出现毫秒级甚至秒级的阻塞。</p>
</li>
</ul>
<h3 id="2-aof-append-only-file--日志模式">2. AOF (Append Only File) —— 日志模式
</h3><p>AOF 记录了服务器接收到的每一个<strong>写操作</strong>（查询操作不记录）。服务器启动时，通过重新执行这些命令来还原数据。</p>
<h4 id="工作原理-1"><strong>工作原理</strong>
</h4><ul>
<li>
<p><strong>命令追加：</strong> 所有的写命令会先追加到 AOF 缓冲区。</p>
</li>
<li>
<p><strong>同步策略（fsync）：</strong> 根据配置将缓冲区内容同步到磁盘：</p>
<ul>
<li>
<p><code>appendfsync always</code>：每次写操作都同步（最安全，但性能最差）。</p>
</li>
<li>
<p><code>appendfsync everysec</code>：每秒同步一次（<strong>默认推荐</strong>，兼顾性能与安全）。</p>
</li>
<li>
<p><code>appendfsync no</code>：由操作系统决定何时同步（性能最好，但不可控）。</p>
</li>
</ul>
</li>
<li>
<p><strong>AOF 重写（Rewrite）：</strong> 随着时间推移，AOF 文件会越来越大（例如：<code>SET a 1</code>, <code>SET a 2</code> 其实最终只是 <code>a=2</code>）。Redis 会在后台对 AOF 文件进行重写，只保留恢复当前数据所需的最小命令集。</p>
</li>
</ul>
<h4 id="-优点-1"><strong>✅ 优点</strong>
</h4><ul>
<li>
<p><strong>数据安全性高：</strong> 使用 <code>everysec</code> 策略，最坏情况下也只会丢失 1 秒的数据。</p>
</li>
<li>
<p><strong>可读性强：</strong> AOF 文件是纯文本格式，如果误执行了 <code>FLUSHALL</code>，只要 AOF 文件未被重写，可以手动删掉文件末尾的该命令来挽救数据。</p>
</li>
</ul>
<h4 id="-缺点-1"><strong>❌ 缺点</strong>
</h4><ul>
<li>
<p><strong>文件体积大：</strong> 记录所有写命令，导致 AOF 文件通常比 RDB 文件大得多。</p>
</li>
<li>
<p><strong>恢复速度慢：</strong> 恢复数据时需要“重放”所有命令，速度比加载 RDB 二进制快照要慢。</p>
</li>
<li>
<p><strong>写性能稍低：</strong> 根据 fsync 策略，AOF 对写性能有一定影响（通常 <code>everysec</code> 影响很小）。</p>
</li>
</ul>
<hr>
<h3 id="3-rdb-vs-aof-核心对比">3. RDB vs AOF 核心对比
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>RDB (快照)</strong></th>
          <th><strong>AOF (日志)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数据安全性</strong></td>
          <td>较低 (可能丢失最后几分钟数据)</td>
          <td><strong>高</strong> (默认通常只丢1秒)</td>
      </tr>
      <tr>
          <td><strong>恢复速度</strong></td>
          <td><strong>非常快</strong></td>
          <td>较慢 (需重放命令)</td>
      </tr>
      <tr>
          <td><strong>文件体积</strong></td>
          <td><strong>小 (二进制压缩)</strong></td>
          <td>大 (文本记录)</td>
      </tr>
      <tr>
          <td><strong>资源消耗</strong></td>
          <td>CPU 高 (Fork 过程), I/O 低</td>
          <td>CPU 低, I/O 高 (持续追加)</td>
      </tr>
      <tr>
          <td><strong>启动优先级</strong></td>
          <td>低 (若开启 AOF，优先加载 AOF)</td>
          <td><strong>高</strong> (因为数据更全)</td>
      </tr>
  </tbody>
</table></div>
<p>Redis 是一个基于内存的数据库，为了防止服务器宕机导致数据丢失，Redis 提供了两种主要的持久化机制：<strong>RDB (Redis Database)</strong> 和 <strong>AOF (Append Only File)</strong>。</p>
<p>这两者分别代表了两种不同的思路：<strong>快照（Snapshotting）</strong> 和 <strong>日志（Logging）</strong>。</p>
<p>以下是两者的详细对比与解析：</p>
<hr>
<h3 id="1-rdb-redis-database--快照模式-1">1. RDB (Redis Database) —— 快照模式
</h3><p>RDB 是 Redis 默认的持久化方式。它会在指定的时间间隔内，将内存中的数据集快照写入磁盘。</p>
<h4 id="工作原理-2"><strong>工作原理</strong>
</h4><ul>
<li>
<p><strong>触发方式：</strong> 可以通过配置文件（如 <code>save 900 1</code>，表示900秒内有1个key变动则触发）自动触发，也可以手动执行 <code>SAVE</code> 或 <code>BGSAVE</code> 命令。</p>
</li>
<li>
<p><strong>核心流程（BGSAVE）：</strong></p>
<ol>
<li>
<p>Redis 主进程 <strong>fork</strong> 一个子进程。</p>
</li>
<li>
<p>子进程共享主进程的内存数据（利用操作系统的 <strong>Copy-on-Write / 写时复制</strong> 技术）。</p>
</li>
<li>
<p>子进程将数据写入到一个临时的 RDB 文件中。</p>
</li>
<li>
<p>写入完成后，用新文件替换旧的 RDB 文件。</p>
</li>
</ol>
</li>
</ul>
<h4 id="-优点-2"><strong>✅ 优点</strong>
</h4><ul>
<li>
<p><strong>恢复速度快：</strong> RDB 是一个紧凑的二进制文件，非常适合用于灾难恢复和备份。Redis 加载 RDB 文件恢复数据的速度远快于 AOF。</p>
</li>
<li>
<p><strong>文件体积小：</strong> 相比 AOF，RDB 文件更小，节省磁盘空间。</p>
</li>
<li>
<p><strong>性能影响小：</strong> 父进程在 <code>fork</code> 子进程后继续处理请求，持久化工作由子进程完成，最大化了 Redis 的性能。</p>
</li>
</ul>
<h4 id="-缺点-2"><strong>❌ 缺点</strong>
</h4><ul>
<li>
<p><strong>数据丢失风险较高：</strong> RDB 是间隔执行的（例如每5分钟一次）。如果 Redis 在两次快照之间宕机，这期间产生的数据将会丢失。</p>
</li>
<li>
<p><strong>大数据集下的停顿：</strong> 当数据集非常大（如几十 GB）时，<code>fork</code> 子进程的操作可能会比较耗时，导致 Redis 主进程出现毫秒级甚至秒级的阻塞。</p>
</li>
</ul>
<hr>
<h3 id="2-aof-append-only-file--日志模式-1">2. AOF (Append Only File) —— 日志模式
</h3><p>AOF 记录了服务器接收到的每一个<strong>写操作</strong>（查询操作不记录）。服务器启动时，通过重新执行这些命令来还原数据。</p>
<h4 id="工作原理-3"><strong>工作原理</strong>
</h4><ul>
<li>
<p><strong>命令追加：</strong> 所有的写命令会先追加到 AOF 缓冲区。</p>
</li>
<li>
<p><strong>同步策略（fsync）：</strong> 根据配置将缓冲区内容同步到磁盘：</p>
<ul>
<li>
<p><code>appendfsync always</code>：每次写操作都同步（最安全，但性能最差）。</p>
</li>
<li>
<p><code>appendfsync everysec</code>：每秒同步一次（<strong>默认推荐</strong>，兼顾性能与安全）。</p>
</li>
<li>
<p><code>appendfsync no</code>：由操作系统决定何时同步（性能最好，但不可控）。</p>
</li>
</ul>
</li>
<li>
<p><strong>AOF 重写（Rewrite）：</strong> 随着时间推移，AOF 文件会越来越大（例如：<code>SET a 1</code>, <code>SET a 2</code> 其实最终只是 <code>a=2</code>）。Redis 会在后台对 AOF 文件进行重写，只保留恢复当前数据所需的最小命令集。</p>
</li>
</ul>
<h4 id="-优点-3"><strong>✅ 优点</strong>
</h4><ul>
<li>
<p><strong>数据安全性高：</strong> 使用 <code>everysec</code> 策略，最坏情况下也只会丢失 1 秒的数据。</p>
</li>
<li>
<p><strong>可读性强：</strong> AOF 文件是纯文本格式，如果误执行了 <code>FLUSHALL</code>，只要 AOF 文件未被重写，可以手动删掉文件末尾的该命令来挽救数据。</p>
</li>
</ul>
<h4 id="-缺点-3"><strong>❌ 缺点</strong>
</h4><ul>
<li>
<p><strong>文件体积大：</strong> 记录所有写命令，导致 AOF 文件通常比 RDB 文件大得多。</p>
</li>
<li>
<p><strong>恢复速度慢：</strong> 恢复数据时需要“重放”所有命令，速度比加载 RDB 二进制快照要慢。</p>
</li>
<li>
<p><strong>写性能稍低：</strong> 根据 fsync 策略，AOF 对写性能有一定影响（通常 <code>everysec</code> 影响很小）。</p>
</li>
</ul>
<hr>
<h3 id="3-rdb-vs-aof-核心对比-1">3. RDB vs AOF 核心对比
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>RDB (快照)</strong></th>
          <th><strong>AOF (日志)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数据安全性</strong></td>
          <td>较低 (可能丢失最后几分钟数据)</td>
          <td><strong>高</strong> (默认通常只丢1秒)</td>
      </tr>
      <tr>
          <td><strong>恢复速度</strong></td>
          <td><strong>非常快</strong></td>
          <td>较慢 (需重放命令)</td>
      </tr>
      <tr>
          <td><strong>文件体积</strong></td>
          <td><strong>小 (二进制压缩)</strong></td>
          <td>大 (文本记录)</td>
      </tr>
      <tr>
          <td><strong>资源消耗</strong></td>
          <td>CPU 高 (Fork 过程), I/O 低</td>
          <td>CPU 低, I/O 高 (持续追加)</td>
      </tr>
      <tr>
          <td><strong>启动优先级</strong></td>
          <td>低 (若开启 AOF，优先加载 AOF)</td>
          <td><strong>高</strong> (因为数据更全)</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h3 id="4-最佳实践混合持久化-redis-40">4. 最佳实践：混合持久化 (Redis 4.0+)
</h3><p>在 Redis 4.0 之前，通常建议同时开启 RDB（做备份）和 AOF（保数据）。</p>
<p>Redis 4.0 引入了混合持久化（Hybrid Persistence）：</p>
<p>这是目前的推荐配置。它结合了 RDB 和 AOF 的优点：</p>
<ul>
<li>
<p><strong>机制：</strong> 在进行 AOF 重写时，Redis 会将当前内存的数据以 <strong>RDB 格式</strong> 写入 AOF 文件的开头，随后的增量写操作继续以 <strong>AOF 文本格式</strong> 追加到文件末尾。</p>
</li>
<li>
<p><strong>结果：</strong> AOF 文件前半部分是 RDB（加载快、体积小），后半部分是增量日志（数据全）。</p>
</li>
<li>
<p><strong>效果：</strong> 既保证了快速启动（加载 RDB 部分），又保证了数据不丢失（加载 AOF 增量部分）。</p>
</li>
</ul>
<h2 id="进程和线程的区别">进程和线程的区别
</h2><p>用一句话概括：<strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。</strong></p>
<h3 id="核心区别详解">核心区别详解
</h3><h4 id="1-资源的拥有权resource-ownership">1. 资源的拥有权（Resource Ownership）
</h4><ul>
<li>
<p><strong>进程：</strong> 拥有独立的内存空间（代码段、数据段、堆等）和系统资源（文件描述符等）。不同进程之间的资源是隔离的。</p>
</li>
<li>
<p><strong>线程：</strong> 线程本身不拥有系统资源，只拥有很少的运行中必不可少的资源（如<strong>程序计数器、栈、寄存器</strong>）。同一进程内的所有线程<strong>共享</strong>该进程的内存空间（堆、全局变量）和文件资源。</p>
</li>
</ul>
<h4 id="2-调度与开销overhead--switching">2. 调度与开销（Overhead &amp; Switching）
</h4><ul>
<li>
<p><strong>进程：</strong> 切换成本<strong>高</strong>。当操作系统切换进程时，需要保存当前进程的上下文（内存页表、CPU 状态等）并加载新进程的上下文，这会导致 CPU 缓存失效，开销较大。</p>
</li>
<li>
<p><strong>线程：</strong> 切换成本<strong>低</strong>。同一进程内的线程切换，不需要切换内存页表，只需要保存和恢复少量的寄存器内容和栈信息，速度很快。</p>
</li>
</ul>
<h4 id="3-通信方式communication">3. 通信方式（Communication）
</h4><ul>
<li>
<p><strong>进程间通信 (IPC)：</strong> 困难。因为内存隔离，进程间需要通过特殊机制通信，如：管道 (Pipe)、消息队列、共享内存、信号量、Socket 等。</p>
</li>
<li>
<p><strong>线程间通信：</strong> 容易。因为共享内存（堆），线程之间可以直接读写同一变量来进行通信。</p>
<ul>
<li><em>注意：</em> 虽然通信容易，但带来了**线程安全（同步）**问题，需要使用锁（Lock）或 CAS 等机制来防止数据错乱。</li>
</ul>
</li>
</ul>
<h4 id="4-健壮性与隔离性stability">4. 健壮性与隔离性（Stability）
</h4><ul>
<li>
<p><strong>进程：</strong> 健壮性强。一个进程崩溃通常<strong>不会</strong>影响其他进程（因为内存是隔离的）。例如：Chrome 浏览器的一个标签页（进程）崩了，通常不会导致整个浏览器崩溃。</p>
</li>
<li>
<p><strong>线程：</strong> 健壮性弱。一个线程出现致命错误（如非法内存访问），可能会导致<strong>整个进程</strong>崩溃，进而导致该进程内的所有线程都挂掉。</p>
</li>
</ul>
<hr>
<h3 id="对比总结表">对比总结表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>进程 (Process)</strong></th>
          <th><strong>线程 (Thread)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>本质</strong></td>
          <td><strong>资源分配</strong>的最小单位</td>
          <td><strong>CPU 调度</strong>的最小单位</td>
      </tr>
      <tr>
          <td><strong>内存空间</strong></td>
          <td>独立（互不干扰）</td>
          <td>共享（同一进程内）</td>
      </tr>
      <tr>
          <td><strong>切换开销</strong></td>
          <td>大 (涉及虚拟内存、页表切换)</td>
          <td>小 (不涉及内存地址空间切换)</td>
      </tr>
      <tr>
          <td><strong>通信难度</strong></td>
          <td>难 (IPC：管道、Socket等)</td>
          <td>易 (直接读写共享变量)</td>
      </tr>
      <tr>
          <td><strong>稳定性</strong></td>
          <td>进程间隔离，一个崩了不影响其他</td>
          <td>一个线程崩了可能搞挂整个进程</td>
      </tr>
      <tr>
          <td><strong>并发性</strong></td>
          <td>也可以并发，但资源消耗大</td>
          <td>并发性高，资源消耗小</td>
      </tr>
  </tbody>
</table></div>
<h2 id="redis的内存淘汰机制">Redis的内存淘汰机制
</h2><p>当 Redis 的内存使用量达到在 <code>redis.conf</code> 中配置的 <code>maxmemory</code> 上限时，为了能继续接收新的写入请求，Redis 必须根据配置的策略删除一部分数据。这就是 <strong>Redis 的内存淘汰机制</strong>。</p>
<p>Redis 提供了 <strong>8 种</strong> 淘汰策略（Redis 4.0 之后），我们可以从**“淘汰范围”<strong>和</strong>“淘汰算法”**两个维度来理解。</p>
<hr>
<h3 id="1-两个核心维度">1. 两个核心维度
</h3><p>在记忆这些策略之前，先理解两个概念，这样就不需要死记硬背了：</p>
<ol>
<li>
<p><strong>淘汰范围（也就是“去哪里选”）：</strong></p>
<ul>
<li>
<p><strong><code>allkeys</code></strong>：从<strong>所有</strong>键中筛选（不管有没有设置过期时间）。通常用于把 Redis 当纯缓存用的场景。</p>
</li>
<li>
<p><strong><code>volatile</code></strong>：只从**设置了过期时间（TTL）**的键中筛选。通常用于把 Redis 当数据库用，同时又想缓存一部分临时数据的场景。</p>
</li>
</ul>
</li>
<li>
<p><strong>淘汰算法（也就是“怎么选”）：</strong></p>
<ul>
<li>
<p><strong>LRU (Least Recently Used)</strong>：最近最少使用。</p>
</li>
<li>
<p><strong>LFU (Least Frequently Used)</strong>：最不经常使用（Redis 4.0+）。</p>
</li>
<li>
<p><strong>Random</strong>：随机。</p>
</li>
<li>
<p><strong>TTL</strong>：快过期的。</p>
</li>
</ul>
</li>
</ol>
<h3 id="redis-的-lru-是真的-lru-吗">Redis 的 LRU 是真的 LRU 吗？
</h3><p><strong>不是。</strong> Redis 使用的是<strong>近似 LRU 算法</strong>（Approximated LRU）。</p>
<ul>
<li>
<p><strong>原因：</strong> 严格的 LRU 需要维护一个巨大的双向链表，每访问一次 key 就要移动节点，这非常消耗内存且影响性能。</p>
</li>
<li>
<p><strong>实现：</strong> Redis 采用<strong>随机采样</strong>的方式。当需要淘汰时，它随机抽取 N 个 key（默认 5 个，由 <code>maxmemory-samples</code> 配置），然后淘汰这 N 个里面最久没被访问的那一个。</p>
</li>
<li>
<p><strong>效果：</strong> 虽然是近似的，但在 Redis 3.0 优化后，效果已经非常接近严格 LRU 了。</p>
</li>
</ul>
<h3 id="redis的各种淘汰策略">Redis的各种淘汰策略
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>策略前缀</strong></th>
          <th><strong>策略后缀 (算法)</strong></th>
          <th><strong>含义</strong></th>
          <th><strong>适用场景</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>noeviction</strong></td>
          <td>-</td>
          <td><strong>不淘汰</strong>，写请求报错</td>
          <td>纯数据存储，数据不能丢</td>
      </tr>
      <tr>
          <td><strong>allkeys</strong></td>
          <td><strong>-lru</strong></td>
          <td>所有Key + 最近最少使用</td>
          <td><strong>通用缓存 (推荐)</strong></td>
      </tr>
      <tr>
          <td><strong>allkeys</strong></td>
          <td><strong>-lfu</strong></td>
          <td>所有Key + 最不经常使用</td>
          <td>即使最近被访问过，总体访问频率低也被淘汰</td>
      </tr>
      <tr>
          <td><strong>allkeys</strong></td>
          <td><strong>-random</strong></td>
          <td>所有Key + 随机</td>
          <td>极少使用</td>
      </tr>
      <tr>
          <td><strong>volatile</strong></td>
          <td><strong>-lru</strong></td>
          <td>过期Key + 最近最少使用</td>
          <td>混合存储，只淘汰缓存部分</td>
      </tr>
      <tr>
          <td><strong>volatile</strong></td>
          <td><strong>-lfu</strong></td>
          <td>过期Key + 最不经常使用</td>
          <td>同上</td>
      </tr>
      <tr>
          <td><strong>volatile</strong></td>
          <td><strong>-random</strong></td>
          <td>过期Key + 随机</td>
          <td>极少使用</td>
      </tr>
      <tr>
          <td><strong>volatile</strong></td>
          <td><strong>-ttl</strong></td>
          <td>过期Key + 剩余时间最短</td>
          <td>让快过期的先走</td>
      </tr>
  </tbody>
</table></div>
<h2 id="java的双亲委派模型是什么">Java的双亲委派模型是什么？
</h2><p><strong>双亲委派模型（Parent Delegation Model）</strong> 是 Java 类加载机制的核心设计思想。</p>
<p>虽然名字听起来有点高大上（甚至有点拗口），但它的核心逻辑非常简单，用一句话概括就是：<strong>“这也是为了你好：有事儿先找你爹，你爹搞不定你再自己来。”</strong></p>
<p>下面我从<strong>结构、流程、作用</strong>和<strong>例外</strong>四个方面为你拆解。</p>
<hr>
<h3 id="1-谁是双亲类加载器的层级">1. 谁是“双亲”？（类加载器的层级）
</h3><p>在 Java 中，类加载器（ClassLoader）是有层级关系的。并不是真的有两个亲戚（“双亲”这个翻译其实有点误导，它指的是 Parent，即<strong>父级</strong>）。</p>
<p>主要的类加载器有三层：</p>
<ol>
<li>
<p><strong>启动类加载器 (Bootstrap ClassLoader)</strong></p>
<ul>
<li>
<p><strong>地位：</strong> 老祖宗，最顶层。</p>
</li>
<li>
<p><strong>职责：</strong> 负责加载 Java 的核心类库（如 <code>java.lang.String</code>, <code>rt.jar</code> 等）。它是用 C++ 写的，在 Java 代码里拿不到它的引用（也就是 <code>null</code>）。</p>
</li>
<li>
<p>它负责加载 Java 运行时环境（JRE）中最核心的库。这些类位于 <code>$JAVA_HOME/jre/lib</code> 目录下，通常打包在 <code>rt.jar</code> (Runtime Jar) 中。</p>
<p><strong>💡 具体例子：</strong> 只要是 <code>java.*</code> 开头的几乎都是它加载的。</p>
<ul>
<li>
<p><strong>基础类型包装类：</strong> <code>java.lang.Integer</code>, <code>java.lang.Double</code>, <code>java.lang.String</code></p>
</li>
<li>
<p><strong>集合框架：</strong> <code>java.util.ArrayList</code>, <code>java.util.HashMap</code>, <code>java.util.HashSet</code></p>
</li>
<li>
<p><strong>IO 流：</strong> <code>java.io.File</code>, <code>java.io.FileInputStream</code></p>
</li>
<li>
<p><strong>并发包：</strong> <code>java.util.concurrent.ConcurrentHashMap</code></p>
</li>
<li>
<p><strong>线程：</strong> <code>java.lang.Thread</code></p>
</li>
</ul>
<p><strong>🧐 现象：</strong> 如果你在代码里打印 <code>String.class.getClassLoader()</code>，你会得到 <strong><code>null</code></strong>。这不是因为没加载，而是因为 Bootstrap 是用 C++ 写的，Java 代码无法获取它的引用。</p>
</li>
</ul>
</li>
<li>
<p><strong>扩展类加载器 (Extension ClassLoader)</strong></p>
<ul>
<li>
<p><strong>地位：</strong> 中间层。</p>
</li>
<li>
<p><strong>职责：</strong> 负责加载 Java 的扩展库（<code>JAVA_HOME/lib/ext</code> 目录下的 jar 包）。</p>
</li>
<li>
<p>它负责加载 <code>$JAVA_HOME/jre/lib/ext</code> 目录下的类库，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径。它是对 Java 核心功能的补充。</p>
<p><strong>💡 具体例子：</strong> 这些类通常平时用得少一点，多涉及一些加密、特殊网络协议或 XML 解析等。</p>
<ul>
<li>
<p><strong>加密库：</strong> <code>com.sun.crypto.provider.SunJCE</code> (Java 加密扩展，做 AES/DES 加密时会用到)</p>
</li>
<li>
<p><strong>DNS 相关：</strong> <code>sun.net.spi.nameservice.dns.DNSNameService</code> (某些 JDK 版本下的 DNS 解析服务)</p>
</li>
<li>
<p><strong>JavaScript 引擎：</strong> <code>jdk.nashorn.api.scripting.NashornScriptEngine</code> (Java 8 中内置的 JS 引擎)</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>应用程序类加载器 (Application ClassLoader)</strong></p>
<ul>
<li>
<p><strong>地位：</strong> 最底层（系统默认）。</p>
</li>
<li>
<p><strong>职责：</strong> 负责加载我们自己写的代码（<code>ClassPath</code> 下的类）和第三方 Jar 包。</p>
</li>
<li>
<p>这是我们接触最多的加载器。它负责加载 <code>CLASSPATH</code> 环境变量或系统属性 <code>java.class.path</code> 指定的类库。</p>
<p><strong>💡 具体例子：</strong> 凡是你自己在工程里写的，或者在 <code>pom.xml</code> / <code>build.gradle</code> 里引用的，都归它管。</p>
<ol>
<li>
<p><strong>你写的业务代码：</strong></p>
<ul>
<li>
<p><code>com.example.project.UserController</code></p>
</li>
<li>
<p><code>com.example.project.MyUtils</code></p>
</li>
<li>
<p>你的 <code>Main</code> 启动类</p>
</li>
</ul>
</li>
<li>
<p><strong>第三方开源框架（Maven 依赖）：</strong></p>
<ul>
<li>
<p><strong>Spring 全家桶：</strong> <code>org.springframework.boot.SpringApplication</code>, <code>org.springframework.context.ApplicationContext</code></p>
</li>
<li>
<p><strong>数据库驱动：</strong> <code>com.mysql.cj.jdbc.Driver</code> (注意：虽然 Driver 接口是核心的，但 MySQL 的实现类是 App 加载的)</p>
</li>
<li>
<p><strong>中间件客户端：</strong> <code>org.apache.rocketmq.client.producer.DefaultMQProducer</code> (RocketMQ), <code>com.alibaba.dubbo.config.ApplicationConfig</code> (Dubbo)</p>
</li>
<li>
<p><strong>工具类：</strong> <code>com.alibaba.fastjson.JSON</code>, <code>org.apache.commons.lang3.StringUtils</code></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p><em>此外，还可以有<strong>自定义类加载器 (Custom ClassLoader)</strong>，挂在应用程序类加载器下面。</em></p>
</blockquote>
<hr>
<h3 id="2-委派流程怎么工作">2. 委派流程（怎么工作？）
</h3><p>当一个类加载器收到了类加载的请求时，它<strong>不会</strong>自己立即去加载，而是遵循以下步骤：</p>
<ol>
<li>
<p><strong>向上委托：</strong> 它会把这个请求委托给<strong>父类加载器</strong>去执行。</p>
</li>
<li>
<p><strong>层层传递：</strong> 父类加载器如果还有父类，就继续向上委托，直到传到最顶层的 <strong>Bootstrap ClassLoader</strong>。</p>
</li>
<li>
<p><strong>向下尝试：</strong></p>
<ul>
<li>
<p><strong>Bootstrap</strong> 尝试加载，如果找到了（比如是 <code>String</code>），就直接返回。</p>
</li>
<li>
<p>如果 <strong>Bootstrap</strong> 没找到（也就是它管辖的范围里没有这个类），就告诉子类（Extension）：“我搞不定，你来吧”。</p>
</li>
<li>
<p><strong>Extension</strong> 尝试加载，如果没找到，再往下交给 <strong>Application</strong>。</p>
</li>
<li>
<p><strong>Application</strong> 尝试加载，如果也没找到，就会抛出 <code>ClassNotFoundException</code>。</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-为什么要这么设计核心作用">3. 为什么要这么设计？（核心作用）
</h3><p>双亲委派模型主要解决了两个大问题：</p>
<h4 id="-1-安全性-security--防止核心-api-被篡改">✅ 1. 安全性 (Security) —— 防止核心 API 被篡改
</h4><p>假设黑客写了一个恶意的类，名字也叫 <code>java.lang.String</code>，并且放在了你的 ClassPath 下。
如果没有双亲委派，系统就会加载这个恶意的 <code>String</code> 类，你的密码、数据全都会被黑客截获。 <strong>有了双亲委派：</strong> 系统在加载 <code>String</code> 时，会一直往上找，最终由 <strong>Bootstrap ClassLoader</strong> 加载了 JDK 自带的那个正版 <code>String</code>。黑客写的那个类永远没有机会被加载。</p>
<h4 id="-2-避免重复加载-uniqueness">✅ 2. 避免重复加载 (Uniqueness)
</h4><p>Java 类在内存中的唯一性是由 <strong>“类加载器 + 类全名”</strong> 共同决定的。
如果同一个 <code>System</code> 类被两个不同的加载器各加载了一次，JVM 会认为它们是两个完全不同的类，这会导致类型转换异常，系统会乱套。
双亲委派保证了核心类永远只由顶层的加载器加载一次。</p>
<h3 id="4-什么时候需要打破双亲委派">4. 什么时候需要打破双亲委派？
</h3><p>虽然双亲委派很好，但在某些特殊场景下，它反而成了阻碍，我们需要“打破”它（即：不让父类先加载，而是自己先加载，或者绕过父类）。</p>
<p><strong>经典案例：</strong></p>
<ol>
<li>
<p><strong>Tomcat (Web 容器)：</strong></p>
<ul>
<li>
<p>Tomcat 上可能部署了两个 Web 应用，一个用 Spring 4，一个用 Spring 5。</p>
</li>
<li>
<p>如果用默认的双亲委派，Spring 类库只能加载一份，会导致冲突。</p>
</li>
<li>
<p><strong>解决：</strong> Tomcat 自定义了类加载器，优先加载 Web 应用自己 <code>WEB-INF/lib</code> 下的类，<strong>打破了“向上委托”的规则</strong>（先自己找，找不到再问爸爸）。</p>
</li>
</ul>
</li>
<li>
<p><strong>JDBC (SPI 机制)：</strong></p>
<ul>
<li>
<p>Java 核心包提供了 <code>java.sql.Driver</code> 接口（在 Bootstrap 层加载）。</p>
</li>
<li>
<p>但是具体的实现（如 MySQL 驱动）是第三方厂商提供的（在 ClassPath 下，由 App 层加载）。</p>
</li>
<li>
<p>这里出现了一个悖论：<strong>Bootstrap 层的代码需要去调用 App 层的代码</strong>。父加载器是看不到子加载器的类的。</p>
</li>
<li>
<p><strong>解决：</strong> 使用 <strong>线程上下文类加载器 (Thread Context ClassLoader)</strong>，让父级加载器“走后门”拿到子级加载器去加载类。</p>
</li>
</ul>
</li>
</ol>
<h2 id="hashmap与concurenthashmap的区别">HashMap与ConcurentHashMap的区别
</h2><p><strong>HashMap</strong> 和 <strong>ConcurrentHashMap (CHM)</strong> 的核心区别在于：<strong>线程安全性</strong>和<strong>底层实现机制</strong></p>
<p>简单来说：</p>
<ul>
<li>
<p><strong>HashMap</strong> 是<strong>非线程安全</strong>的，性能极高，适合单线程。</p>
</li>
<li>
<p><strong>ConcurrentHashMap</strong> 是<strong>线程安全</strong>的，高并发下性能依然优秀，适合多线程。</p>
</li>
</ul>
<h3 id="核心区别详解-1">核心区别详解
</h3><h4 id="-线程安全性-thread-safety">① 线程安全性 (Thread Safety)
</h4><ul>
<li>
<p><strong>HashMap:</strong></p>
<ul>
<li>
<p><strong>不安全。</strong> 如果多个线程同时写入 HashMap，可能会导致数据覆盖（Data Race）。</p>
</li>
<li>
<p><strong>严重问题：</strong> 在 JDK 1.7 中，多线程并发扩容（Resize）时甚至会导致链表成环，造成 <code>Infinite Loop</code>（死循环），CPU 飙升 100%。虽然 JDK 1.8 修复了死循环问题，但依然会有数据丢失风险。</p>
</li>
</ul>
</li>
<li>
<p><strong>ConcurrentHashMap:</strong></p>
<ul>
<li><strong>安全。</strong> 它是专门为并发设计的。内部使用了非常精妙的锁机制和 CAS 操作，保证了多线程下的数据一致性。</li>
</ul>
</li>
</ul>
<h4 id="-锁的粒度-locking-granularity--性能的关键">② 锁的粒度 (Locking Granularity) —— 性能的关键
</h4><ul>
<li>
<p><strong>HashMap:</strong> 没有锁。</p>
</li>
<li>
<p><strong>Hashtable (反面教材):</strong> 使用 <code>synchronized</code> 锁住<strong>整个</strong> Map（一把大锁）。只要有一个线程在写，其他线程无论是读还是写都得排队，效率极低。</p>
</li>
<li>
<p><strong>ConcurrentHashMap:</strong></p>
<ul>
<li>
<p><strong>JDK 1.7:</strong> 使用 <strong>分段锁 (Segment Locking)</strong>。将数据分成一段一段（默认 16 段），每次只锁住被修改的那一段。</p>
</li>
<li>
<p><strong>JDK 1.8 (优化):</strong> 抛弃了分段锁，采用 <strong>CAS + <code>synchronized</code></strong>。锁的粒度更细，只锁住<strong>哈希桶的头节点</strong>。这意味着只要两个线程操作的 Key 不在同一个桶（Hash冲突），它们就可以完全并行，互不干扰！</p>
</li>
<li>
<p><strong>能用无锁（CAS）解决的就用无锁，解决不了的再用锁（synchronized），而且锁本身也做了巨大的优化</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="1-cas-compare-and-swap--冲锋在前的轻骑兵">1. CAS (Compare And Swap) —— 冲锋在前的“轻骑兵”
</h3><p>CAS 是一种<strong>乐观锁</strong>机制。它的核心思想是：“我认为没人跟我抢，所以我直接尝试更新。如果真的有人抢（比较失败），我再重试或放弃。”</p>
<p>在 JDK 1.8 的 CHM 中，CAS 主要用于<strong>无竞争场景</strong>和<strong>状态设置</strong>，它的速度非常快，因为它直接对应 CPU 的一条原子指令（<code>cmpxchg</code>）。</p>
<h4 id="cas-在哪里用"><strong>CAS 在哪里用？</strong>
</h4><ol>
<li>
<p><strong>插入新节点（最关键的路径）：</strong> 当 <code>put</code> 一个数据时，如果计算出的 Hash 槽位（Bucket）是<strong>空</strong>的（没有发生哈希冲突），CHM <strong>不会加锁</strong>，而是直接用 CAS 尝试把新节点放入该位置。</p>
<ul>
<li>
<p><strong>代码逻辑：</strong> <code>casTabAt(tab, i, null, new Node(...))</code></p>
</li>
<li>
<p><strong>优势：</strong> 这种情况在哈希散列良好的情况下非常常见，完全避免了加锁的开销。</p>
</li>
</ul>
</li>
<li>
<p><strong>初始化数组：</strong> 在 <code>initTable</code> 方法中，通过 CAS 修改 <code>sizeCtl</code> 变量（将其设为 -1），来抢占“初始化数组”的权利。只有一个线程能 CAS 成功，其他的线程会 <code>yield</code> 让出 CPU。</p>
</li>
<li>
<p><strong>计数更新：</strong> 在 <code>addCount</code> 方法中，利用类似 <code>LongAdder</code> 的机制（<code>Cells</code> 数组），通过 CAS 累加元素的数量。</p>
</li>
</ol>
<h4 id="cas-的潜在问题"><strong>CAS 的潜在问题：</strong>
</h4><ul>
<li>
<p><strong>ABA 问题：</strong>（虽然在 CHM 的节点插入中通常不涉及，但在其他并发场景需注意）。</p>
</li>
<li>
<p><strong>自旋开销：</strong> 如果竞争太激烈，CAS 一直失败重试（自旋），会白白浪费 CPU 资源。</p>
</li>
</ul>
<hr>
<h3 id="2-synchronized--坐镇后方的重装卫士">2. Synchronized —— 坐镇后方的“重装卫士”
</h3><p>在 JDK 1.6 之前，<code>synchronized</code> 是重量级锁，性能很差。但在 JDK 1.8 中，它是经过武装牙齿的“新式重甲”。</p>
<h4 id="synchronized-在哪里用"><strong>Synchronized 在哪里用？</strong>
</h4><p><strong>仅在发生哈希冲突时使用。</strong></p>
<p>当 <code>put</code> 数据时，如果发现目标槽位<strong>已经有节点了</strong>（Hash 冲突），CAS 就搞不定了（因为要操作链表或红黑树，涉及多个指针的变动，CAS 很难保证原子性）。
此时，CHM 会用 <code>synchronized</code> <strong>锁住该槽位的头节点</strong>。</p>
<h3 id="底层实现深度对比-jdk-17-vs-jdk-18">底层实现深度对比 (JDK 1.7 vs JDK 1.8)
</h3><p>这是面试中最能体现深度的部分，重点关注 ConcurrentHashMap 的演进。</p>
<h4 id="hashmap">HashMap
</h4><ul>
<li>
<p><strong>JDK 1.7:</strong> 数组 + 链表。</p>
</li>
<li>
<p><strong>JDK 1.8:</strong> 数组 + 链表 + <strong>红黑树</strong>。当链表长度 &gt; 8 且数组长度 &gt; 64 时，链表会转为红黑树，将查询复杂度从 $O(n)$ 优化到 $O(\log n)$。</p>
</li>
</ul>
<h4 id="concurrenthashmap-进化史">ConcurrentHashMap (进化史)
</h4><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>JDK 1.7 (分段锁)</strong></th>
          <th><strong>JDK 1.8 (CAS + Synchronized)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>核心结构</strong></td>
          <td><strong>Segment 数组 + HashEntry 数组 + 链表</strong></td>
          <td><strong>Node 数组 + 链表 + 红黑树</strong></td>
      </tr>
      <tr>
          <td><strong>锁机制</strong></td>
          <td><strong>ReentrantLock (Segment 继承自它)</strong></td>
          <td><strong>CAS (乐观锁) + synchronized</strong></td>
      </tr>
      <tr>
          <td><strong>锁粒度</strong></td>
          <td>粗。锁住一个 Segment (默认含多个 Hash 桶)</td>
          <td>细。只锁住当前 Hash 桶的<strong>头节点</strong></td>
      </tr>
      <tr>
          <td><strong>并发度</strong></td>
          <td>受限于 Segment 个数 (默认 16)</td>
          <td>理论上等于 Hash 桶的数量 (数组长度)</td>
      </tr>
      <tr>
          <td><strong>读操作</strong></td>
          <td><code>volatile</code> 保证可见性，<strong>无锁</strong></td>
          <td><code>volatile</code> 保证可见性，<strong>无锁</strong></td>
      </tr>
  </tbody>
</table></div>
<p><strong>JDK 1.8 为什么要放弃分段锁？</strong></p>
<ol>
<li>
<p><strong>内存占用：</strong> 每个 Segment 都要继承 ReentrantLock，通过 AQS 维护队列，内存开销大。</p>
</li>
<li>
<p><strong>锁粒度不够细：</strong> 即使分了 16 段，依然可能存在多个线程竞争同一个段的情况。</p>
</li>
<li>
<p><strong>效率提升：</strong> JDK 1.6 之后 JVM 对 <code>synchronized</code> 做了大量优化（偏向锁、轻量级锁），在低竞争下性能已经非常好了，没必要维护复杂的 ReentrantLock。</p>
</li>
</ol>
<hr>
<h3 id="3-总结对比表">3. 总结对比表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>HashMap</strong></th>
          <th><strong>ConcurrentHashMap</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>线程安全</strong></td>
          <td>❌ 否</td>
          <td>✅ 是</td>
      </tr>
      <tr>
          <td><strong>Null Key/Value</strong></td>
          <td>✅ 允许</td>
          <td>❌ 不允许</td>
      </tr>
      <tr>
          <td><strong>原理 (JDK8)</strong></td>
          <td>数组 + 链表 + 红黑树</td>
          <td>数组 + 链表 + 红黑树 + CAS + synchronized</td>
      </tr>
      <tr>
          <td><strong>扩容机制</strong></td>
          <td>新建数组 -&gt; 迁移数据</td>
          <td>能够支持<strong>多线程并发协助扩容</strong> (这是 CHM 1.8 的黑科技)</td>
      </tr>
      <tr>
          <td><strong>应用场景</strong></td>
          <td>局部变量、单线程环境</td>
          <td>全局缓存、高并发环境</td>
      </tr>
  </tbody>
</table></div>
<h3 id="为什么要用synchronized去处理hash冲突">为什么要用synchronized去处理hash冲突
</h3><h4 id="cas-的射程只有-1-个变量-one-word">CAS 的“射程”只有 1 个变量 (One Word)
</h4><p>这是核心原因。 <strong>CAS 只能保证对“内存中某一个地址”的更新是原子的。</strong></p>
<ul>
<li>
<p><strong>没有冲突时（put 到空槽位）：</strong> 只需要把 <code>Node</code> 放入数组的 <code>tab[i]</code> 位置。这就只涉及<strong>一个变量</strong>（数组的一个坑位）的修改。</p>
<ul>
<li><code>CAS(tab, i, null, newNode)</code> -&gt; <strong>搞得定！</strong> ✅</li>
</ul>
</li>
<li>
<p><strong>有冲突时（链表/红黑树）：</strong> 这就不是改一个变量的事了，这是一个<strong>复合操作（Compound Operation）</strong>。</p>
<ul>
<li>
<p><strong>场景一：链表追加</strong> 你需要先遍历链表找到最后一个节点 <code>Tail</code>，然后把 <code>Tail.next</code> 指向 <code>NewNode</code>。
看似只改了 <code>Tail.next</code> 一个变量，但在并发环境下，你必须保证<strong>从你找到 Tail 到你修改 Tail 的这段时间里，Tail 没有被别人删掉，也没有别人在后面先插了一脚</strong>。如果要用 CAS 解决这个问题，必须极其复杂的自旋重试，代码复杂度指数级上升。</p>
</li>
<li>
<p><strong>场景二：红黑树旋转 (最致命的)</strong> 红黑树插入节点后，为了保持平衡，可能需要<strong>变色</strong>和<strong>旋转</strong>。
一次旋转（左旋/右旋）往往涉及到 <strong>3 到 5 个指针</strong>的同时修改（父节点指向子节点、子节点指向孙节点、父节点指向新的子节点&hellip;）。 <strong>CAS 一次只能改 1 个指针，无法同时原子性地修改 3 个指针。</strong> 如果你用 3 次 CAS 分别去改，那在第 1 次和第 2 次之间，树的结构是<strong>断裂</strong>的。其他线程读到这个断裂的树，程序直接崩了。</p>
</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> <code>synchronized</code> 锁住的是**“一段代码逻辑”<strong>（原子性范围大），而 CAS 锁住的是</strong>“一个变量”**（原子性范围小）。处理复杂数据结构变动，必须用大范围的锁。</p>
<h2 id="redis挂了rocketmq挂了都怎么处理">Redis挂了RocketMQ挂了都怎么处理
</h2><h3 id="redis-挂了怎么处理">Redis 挂了怎么处理？
</h3><p>Redis 挂了，最大的风险是<strong>大量流量瞬间击穿缓存，直接打到数据库（MySQL）</strong>，导致数据库宕机，引发“缓存雪崩”。</p>
<h4 id="1-架构层面事前别让它挂">1. 架构层面（事前：别让它挂）
</h4><p>生产环境绝对不能用单机版（Standalone）Redis。</p>
<ul>
<li>
<p><strong>哨兵模式 (Sentinel)：</strong> 此时如果主节点挂了，哨兵会自动选举一个从节点变成主节点。业务层感知很小。</p>
</li>
<li>
<p><strong>集群模式 (Cluster)：</strong> 数据分片。某一个分片的主节点挂了，该分片的从节点上位。</p>
</li>
</ul>
<h4 id="2-应用层面事中挂了怎么办">2. 应用层面（事中：挂了怎么办）
</h4><p>这是开发最需要关心的。如果 Redis 真的全挂了，代码必须有<strong>降级策略</strong>。</p>
<ul>
<li>
<p><strong>方案 A：二级缓存（本地缓存）兜底</strong></p>
<ul>
<li>
<p><strong>策略：</strong> 请求先查 Redis -&gt; Redis 挂了/没数据 -&gt; 查本地缓存 (如 Caffeine/Guava) -&gt; 本地也没 -&gt; 查数据库。</p>
</li>
<li>
<p><strong>作用：</strong> 本地缓存虽然容量小，但能扛住短期的高热点流量，给数据库争取喘息时间。</p>
</li>
</ul>
</li>
<li>
<p><strong>方案 B：熔断与限流（Circuit Breaker &amp; Rate Limiting）</strong></p>
<ul>
<li>
<p><strong>工具：</strong> Sentinel (阿里), Hystrix, Resilience4j。</p>
</li>
<li>
<p><strong>逻辑：</strong> 当监测到访问 Redis 的异常率飙升（比如连接超时），直接<strong>熔断</strong> Redis 调用。</p>
</li>
<li>
<p><strong>后续：</strong> 请求不再去连 Redis（防止卡死线程），而是直接<strong>限流</strong>访问数据库。比如平时 10000 QPS，Redis 挂了，限制只有 200 QPS 能打到数据库，剩下的请求直接报错或返回默认值。</p>
</li>
<li>
<p><strong>目的：</strong> <strong>保住数据库！</strong> 只要数据库还活着，服务就还有救；数据库挂了，整个系统就完了。</p>
</li>
</ul>
</li>
<li>
<p><strong>方案 C：服务降级</strong></p>
<ul>
<li>如果是非核心业务（比如“猜你喜欢”、“热搜榜”），Redis 挂了直接返回空数据或静态的默认数据，不要去查数据库。</li>
</ul>
</li>
</ul>
<h4 id="3-关于分布式锁">3. 关于分布式锁
</h4><ul>
<li>
<p>如果你的系统依赖 Redis 做分布式锁（Redisson），Redis 挂了会导致锁失效或无法加锁。</p>
</li>
<li>
<p><strong>处理：</strong> 这种情况下通常需要业务报错（Fail Fast），或者降级为数据库乐观锁（Version字段），但并发性能会大打折扣。</p>
</li>
</ul>
<h3 id="mq-消息队列-挂了怎么处理">MQ (消息队列) 挂了怎么处理？
</h3><p>MQ (如 RocketMQ, Kafka, RabbitMQ) 挂了，最大的风险是<strong>上下游解耦失败，导致核心链路断开（如下单成功了，但扣库存/发积分的消息发不出去了）</strong>，或者<strong>数据丢失</strong>。</p>
<h4 id="1-架构层面事前别让它挂-1">1. 架构层面（事前：别让它挂）
</h4><ul>
<li>
<p><strong>集群部署：</strong> 无论是 Kafka 还是 RocketMQ，都是主从/多副本机制。</p>
</li>
<li>
<p><strong>多机房/多Broker：</strong> 确保一个 Broker 挂了，Producer 可以自动重连到其他 Broker 发送消息。</p>
</li>
</ul>
<h4 id="2-应用层面事中生产者发不出去怎么办">2. 应用层面（事中：生产者发不出去怎么办？）
</h4><p>这是最关键的。如果 MQ 彻底连不上了，生产者（Producer）必须有备选方案。</p>
<ul>
<li>
<p><strong>方案 A：本地消息表（Local Message Table）—— 最稳妥方案</strong></p>
<ul>
<li>
<p><strong>原理：</strong> 既然 MQ 连不上，那就把消息写到<strong>本地数据库</strong>的一张表里（和业务数据在同一个事务中）。</p>
</li>
<li>
<p><strong>流程：</strong></p>
<ol>
<li>
<p>开启数据库事务。</p>
</li>
<li>
<p>执行业务 SQL（如下单）。</p>
</li>
<li>
<p>执行插入 SQL：<code>INSERT INTO local_msg_table ... status='PENDING'</code>。</p>
</li>
<li>
<p>提交事务。</p>
</li>
</ol>
</li>
<li>
<p><strong>恢复：</strong> 启动一个定时任务（Timer），轮询这张本地消息表，把状态是 &lsquo;PENDING&rsquo; 的消息尝试重新发给 MQ。一旦发送成功，从表中删除或更新状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>方案 B：写入本地磁盘/文件</strong></p>
<ul>
<li>
<p><strong>原理：</strong> 如果数据库压力也很大，可以将消息内容追加写入服务器的本地日志文件。</p>
</li>
<li>
<p><strong>恢复：</strong> 后续写个脚本读取日志文件，重新灌入 MQ。</p>
</li>
</ul>
</li>
<li>
<p><strong>方案 C：同步直连（极端降级）</strong></p>
<ul>
<li>
<p>如果业务允许，当 MQ 挂了，消费者（Consumer）提供一个 HTTP/RPC 接口。生产者发现 MQ 发送失败，直接调用消费者的 RPC 接口（将异步变同步）。</p>
</li>
<li>
<p><em>缺点：</em> 失去了削峰填谷的作用，消费者可能扛不住压力。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-应用层面事中消费者收不到怎么办">3. 应用层面（事中：消费者收不到怎么办？）
</h4><ul>
<li>
<p><strong>积压处理：</strong> MQ 挂了期间，消息无法消费。等 MQ 恢复后，可能会有海量消息涌入。</p>
</li>
<li>
<p><strong>策略：</strong> 消费者需要评估是否增加线程数，或者临时起一套只负责“搬运”的消费者，把消息快速落库，然后再慢慢处理，防止消费者被压垮。</p>
</li>
</ul>
<h2 id="介绍tidb的计算与存储分离和mysql的区别是什么">介绍TiDB的计算与存储分离，和MySQL的区别是什么
</h2><p>一句话概括：<strong>TiDB 把“处理 SQL 的脑子”和“存数据的肚子”彻底分开了，中间通过网络（RPC）通信。</strong></p>
<hr>
<h3 id="一-tidb-的计算与存储分离架构">一、 TiDB 的计算与存储分离架构
</h3><p>TiDB 的架构主要由三大组件组成，完美体现了这种分离：</p>
<h4 id="1-计算层tidb-server无状态的大脑">1. 计算层：TiDB Server（无状态的“大脑”）
</h4><ul>
<li>
<p><strong>职责：</strong> 负责接收客户端的 SQL 请求，进行 SQL 解析、语法检查、制定查询计划（Optimizer）、生成执行器。</p>
</li>
<li>
<p><strong>特点：</strong> <strong>它是无状态的（Stateless）。</strong> 它不存储任何实际的数据。</p>
</li>
<li>
<p><strong>扩展性：</strong> 如果你发现 SQL 解析慢了，或者并发连接数太高了，只需要加几台 TiDB Server 机器就行，完全不需要进行数据迁移。</p>
</li>
</ul>
<h4 id="2-存储层tikv分布式的肚子">2. 存储层：TiKV（分布式的“肚子”）
</h4><ul>
<li>
<p><strong>职责：</strong> 负责存储真正的数据。底层是一个巨大的、分布式的、有序的 Key-Value Map。</p>
</li>
<li>
<p><strong>实现：</strong> 内部使用 <strong>RocksDB</strong> 存储引擎。数据被切分成很多个 <strong>Region</strong>（默认 96MB），通过 <strong>Raft 协议</strong>（类似 Paxos）保证多副本一致性。</p>
</li>
<li>
<p><strong>扩展性：</strong> 如果你发现硬盘满了，或者磁盘 I/O 扛不住了，只需要加几台 TiKV 机器，数据会自动均衡过去。</p>
</li>
</ul>
<h4 id="3-调度层pd-placement-driver总指挥">3. 调度层：PD (Placement Driver)（“总指挥”）
</h4><ul>
<li><strong>职责：</strong> 存储元数据（哪个 Key 在哪个 TiKV 上），负责给 TiDB Server 提供路由信息，同时指挥 TiKV 进行数据搬迁和负载均衡。</li>
</ul>
<hr>
<h3 id="二-tidb-与-mysql-的核心区别">二、 TiDB 与 MySQL 的核心区别
</h3><p>我们将传统 MySQL（单机或主从架构）与 TiDB 进行深度对比：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>维度</strong></th>
          <th><strong>MySQL (传统架构)</strong></th>
          <th><strong>TiDB (存算分离架构)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>架构模式</strong></td>
          <td><strong>紧耦合 (Monolithic)</strong></td>
          <td><strong>松耦合 (Microservices-like)</strong></td>
      </tr>
      <tr>
          <td><strong>进程结构</strong></td>
          <td>SQL 解析器和 InnoDB 引擎在<strong>同一个进程</strong> (<code>mysqld</code>) 中。</td>
          <td>SQL 解析在 <code>TiDB</code> 进程，数据存储在 <code>TiKV</code> 进程，通常部署在不同机器上。</td>
      </tr>
      <tr>
          <td><strong>通信方式</strong></td>
          <td>内存函数调用 (Function Call)，极快。</td>
          <td><strong>网络 RPC 调用 (gRPC)</strong>，有网络延迟开销。</td>
      </tr>
      <tr>
          <td><strong>扩展能力 (Scaling)</strong></td>
          <td><strong>垂直扩展 (Vertical)</strong>：买更好的 CPU/内存。<br><strong>分库分表</strong>：需要中间件，运维极其痛苦。</td>
          <td><strong>水平扩展 (Horizontal)</strong>：计算不足加 TiDB，存储不足加 TiKV，<strong>完全透明</strong>，业务无感知。</td>
      </tr>
      <tr>
          <td><strong>查询执行</strong></td>
          <td>数据在哪，计算就在哪。</td>
          <td><strong>分布式计算</strong>：TiDB 生成计划，分发给多个 TiKV 并行处理。</td>
      </tr>
      <tr>
          <td><strong>事务限制</strong></td>
          <td>受限于单机内存和磁盘，大事务容易导致主从延迟。</td>
          <td>基于 <strong>Percolator 模型</strong> (Google) 的两阶段提交 (2PC)，支持跨行跨表分布式事务。</td>
      </tr>
      <tr>
          <td><strong>高可用</strong></td>
          <td>需依赖 MHA/Orchestrator，主从切换可能丢数据或需人工介入。</td>
          <td>基于 <strong>Raft 协议</strong>，自动选主，强一致性，RPO = 0（数据不丢）。</td>
      </tr>
  </tbody>
</table></div>
<h2 id="为什么lua脚本能保证原子性">为什么lua脚本能保证原子性？
</h2><p>简单直接的答案是：<strong>因为 Redis 的主工作线程是单线程的，且 Lua 脚本在执行时是“排他”的。</strong></p>
<p>我们可以把 Redis 想象成一个<strong>只开了一个窗口的办事大厅</strong>，而 Lua 脚本就是一份<strong>必须一次性办完的复杂文件</strong>。</p>
<p>以下是深度的技术原理拆解，帮助你在面试中不仅能答对，还能答出深度：</p>
<h3 id="1-核心机制单线程--独占模式">1. 核心机制：单线程 + 独占模式
</h3><p>Redis 的核心命令执行器是<strong>单线程</strong>的（Event Loop）。</p>
<ul>
<li>
<p><strong>普通命令（如 SET/GET）：</strong> Redis 会从队列里一个个取出来执行。A 客户端发一个 SET，B 客户端发一个 GET，它们是排队轮流执行的。</p>
</li>
<li>
<p><strong>Lua 脚本（EVAL）：</strong> 当 Redis 读到 <code>EVAL</code> 命令（执行 Lua 脚本）时，它会进入一种<strong>独占模式</strong>。</p>
<ul>
<li>
<p>Redis 会暂停处理所有其他客户端发来的请求。</p>
</li>
<li>
<p>它把整个 Lua 脚本作为一个<strong>整体</strong>交给 Lua 解释器执行。</p>
</li>
<li>
<p>只有当脚本执行结束（或者超时），Redis 才会恢复去处理请求队列里排队的下一个命令。</p>
</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong> 在 Lua 脚本执行期间，<strong>绝对不会</strong>有其他客户端的命令插队。这就从物理上保证了脚本内的操作是不可分割的（Indivisible），也就是<strong>原子性</strong>。</p>
<h3 id="面试高阶陷阱此原子性非彼原子性">面试高阶陷阱：此“原子性”非彼“原子性”
</h3><p>这是面试官最喜欢挖的坑，一定要主动指出来：</p>
<p><strong>Redis Lua 脚本的“原子性”是指“隔离性 (Isolation)”，而不是数据库事务中的“原子性 (Atomicity，要么全做要么全不做)”。</strong></p>
<ul>
<li>
<p><strong>SQL 事务：</strong> 如果中间报错，会<strong>回滚 (Rollback)</strong>，像什么都没发生过一样。</p>
</li>
<li>
<p><strong>Redis Lua：</strong> 如果脚本里有 3 条命令，执行到第 2 条报错了：</p>
<ul>
<li>
<p>第 1 条已经生效的数据<strong>不会回滚</strong>！</p>
</li>
<li>
<p>第 2 条报错停止。</p>
</li>
<li>
<p>第 3 条不会执行。</p>
</li>
<li>
<p>脚本结束。</p>
</li>
</ul>
</li>
</ul>
<p><strong>面试话术：</strong></p>
<blockquote>
<p>“Redis 的 Lua 脚本保证的是<strong>执行过程不被其他客户端打断</strong>，保证了操作的<strong>原子隔离性</strong>。但是，Redis <strong>不支持回滚 (Rollback)</strong>。如果脚本内部逻辑抛出错误，之前执行成功的写操作是无法撤销的。所以在编写 Lua 脚本时，必须保证代码逻辑的健壮性。”</p>
</blockquote>
<p>我的简历中使用了 <strong>Redisson 的 RRateLimiter</strong> ，这个组件的底层就是纯 Lua 脚本实现的。</p>
<p>可以这样举例：</p>
<blockquote>
<p>“比如我在项目中使用的令牌桶限流。</p>
<ol>
<li>
<p>我需要查询当前令牌够不够（GET）。</p>
</li>
<li>
<p>如果够，我就要扣减一个令牌（DECR）。</p>
</li>
</ol>
<p>这两个操作如果分开执行，在高并发下会出现‘超卖’（两个线程同时看到令牌剩余 1 个，结果都扣减了，变成 -1）。
而 Redisson 将这两个动作封装在一个 Lua 脚本里发给 Redis，因为 Lua 的原子性，这两个动作瞬间完成，中间没缝隙，绝对不会出现超卖。”</p>
</blockquote>
<h3 id="为什么这比-redis原生事务更强">为什么这比 Redis原生事务更强？
</h3><p>Redis 原生事务（MULTI/EXEC）存在一个痛点：<strong>CAS (Check-And-Set) 问题。</strong></p>
<ul>
<li>
<p><strong>Redis 事务流程：</strong> 你必须先 <code>GET</code> 一个值到客户端，判断一下（Check），然后再发 <code>SET</code> 命令（Set）。</p>
</li>
<li>
<p><strong>竞态条件：</strong> 在你 <code>GET</code> 之后、<code>SET</code> 之前，因为网络延迟，另一个客户端可能修改了这个值。虽然 <code>WATCH</code> 可以监控变化并取消事务，但这意味着你需要写重试逻辑，高并发下失败率极高。</p>
</li>
<li>
<p><strong>Lua 的优势：</strong> 逻辑直接在服务端运行。<code>GET</code> 和 <code>SET</code> 之间没有网络通信延迟，且中间没有其他命令插入。你可以放心地读取一个值，修改它，再写回去，完全不用担心期间被别人改了。</p>
</li>
</ul>
<h2 id="介绍一下虚拟内存">介绍一下虚拟内存
</h2><p><strong>虚拟内存 (Virtual Memory)</strong>，一言以蔽之，是<strong>操作系统对所有进程撒的一个弥天大谎</strong>。</p>
<p>它给每个进程（比如你的 Java 程序）营造了一个<strong>美丽的幻觉</strong>：</p>
<blockquote>
<p>“兄弟，这整个电脑的内存全是你的！是连续的！是独占的！你想怎么用怎么用，不用管别人。”</p>
</blockquote>
<p>但实际上，物理内存（RAM）可能早就被碎尸万段，甚至塞满了，部分数据都被赶到硬盘上去了。</p>
<p>在很久以前（DOS 时代），确实没有虚拟内存。程序直接操作<strong>物理地址</strong>。
这会导致三个严重问题：</p>
<ol>
<li>
<p><strong>打架（地址冲突）</strong>：</p>
<ul>
<li>
<p>QQ 说：“我要住 101 号房间。”</p>
</li>
<li>
<p>微信说：“我也要住 101 号房间。”</p>
</li>
<li>
<p><strong>崩了</strong>。程序员必须小心翼翼地规划，谁用哪块地。</p>
</li>
</ul>
</li>
<li>
<p><strong>偷窥（不安全）</strong>：</p>
<ul>
<li>
<p>QQ 住 101，微信住 102。</p>
</li>
<li>
<p>微信稍微伸个头，就能看到 QQ 在 101 房间里的隐私（读取内存数据）。恶意程序可以随意修改操作系统的核心数据。</p>
</li>
</ul>
</li>
<li>
<p><strong>不够用（内存不足）</strong>：</p>
<ul>
<li>你有 4GB 内存，GTA5 游戏要 8GB。直接报错退出，玩不了。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二-虚拟内存的机制怎么圆这个谎">二、 虚拟内存的机制（怎么圆这个谎？）
</h3><p>为了解决上面的问题，操作系统引入了<strong>中间商</strong>。</p>
<h4 id="1-核心道具页表-page-table--mmu">1. 核心道具：页表 (Page Table) &amp; MMU
</h4><ul>
<li>
<p><strong>虚拟地址 (Virtual Address)</strong>：进程手里拿到的房卡号（比如 0x001）。这是假的。</p>
</li>
<li>
<p><strong>物理地址 (Physical Address)</strong>：内存条上真正的存储单元地址（比如 0x8F3）。这是真的。</p>
</li>
<li>
<p><strong>映射表 (Page Table)</strong>：记录“假房号”对应“真房号”的小本本。</p>
</li>
<li>
<p><strong>MMU (Memory Management Unit)</strong>：CPU 里专门负责查表的一个硬件单元。</p>
</li>
</ul>
<h4 id="2-工作流程">2. 工作流程
</h4><p>当你的 Java 程序执行指令 <code>int a = 10</code> (假设要把 10 写到地址 0x001)：</p>
<ol>
<li>
<p><strong>进程发出指令</strong>：“我要往 <strong>0x001</strong> 写数据！”（这是虚拟地址）。</p>
</li>
<li>
<p><strong>MMU 拦截</strong>：“稍等，我查一下表。”</p>
<ul>
<li>MMU 查页表发现：进程 A 的 <strong>0x001</strong> 对应物理内存的 <strong>0x8F3</strong>。</li>
</ul>
</li>
<li>
<p><strong>硬件执行</strong>：CPU 把数据写到了物理内存的 <strong>0x8F3</strong>。</p>
</li>
</ol>
<p><strong>妙在哪里？</strong></p>
<ul>
<li>
<p><strong>QQ</strong> 往 <strong>0x001</strong> 写数据 -&gt; 映射到物理地址 <strong>0x800</strong>。</p>
</li>
<li>
<p><strong>微信</strong> 往 <strong>0x001</strong> 写数据 -&gt; 映射到物理地址 <strong>0x900</strong>。</p>
</li>
<li>
<p>虽然他们用的虚拟地址一样，但物理上完全隔离，互不干扰！</p>
</li>
</ul>
<h4 id="缺页中断-page-fault--空手套白狼">缺页中断 (Page Fault) —— “空手套白狼”
</h4><p>这是虚拟内存最骚的操作。
你的 Java 程序申请了 1GB 内存（比如 <code>new byte[1024*1024*1024]</code>）。
操作系统直接答应：“好，给你 1GB！”（虚拟内存里划给你了）。 <strong>但实际上，物理内存里 1KB 都没给你分配。</strong></p>
<ul>
<li>
<p><strong>当你真正开始写数据时</strong>：</p>
<ol>
<li>
<p>CPU 拿着虚拟地址去查表。</p>
</li>
<li>
<p>MMU 发现：<strong>“夷？这个页在物理内存里不存在（Valid 位是 0）。”</strong></p>
</li>
<li>
<p>触发 <strong>缺页中断 (Page Fault)</strong>。</p>
</li>
<li>
<p>操作系统内核醒来：“哎呀，这小子来真的了。”</p>
</li>
<li>
<p>操作系统赶紧找一块空闲的物理内存，分配给这个页，更新映射表。</p>
</li>
<li>
<p>让 CPU 重新执行刚才的写入指令。</p>
</li>
</ol>
</li>
</ul>
<p>这就是为什么 Java 启动时申请大内存很快，但实际占用（RES）是随着运行慢慢涨上去的。</p>
<h4 id="交换-swap--硬盘来凑数">交换 (Swap) —— 硬盘来凑数
</h4><p>如果物理内存真满了（比如开了几十个 Chrome 标签页），怎么办？</p>
<ul>
<li>
<p><strong>动作</strong>：操作系统会把那些<strong>很久没用的页</strong>（冷数据），从物理内存里踢出来，写到<strong>硬盘</strong>上（Swap 分区 / pagefile.sys）。</p>
</li>
<li>
<p><strong>腾地</strong>：物理内存腾出来了，给当前急用的程序用。</p>
</li>
<li>
<p><strong>换回</strong>：当你突然切回那个很久没用的 Chrome 标签页，操作系统会再触发缺页中断，把硬盘里的数据读回物理内存（这时候你会感觉电脑卡了一下，硬盘灯狂闪）。</p>
</li>
</ul>
<p>操作系统中有很多内存淘汰策略，比如LRU，LFU，CLOCK，增强CLOCK等</p>
<h2 id="进程切换和线程切换的区别">进程切换和线程切换的区别?
</h2><p>1.进程切换:进程切换涉及到更多的内容，包括整个进程的地址空间、全局变量、文件描述符等。因此，进程切换的开销通常比线程切换大。
2.线程切换:线程切换只涉及到线程的堆栈、寄存器和程序计数器等，不涉及进程级别的资源，因此线程切换的开销较小。</p>
<h2 id="线程切换为什么比进程切换快节省了什么资源">线程切换为什么比进程切换快，节省了什么资源?
</h2><p>线程切换比进程切换快是因为线程共享同一进程的地址空间和资源，线程切换时只需切换堆栈和程序计数器等少量信息，而不需要切换地址空间，避免了进程切换时需要切换内存映射表等大量资源的开销，从而节省了时间和系统资源。</p>
<h2 id="jni是什么">JNI 是什么？
</h2><p>它在 Java 编程中是一个非常重要的机制，主要用于解决 Java 应用程序需要与本地代码（Native Code）交互的问题。</p>
<hr>
<h3 id="jni-的核心概念与作用">JNI 的核心概念与作用
</h3><h4 id="1-核心定义">1. 核心定义
</h4><p>JNI 是一套编程接口，它允许运行在 <strong>Java 虚拟机（JVM）</strong> 上的 Java 代码与用其他语言（如 <strong>C、C++</strong> 等）编写的本地应用程序和库进行交互。</p>
<h4 id="2-主要作用">2. 主要作用
</h4><ul>
<li>
<p><strong>调用本地库 (Calling Native Libraries):</strong> 允许 Java 程序调用操作系统底层功能、硬件设备驱动程序，或者使用已经存在的、用 C/C++ 等语言编写的高性能库。</p>
</li>
<li>
<p><strong>提高性能 (Performance Enhancement):</strong> 对于对性能要求极高或需要直接操作硬件的代码块，可以将其用 C/C++ 实现，并通过 JNI 在 Java 中调用，以提升执行效率。</p>
</li>
<li>
<p><strong>复用现有代码 (Reusing Existing Code):</strong> 允许开发者在 Java 项目中重用大量的现有 C/C++ 代码库，而无需将其完全重写成 Java。</p>
</li>
</ul>
<h3 id="jni-的缺点">JNI 的缺点
</h3><p>虽然 JNI 很强大，但它也有一些缺点：</p>
<ul>
<li>
<p><strong>失去跨平台性：</strong> 一旦使用 JNI，你的 Java 程序就依赖于特定的本地库文件，从而失去了 Java <strong>“一次编译，到处运行”</strong> 的跨平台优势。</p>
</li>
<li>
<p><strong>开发复杂性：</strong> JNI 的开发过程比纯 Java 复杂，需要处理 C/C++ 代码、头文件生成、本地内存管理和垃圾回收的交互等问题。</p>
</li>
<li>
<p><strong>安全和稳定性风险：</strong> 本地代码不受 JVM 内存管理和安全机制的保护。如果本地代码有内存泄漏或越界访问等错误，可能导致整个 JVM 崩溃。</p>
</li>
</ul>
<h2 id="springboot程序的jdbc连接到了mysql用的是uds请问流程是什么">SpringBoot程序的JDBC连接到了MySQL，用的是UDS，请问流程是什么
</h2><h3 id="场景准备">场景准备
</h3><ol>
<li>
<p><strong>主角 A (Spring Boot)</strong>：位于 Linux 系统的一个进程（假设 PID=100）。</p>
</li>
<li>
<p><strong>主角 B (MySQL)</strong>：位于 Linux 系统的另一个进程（假设 PID=200）。</p>
</li>
<li>
<p><strong>秘密通道 (UDS 文件)</strong>：MySQL 在启动时，会在硬盘上创建一个特殊文件，通常位于 <code>/var/lib/mysql/mysql.sock</code>（这个路径在 <code>my.cnf</code> 里配置）。</p>
</li>
</ol>
<p><strong>配置上的不同（这是关键第一步）：</strong> 平时你连数据库，URL 写的是 <code>jdbc:mysql://127.0.0.1:3306/...</code>。
用 UDS 时，你的 JDBC URL 会变得很奇怪，大概长这样（取决于具体的驱动实现，通常需要引入 <code>junixsocket</code> 等库配合）：</p>
<p>Properties</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># 意思就是：别走 TCP 了，帮我去连这个文件！</span>
</span></span><span class="line"><span class="cl"><span class="n">jdbc</span><span class="p">:</span><span class="n">mysql</span><span class="p">:</span><span class="o">///</span><span class="err">?</span><span class="n">socketFactory</span><span class="o">=</span><span class="n">org</span><span class="o">.</span><span class="n">newsclub</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">mysql</span><span class="o">.</span><span class="n">AFUNIXDatabaseSocketFactory</span><span class="o">&amp;</span><span class="n">socket</span><span class="o">=/</span><span class="k">var</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">mysql</span><span class="o">/</span><span class="n">mysql</span><span class="o">.</span><span class="n">sock</span>
</span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="二-详细连接流程从发起请求到拿到数据">二、 详细连接流程（从发起请求到拿到数据）
</h3><p>假设你的 Controller 收到一个请求，要查 <code>SELECT * FROM users</code>。</p>
<h4 id="第一阶段建立连接握手">第一阶段：建立连接（握手）
</h4><ol>
<li>
<p><strong>Java 发起系统调用</strong>：</p>
<ul>
<li>
<p>Spring Boot (JDBC 驱动) 解析 URL，发现要用 UDS。</p>
</li>
<li>
<p>它不再调用 TCP 的 <code>connect(ip, port)</code>，而是调用针对文件的系统调用 <strong><code>socket(AF_UNIX, ...)</code></strong> 和 <strong><code>connect(&quot;/var/lib/mysql/mysql.sock&quot;)</code></strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>操作系统（内核）介入</strong>：</p>
<ul>
<li>
<p>内核看到 Java 想连 <code>/var/lib/mysql/mysql.sock</code>。</p>
</li>
<li>
<p><strong>权限检查</strong>：内核检查运行 Java 进程的用户（比如 <code>app_user</code>）有没有对这个 sock 文件的<strong>读写权限</strong>。如果没有，直接报错 <code>Permission denied</code>。</p>
</li>
<li>
<p><strong>查找绑定</strong>：内核查看记录表，发现这个 sock 文件正被 <strong>PID=200 (MySQL)</strong> 监听（Listen）着。</p>
</li>
</ul>
</li>
<li>
<p><strong>建立通道</strong>：</p>
<ul>
<li>
<p>内核在内存里，直接在 PID=100 (Java) 和 PID=200 (MySQL) 之间搭了一根“虚拟管子”。</p>
</li>
<li>
<p><strong>分配句柄</strong>：</p>
<ul>
<li>
<p>给 Java 进程发一个文件句柄（FD），比如 <strong>FD=8</strong>。</p>
</li>
<li>
<p>给 MySQL 进程发一个文件句柄（FD），比如 <strong>FD=12</strong>。</p>
</li>
</ul>
</li>
<li>
<p>此时，<strong>连接建立完成</strong>。不需要 TCP 的三次握手（SYN, SYN-ACK, ACK），只有文件系统的查找开销。</p>
</li>
</ul>
</li>
</ol>
<h4 id="第二阶段发送-sql写数据">第二阶段：发送 SQL（写数据）
</h4><ol>
<li>
<p><strong>Java 写数据</strong>：</p>
<ul>
<li>
<p>Spring Boot 把 SQL 语句 <code>SELECT * FROM users</code> 转成字节流。</p>
</li>
<li>
<p>调用系统调用 <strong><code>write(FD=8, &quot;SELECT...&quot;)</code></strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>内核搬运（最快的部分）</strong>：</p>
<ul>
<li>
<p><strong>没有协议栈</strong>：内核<strong>不需要</strong>给数据包加 TCP 头、IP 头、不需要算校验和，也不需要路由查找。</p>
</li>
<li>
<p><strong>直接拷贝</strong>：内核直接把 Java 进程 <strong>发送缓冲区</strong> 里的数据，拷贝到 MySQL 进程的 <strong>接收缓冲区</strong> 里。</p>
</li>
<li>
<p>MySQL 那个监听的 FD=12 变得“可读”。</p>
</li>
</ul>
</li>
<li>
<p><strong>MySQL 读数据</strong>：</p>
<ul>
<li>MySQL 被唤醒，调用 <code>read(FD=12)</code>，拿到了 SQL 语句。</li>
</ul>
</li>
</ol>
<h4 id="第三阶段返回结果读数据">第三阶段：返回结果（读数据）
</h4><ol>
<li>
<p><strong>MySQL 处理</strong>：</p>
<ul>
<li>MySQL 解析 SQL，查自己的 B+ 树，找到了 10 条用户数据。</li>
</ul>
</li>
<li>
<p><strong>MySQL 写回</strong>：</p>
<ul>
<li>MySQL 调用 <code>write(FD=12, [用户数据])</code>。</li>
</ul>
</li>
<li>
<p><strong>内核再次搬运</strong>：</p>
<ul>
<li>内核把数据直接从 MySQL 的内存搬运到 Java 的内存缓冲区。</li>
</ul>
</li>
<li>
<p><strong>Java 拿到结果</strong>：</p>
<ul>
<li>Spring Boot 从 <code>read(FD=8)</code> 中苏醒，拿到 ResultSet，封装成对象返回给 Controller。</li>
</ul>
</li>
</ol>
<h3 id="如果用-tcp-127001-流程有啥区别">如果用 TCP (127.0.0.1) 流程有啥区别？
</h3><p>为了让你更直观地看到 UDS 省了啥，我们看看<strong>普通的 Localhost TCP 连接</strong>多了哪些步骤：</p>
<ol>
<li>
<p><strong>打包</strong>：Java 把 SQL 加上 TCP 头（源端口、目标端口）、IP 头（源IP 127.0.0.1、目标IP 127.0.0.1）。</p>
</li>
<li>
<p><strong>计算</strong>：CPU 计算 TCP 校验和。</p>
</li>
<li>
<p><strong>路由</strong>：内核网络层查路由表，发现是回环地址（Loopback）。</p>
</li>
<li>
<p><strong>伪装发送</strong>：数据包虽然不出网卡，但要在内核的协议栈里走一圈“虚拟出网再入网”的流程（MTU检查、防火墙规则检查 iptables 等）。</p>
</li>
<li>
<p><strong>拆包</strong>：MySQL 端收到后，去掉 IP 头、去掉 TCP 头，校验数据的完整性。</p>
</li>
</ol>
<p><strong>总结差异</strong>：</p>
<ul>
<li>
<p><strong>TCP 方式</strong>：就像你写了一封信，虽然寄给同一个办公室的同事，但你还是把它扔进了楼下的邮局信箱。邮局（内核网络栈）盖戳、分拣、再投递回同一个办公室。</p>
</li>
<li>
<p><strong>UDS 方式</strong>：你直接站起来，把信放在了同事的桌子上。</p>
</li>
</ul>
<h2 id="redis把数据从内核内存区拷贝到用户内存的过程">Redis把数据从内核内存区拷贝到用户内存的过程
</h2><h3 id="详细流程图解从-socket-到-redis">详细流程图解（从 Socket 到 Redis）
</h3><p>假设一个客户端发来了 <code>GET user:1</code>。</p>
<h4 id="第一步数据到达内核">第一步：数据到达内核
</h4><ol>
<li>
<p><strong>网卡</strong>接收到光信号/电信号，转成数据包。</p>
</li>
<li>
<p><strong>DMA (直接内存访问)</strong> 把数据包拷贝到内核的内存（Socket 接收缓冲区）。</p>
</li>
<li>
<p><strong>内核</strong>检查这根 Socket 对应的句柄（FD），发现 Redis 之前通过 <code>epoll_ctl</code> 关注了它的“可读事件”。</p>
</li>
<li>
<p><strong>内核动作</strong>：把这个 FD 加入到 <strong>就绪链表 (Ready List)</strong> 中。</p>
</li>
</ol>
<h4 id="第二步redis-醒来">第二步：Redis 醒来
</h4><ol>
<li>
<p>Redis 主线程一直在跑一个死循环（<code>aeMain</code>）。</p>
</li>
<li>
<p>循环里调用了 <code>epoll_wait</code>。</p>
</li>
<li>
<p>刚才数据一到，<code>epoll_wait</code> 立刻返回，告诉 Redis：“嘿，FD=5 是<strong>可读</strong>的！”</p>
</li>
</ol>
<h4 id="第三步读取与执行">第三步：读取与执行
</h4><ol>
<li>
<p>Redis 根据 FD=5，找到对应的<strong>处理函数</strong>（通常是 <code>readQueryFromClient</code>）。</p>
</li>
<li>
<p><strong>系统调用 <code>read</code></strong>：把数据从内核搬运到 Redis 的用户态 Buffer。</p>
</li>
<li>
<p><strong>协议解析</strong>：解析 RESP 协议，知道你要执行 <code>GET</code>。</p>
</li>
<li>
<p><strong>查字典</strong>：在内存的 HashMap 里找到 <code>user:1</code> 的值。</p>
</li>
<li>
<p><strong>准备回复</strong>：把结果写入到客户端对象的<strong>发送缓冲区</strong>。</p>
</li>
</ol>
<h4 id="第四步回复客户端">第四步：回复客户端
</h4><ol>
<li>
<p>如果发送缓冲区很小，Redis 直接当场就调用 <code>write</code> 发回去了。</p>
</li>
<li>
<p>如果发送缓冲区满了（或者内核的写缓冲区满了），Redis 会向 epoll 注册一个 <strong>“写事件”</strong>。</p>
</li>
<li>
<p>等下次内核告诉 Redis “这个 Socket 可以写了”，Redis 再继续把剩下的数据发完。</p>
</li>
</ol>
<h2 id="操作系统的io多路复用selectpollepoll">操作系统的IO多路复用select，poll，epoll
</h2><p>poll和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合，<strong>因此都需要遍历文件描述符集合来找到可读或可写的 Socket</strong>，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<ul>
<li>
<p>epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过epoll_ctl0 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是O(logn)。而 select/poll 内核里没有类似 epol 红黑树这种保存所有待检测的 socket 的数据结构，所以select/pol 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
</li>
<li>
<p><strong>epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中</strong>，当用户调用 epoll_wait0 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
</li>
</ul>
<p>我们来看一个最经典的场景：<strong>Redis 怎么把数据发给客户端？</strong> 假设 Redis 要发送字符串 <code>&quot;Hello&quot;</code>。</p>
<h3 id="1-物理位置">1. 物理位置
</h3><ul>
<li>
<p><strong>字符串 &ldquo;Hello&rdquo;</strong>：一开始在 Redis 的<strong>用户内存</strong>里。</p>
</li>
<li>
<p><strong>Socket 对象</strong>：在操作系统的<strong>内核内存</strong>里。</p>
</li>
</ul>
<h3 id="2-发送过程-write">2. 发送过程 (write)
</h3><p>Redis 调用 <code>write(fd, &quot;Hello&quot;)</code> 系统调用。</p>
<ul>
<li>
<p><strong>步骤 A：跨界拷贝（CPU Copy）</strong> CPU 暂停 Redis 的用户态运行，切换到内核态。
CPU 把 &ldquo;Hello&rdquo; 从 <strong>Redis 的用户内存</strong> 复制到 <strong>Socket 的发送缓冲区（内核内存）</strong>。 <em>注意：这时候数据其实还在内存里，没出去呢！</em></p>
</li>
<li>
<p><strong>步骤 B：DMA 拷贝</strong> 操作系统看“发送缓冲区”里有货了，就命令 <strong>网卡</strong>（硬件）：
“喂，把这块内存里的数据拿走发出去。”
网卡的 DMA 控制器直接把数据从<strong>内核内存</strong>搬运到<strong>网卡硬件</strong>上，然后变成电信号发走。</p>
</li>
</ul>
<h3 id="3-接收过程-read">3. 接收过程 (read)
</h3><p>客户端发来了一条命令 <code>&quot;GET&quot;</code>。</p>
<ul>
<li>
<p><strong>步骤 A：硬件接收</strong> 网卡收到电信号，转成数据包，通过 DMA 搬运到 <strong>Socket 的接收缓冲区（内核内存）</strong>。 <em>此时，Redis 还不知道数据来了。</em></p>
</li>
<li>
<p><strong>步骤 B：通知与唤醒 (Epoll)</strong> 内核发现这个 Socket 的接收缓冲区有数据了，于是通过 Epoll 告诉 Redis：“FD=5 有读事件了！”</p>
</li>
<li>
<p><strong>步骤 C：跨界拷贝（CPU Copy）</strong> Redis 醒来，调用 <code>read(fd)</code>。
CPU 把数据从 <strong>Socket 的接收缓冲区（内核内存）</strong> 复制到 <strong>Redis 的用户内存</strong>。
现在，Redis 终于可以在自己的变量里看到 <code>&quot;GET&quot;</code> 这三个字母了。</p>
</li>
</ul>
<h2 id="内核内存和socket是什么">内核内存和Socket是什么？
</h2><h3 id="内核内存-kernel-memory--皇宫禁地">内核内存 (Kernel Memory) —— “皇宫禁地”
</h3><p>在 Linux 操作系统中，物理内存（RAM）被逻辑上划分为两块：</p>
<ol>
<li>
<p><strong>用户空间 (User Space)</strong>：</p>
<ul>
<li>
<p><strong>谁在住？</strong> 你的 Java 程序、Chrome 浏览器、QQ 等所有应用程序。</p>
</li>
<li>
<p><strong>地位</strong>：平民百姓。权力有限，想干大事（读硬盘、发网络包）必须打报告（系统调用）。</p>
</li>
<li>
<p><strong>特点</strong>：如果你的 Java 程序崩了，只是这块地盘乱了，不会影响整个电脑。</p>
</li>
</ul>
</li>
<li>
<p><strong>内核空间 (Kernel Space) / 内核内存</strong>：</p>
<ul>
<li>
<p><strong>谁在住？</strong> 操作系统内核（Linux Kernel）、硬件驱动程序。</p>
</li>
<li>
<p><strong>地位</strong>：皇宫禁地（VIP）。拥有最高权限，可以随意操作 CPU、硬盘、网卡。</p>
</li>
<li>
<p><strong>特点</strong>：<strong>Socket 就存放在这里！</strong> 还有页表、进程表等核心数据。如果这里崩了，电脑直接蓝屏或重启。</p>
</li>
</ul>
</li>
</ol>
<p><strong>为什么要有“内核内存”？</strong> 主要是为了<strong>安全</strong>和<strong>隔离</strong>。防止你写了一个只有 bug 的代码，直接把操作系统的核心数据给改了，导致系统瘫痪。</p>
<h3 id="socket-是什么-插座与缓冲区">Socket 是什么？—— “插座与缓冲区”
</h3><p>“Socket” 翻译过来叫“插座”或“套接字”。
但这个翻译太抽象了。在<strong>内核内存</strong>的视角里，Socket 到底是什么？</p>
<p><strong>本质上，Socket 就是内核内存里的两个缓冲区（Buffer）结构体。</strong></p>
<p>当你用 Java <code>new Socket()</code> 创建一个连接时，内核会在<strong>内核内存</strong>里划出一小块地盘，专门维护这个连接。这块地盘里主要包含两部分：</p>
<ol>
<li>
<p><strong>接收缓冲区 (Recv Buffer)</strong>：</p>
<ul>
<li>
<p>像一个<strong>收件箱</strong>。</p>
</li>
<li>
<p>网卡收到网线传来的数据，会先扔进这个箱子，等着你的 Java 程序来取。</p>
</li>
</ul>
</li>
<li>
<p><strong>发送缓冲区 (Send Buffer)</strong>：</p>
<ul>
<li>
<p>像一个<strong>发件箱</strong>。</p>
</li>
<li>
<p>你的 Java 程序想发数据，先把数据扔进这个箱子，然后由操作系统择机发给网卡。</p>
</li>
</ul>
</li>
</ol>
<h2 id="传统的java17是用户级线程和内核级线程一对一处理">传统的Java17，是用户级线程和内核级线程一对一处理
</h2><p>在 Java 19（虚拟线程/协程）普及之前，Java 17 及更早版本，采用的确实是经典的 <strong>1:1 线程模型</strong>。</p>
<p>这意味着：<strong>每一个 Java 线程（User Thread），在底层都死死绑定着一个操作系统的内核线程（Kernel Thread）。</strong></p>
<h3 id="一-核心关系傀儡与真身">一、 核心关系：傀儡与真身
</h3><p>在 1:1 模型中，Java 线程和内核线程的关系，就像是 <strong>“皮影戏的傀儡”</strong> 和 <strong>“幕后的操纵者”</strong>。</p>
<ol>
<li>
<p><strong>Java 线程 (User Thread)</strong>：</p>
<ul>
<li>
<p>这是你在代码里 <code>new Thread()</code> 创建出来的对象。</p>
</li>
<li>
<p>它只是一个<strong>傀儡（皮影）</strong>。它有名字、有属性（ID、Priority），但它自己是没有生命的，动不起来。</p>
</li>
<li>
<p>它生活在 <strong>JVM 的堆内存</strong> 里（用户态）。</p>
</li>
</ul>
</li>
<li>
<p><strong>内核线程 (Kernel Thread / KLT)</strong>：</p>
<ul>
<li>
<p>这是操作系统（Linux/Windows）真正创建出来的<strong>工人</strong>。</p>
</li>
<li>
<p>它是<strong>幕后的操纵者</strong>。只有它才能被 CPU 调度，只有它才有资格进 CPU 干活。</p>
</li>
<li>
<p>它生活在 <strong>内核空间</strong> 里。</p>
</li>
</ul>
</li>
</ol>
<p><strong>所谓 1:1 映射</strong>：就是当你调用 <code>thread.start()</code> 时，JVM 会通过系统调用（System Call），向操作系统申请一个内核线程，然后把这个 Java 线程对象和那个内核线程**“绑死”**在一起。此后，这个 Java 线程的一举一动，其实都是那个内核线程在干活。</p>
<hr>
<h3 id="二-它们怎么通信控制权传递">二、 它们怎么“通信”？（控制权传递）
</h3><p>你问的“通信”，其实不是像发微信那样发消息，而是<strong>指令下达</strong>和<strong>状态同步</strong>。这一切都是通过 <strong>JNI (Java Native Interface)</strong> 和 <strong>系统调用 (System Call)</strong> 完成的。</p>
<p>我们可以把这想象成<strong>牵线</strong>的过程。</p>
<h4 id="1-启动指令start">1. 启动指令：<code>start()</code>
</h4><ul>
<li>
<p><strong>Java 层</strong>：你喊了一句 <code>t1.start()</code>。</p>
</li>
<li>
<p><strong>通信过程</strong>：</p>
<ol>
<li>
<p>Java 方法调用 <code>private native void start0()</code>。</p>
</li>
<li>
<p>这就触碰到了 JVM 的 C++ 代码。</p>
</li>
<li>
<p>JVM 向操作系统发起系统调用：<code>clone()</code> (Linux) 或 <code>CreateThread</code> (Windows)。</p>
</li>
<li>
<p><strong>操作系统</strong>：收到请求，创建一个真正的内核线程。</p>
</li>
<li>
<p><strong>绑定</strong>：JVM 把这个内核线程的 ID 记在 Java 线程对象里（建立了 1:1 关系）。</p>
</li>
</ol>
</li>
</ul>
<h4 id="2-行为控制sleep--yield--park">2. 行为控制：<code>sleep()</code> / <code>yield()</code> / <code>park()</code>
</h4><ul>
<li>
<p><strong>场景</strong>：你在 Java 代码里写了 <code>Thread.sleep(1000)</code>。</p>
</li>
<li>
<p><strong>通信过程</strong>：</p>
<ol>
<li>
<p>Java 线程（傀儡）说：“我要睡一秒。”</p>
</li>
<li>
<p>JVM 识别到这是个 Native 方法。</p>
</li>
<li>
<p>JVM 发起系统调用，告诉内核：“喂，把你手里控制这个 Java 线程的那个内核线程挂起（Suspend）1秒。”</p>
</li>
<li>
<p><strong>操作系统</strong>：把对应的内核线程从 CPU 上也就是“运行队列”里拿下来，扔到“等待队列”里。</p>
</li>
<li>
<p><strong>结果</strong>：Java 线程看起来停了，其实是背后的内核线程停了。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-阻塞同步io-操作">3. 阻塞同步：IO 操作
</h4><ul>
<li>
<p><strong>场景</strong>：你读取文件 <code>fis.read()</code>。</p>
</li>
<li>
<p><strong>通信过程</strong>：</p>
<ol>
<li>
<p>Java 代码执行到读取指令。</p>
</li>
<li>
<p>因为读取硬盘是特权操作，Java 线程自己干不了，必须陷入<strong>内核态</strong>。</p>
</li>
<li>
<p>对应的内核线程发起 IO 请求，然后被操作系统<strong>阻塞</strong>（因为它要等硬盘转圈圈）。</p>
</li>
<li>
<p><strong>反馈</strong>：内核线程不动了，Java 线程的状态也就变成了 <code>BLOCKED</code> 或 <code>RUNNABLE</code> (但在等待 syscall 返回)。</p>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="三-它们怎么调度谁说了算">三、 它们怎么调度？（谁说了算？）
</h3><p>这是最关键的：<strong>JVM 完全不管调度！JVM 是没有资格分配 CPU 时间片的。</strong></p>
<p>在 1:1 模型下，Java 线程的调度<strong>完全</strong>交给操作系统的<strong>调度器（Scheduler）</strong>。</p>
<h4 id="1-调度者os-调度器比如-linux-的-cfs">1. 调度者：OS 调度器（比如 Linux 的 CFS）
</h4><p>JVM 就像一个劳务派遣公司，它把人（线程）招进来，交给政府（OS）去管理。至于谁先干活、谁后干活、干多久，全看政府的心情。</p>
<h4 id="2-调度方式抢占式-preemptive">2. 调度方式：抢占式 (Preemptive)
</h4><p>操作系统是个独裁者，它采用**“抢占式”**调度。</p>
<ul>
<li>
<p><strong>时间片（Time Slice）</strong>：</p>
<ul>
<li>
<p>OS 给每个内核线程分配一小段 CPU 时间（比如 10ms - 100ms）。</p>
</li>
<li>
<p>时间一到，CPU 内部的时钟中断响铃。</p>
</li>
<li>
<p>OS 强行把当前线程踢下来（哪怕你代码还没跑完），换下一个线程上。</p>
</li>
</ul>
</li>
<li>
<p><strong>上下文切换 (Context Switch) —— 昂贵的代价</strong>：
这就是 1:1 模型最大的痛点。当 OS 决定切换线程时：</p>
<ol>
<li>
<p><strong>保存现场</strong>：把当前内核线程的寄存器值、程序计数器（跑到哪一行了）全部存回内存。</p>
</li>
<li>
<p><strong>刷新缓存</strong>：因为换人了，CPU L1/L2 缓存里的数据大部分都废了，需要重新加载。</p>
</li>
<li>
<p><strong>恢复现场</strong>：把下一个要运行的内核线程的信息读进寄存器。</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-java-优先级的尴尬">3. Java 优先级的尴尬
</h4><p>Java 里有 <code>Thread.setPriority(1-10)</code>。</p>
<ul>
<li>
<p><strong>现实</strong>：这玩意儿基本是个<strong>心理安慰</strong>。</p>
</li>
<li>
<p><strong>原因</strong>：Java 的优先级只是给 OS 一个“建议”。由于不同操作系统对优先级的定义不同（Linux 甚至可能忽略它），JVM 传过去之后，OS 可能会说：“好的我知道了，但我还是按我的规则办。”</p>
</li>
</ul>
<h2 id="synchronized的底层原理">synchronized的底层原理
</h2><h3 id="第一层数据结构层--mark-word-的比特位舞步">第一层：数据结构层 —— Mark Word 的比特位舞步
</h3><p>在 64 位 JVM 中，对象头（Object Header）里的 <strong>Mark Word</strong> 是 8 个字节（64 bit）。<code>synchronized</code> 的所有状态流转，本质上就是<strong>在修改这 64 个 bit</strong>。</p>
<p>我们需要关注最后 2 位（锁标志位）和倒数第 3 位（偏向锁位）：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>锁状态</strong></th>
          <th><strong>25 bit (未使用)</strong></th>
          <th><strong>31 bit (HashCode)</strong></th>
          <th><strong>1 bit (未用)</strong></th>
          <th><strong>4 bit (分代年龄)</strong></th>
          <th><strong>1 bit (偏向锁位)</strong></th>
          <th><strong>2 bit (锁标志位)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>无锁</strong></td>
          <td>&hellip;</td>
          <td>HashCode</td>
          <td>0</td>
          <td>age</td>
          <td>0</td>
          <td><strong>01</strong></td>
      </tr>
      <tr>
          <td><strong>偏向锁</strong></td>
          <td>ThreadID (54bit)</td>
          <td>Epoch (2bit)</td>
          <td>&hellip;</td>
          <td>age</td>
          <td><strong>1</strong></td>
          <td><strong>01</strong></td>
      </tr>
      <tr>
          <td><strong>轻量级锁</strong></td>
          <td>指向栈中 Lock Record 的指针 (62bit)</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td><strong>00</strong></td>
      </tr>
      <tr>
          <td><strong>重量级锁</strong></td>
          <td>指向互斥量（Monitor）的指针 (62bit)</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td><strong>10</strong></td>
      </tr>
      <tr>
          <td><strong>GC 标记</strong></td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td>&hellip;</td>
          <td><strong>11</strong></td>
      </tr>
  </tbody>
</table></div>
<ul>
<li>
<p><strong>底层细节</strong>：</p>
<ul>
<li>
<p>当锁是 <strong>轻量级锁 (00)</strong> 时，前 62 位不再存 HashCode，而是存一个<strong>内存地址指针</strong>，指向持有锁线程的<strong>栈帧</strong>。</p>
</li>
<li>
<p>当锁是 <strong>重量级锁 (10)</strong> 时，前 62 位指向<strong>堆内存</strong>中 C++ 定义的 <code>ObjectMonitor</code> 对象。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="第二层栈帧层--lock-record-锁记录">第二层：栈帧层 —— Lock Record (锁记录)
</h3><p>在<strong>轻量级锁</strong>阶段，JVM 并不想直接请求操作系统，它玩了一个“偷梁换柱”的把戏。</p>
<ol>
<li>
<p><strong>开辟空间</strong>：当代码进入 <code>synchronized</code> 块，如果当前是无锁状态，JVM 会在当前线程的<strong>栈帧</strong>中创建一个名为 <code>Lock Record</code> 的空间。</p>
</li>
<li>
<p><strong>Displaced Mark Word</strong>：JVM 把对象头里原本的 Mark Word 拷贝一份到这个 <code>Lock Record</code> 中（为了保存原本的 HashCode 和分代年龄，等锁释放了还得还回去）。</p>
</li>
<li>
<p><strong>CAS 争抢</strong>：JVM 尝试用 <strong>CAS (Compare And Swap)</strong> 指令，将对象头里的 Mark Word 替换为指向 <code>Lock Record</code> 的指针。</p>
<ul>
<li>
<p><strong>成功</strong>：对象头变成了“指针 + 00”，代表抢锁成功。</p>
</li>
<li>
<p><strong>失败</strong>：说明有竞争，或者已经锁了。JVM 会检查对象头的指针是不是指向我自己的栈？如果是，说明是<strong>重入锁</strong>，只需在栈里再放一个空的 Lock Record 记录重入次数即可。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第三层jvm-实现层--c-里的-objectmonitor">第三层：JVM 实现层 —— C++ 里的 ObjectMonitor
</h3><p>当竞争升级为重量级锁，JVM 会去堆中申请一个 C++ 对象：ObjectMonitor。</p>
<p>在 OpenJDK 的 HotSpot 源码中 (src/share/vm/runtime/objectMonitor.hpp)，它的核心结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">ObjectMonitor</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span> <span class="k">volatile</span> <span class="n">_owner</span><span class="p">;</span>      <span class="c1">// 指向当前持有锁的线程 (The King)
</span></span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="n">jlong</span>  <span class="n">_recursions</span><span class="p">;</span>  <span class="c1">// 锁的重入次数
</span></span></span><span class="line"><span class="cl">  <span class="k">volatile</span> <span class="kt">int</span>    <span class="n">_count</span><span class="p">;</span>       <span class="c1">// 抢锁计数器
</span></span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// 核心等待队列
</span></span></span><span class="line"><span class="cl">  <span class="n">ObjectWaiter</span> <span class="o">*</span> <span class="k">volatile</span> <span class="n">_cxq</span><span class="p">;</span>       <span class="c1">// (Contention Queue) 竞争队列，单向链表
</span></span></span><span class="line"><span class="cl">  <span class="n">ObjectWaiter</span> <span class="o">*</span> <span class="k">volatile</span> <span class="n">_EntryList</span><span class="p">;</span> <span class="c1">// 等待队列，双向链表 (阻塞状态的线程)
</span></span></span><span class="line"><span class="cl">  <span class="n">ObjectWaiter</span> <span class="o">*</span> <span class="k">volatile</span> <span class="n">_WaitSet</span><span class="p">;</span>   <span class="c1">// 等待集合 (调用wait()后的线程)
</span></span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>底层竞争流程（硬核版）：</strong></p>
<ol>
<li>
<p><strong>CAS 抢占</strong>：线程尝试通过 CAS 将 <code>_owner</code> 指针指向自己。成功则执行。</p>
</li>
<li>
<p><strong>自旋失败，入队</strong>：如果抢不到，线程被封装成 <code>ObjectWaiter</code> 对象。</p>
</li>
<li>
<p><strong>进入 cxq</strong>：线程首先通过 CAS 尝试把节点插入 <code>_cxq</code> 队列的头部（LIFO 策略，为了减少尾部维护开销）。</p>
</li>
<li>
<p><strong>OnDeck 机制</strong>：JVM 不会把所有人都唤醒，而是通过策略挑选一个继承人（Heir），称为 <code>OnDeck</code>，只有这个线程会去竞争锁，避免“惊群效应”。</p>
</li>
</ol>
<hr>
<h3 id="第四层操作系统与硬件层--futex-与-内存屏障">第四层：操作系统与硬件层 —— Futex 与 内存屏障
</h3><p>这是最底下的地基，也是为什么重量级锁慢的原因。</p>
<h4 id="1-操作系统mutex-与-futex">1. 操作系统：Mutex 与 Futex
</h4><p>当线程在 <code>ObjectMonitor</code> 里抢不到锁，需要“阻塞（Block）”时，JVM 会调用操作系统的内核函数。</p>
<ul>
<li>
<p><strong>Linux 环境下</strong>：</p>
<ul>
<li>
<p>早期：直接用 <code>pthread_mutex_lock</code>，这需要从<strong>用户态（User Mode）切换到内核态（Kernel Mode）</strong>。这个切换涉及到保存 CPU 寄存器上下文、刷新 CPU 缓存（L1/L2 Cache 失效）等，开销极大。</p>
</li>
<li>
<p><strong>现代优化 (Futex)</strong>：Linux 提供了 <code>futex</code> (Fast Userspace muTEX)。</p>
<ul>
<li>
<p>它先在<strong>用户态</strong>尝试通过 CAS 修改一个整数。</p>
</li>
<li>
<p>只有当 CAS 失败（确实有竞争），才会调用系统调用（System Call）陷入内核态去执行 <code>sem_wait</code> 让线程挂起。</p>
</li>
</ul>
</li>
<li>
<p><strong>park()</strong>：Java 中的 <code>LockSupport.park()</code> 底层就是调用了 <code>futex</code> 相关的系统调用。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-cpu-硬件内存语义-jmm">2. CPU 硬件：内存语义 (JMM)
</h4><p><code>synchronized</code> 不仅仅是锁，它还保证了 <strong>内存可见性</strong>。</p>
<ul>
<li>
<p><strong>Lock (monitorenter)</strong>：</p>
<ul>
<li>
<p>底层会插入一个 <strong>LoadBarrier</strong>（或类似的刷新指令）。</p>
</li>
<li>
<p>强制让当前线程的工作内存（CPU Cache）失效，必须从主内存重新读取变量。</p>
</li>
</ul>
</li>
<li>
<p><strong>Unlock (monitorexit)</strong>：</p>
<ul>
<li>
<p>底层会插入一个 <strong>StoreBarrier</strong>（写屏障）。</p>
</li>
<li>
<p>强制将工作内存中的最新修改立即刷新回主内存，确保别的线程能看到。</p>
</li>
</ul>
</li>
<li>
<p>确保每次都能读到业务的最新的缓存信息，比如剩余票数还剩1个，把之前获取锁之前获取到的2给删了，重新更新为最新值，然后在把剩余票数变为0个。</p>
</li>
</ul>
<h3 id="总结一条线程的黑化之路">总结：一条线程的“黑化”之路
</h3><p>如果一个 Java 线程去抢 <code>synchronized</code>：</p>
<ol>
<li>
<p><strong>CPU 指令层</strong>：先尝试 <strong>CAS</strong> 修改对象头。</p>
</li>
<li>
<p><strong>栈帧层</strong>：如果失败，检查是否是自己锁的（重入），或者尝试把 Mark Word 复制到自己栈帧（轻量级锁）。</p>
</li>
<li>
<p><strong>C++ 对象层</strong>：还失败？去堆里找 <code>ObjectMonitor</code>，把自己包装成 <code>ObjectWaiter</code> 节点，拼命往 <code>_cxq</code> 队列头挤。</p>
</li>
<li>
<p><strong>OS 内核层</strong>：挤不进去？调用 <code>futex</code> 系统调用，请求操作系统把自己挂起（Sleep），交出 CPU 时间片，从用户态跌落内核态，等待被唤醒。</p>
</li>
</ol>
<h2 id="介绍一下java里的volatile">介绍一下Java里的volatile
</h2><p><code>volatile</code> 是 Java 虚拟机（JVM）提供的一种<strong>轻量级的同步机制</strong>。在并发编程中，它通常被用来修饰变量。</p>
<p>理解 <code>volatile</code>，核心要抓住这三大特性：<strong>可见性</strong>、<strong>有序性</strong>，以及它<strong>不保证原子性</strong>。</p>
<p>以下是详细的拆解：</p>
<hr>
<h3 id="1-核心特性">1. 核心特性
</h3><h4 id="a-保证可见性-visibility">A. 保证可见性 (Visibility)
</h4><p>这是 <code>volatile</code> 最主要的作用。</p>
<ul>
<li>
<p><strong>问题背景：</strong> 在 Java 内存模型 (JMM) 中，每个线程都有自己的<strong>工作内存</strong> (Working Memory，对应 CPU 缓存)，变量存储在<strong>主内存</strong> (Main Memory) 中。线程操作变量时，会先将变量从主内存拷贝到自己的工作内存中。如果线程 A 修改了变量，线程 B 可能还在读取自己缓存中的旧值，导致数据不一致。</p>
</li>
<li>
<p><strong>volatile 的作用：</strong></p>
<ol>
<li>
<p>当一个线程修改了 <code>volatile</code> 变量的值，新值会<strong>立即刷新</strong>到主内存。</p>
</li>
<li>
<p>同时，会强制让其他线程工作内存中该变量的缓存<strong>失效</strong>。</p>
</li>
<li>
<p>当其他线程需要读取该变量时，必须重新从主内存读取最新值。</p>
</li>
</ol>
</li>
</ul>
<h4 id="b-禁止指令重排序-ordering">B. 禁止指令重排序 (Ordering)
</h4><ul>
<li>
<p><strong>问题背景：</strong> 为了提高性能，编译器和处理器通常会对指令进行重排序（即代码执行顺序可能与编写顺序不同），只要不影响单线程下的结果即可。但在多线程环境下，重排序可能导致严重的逻辑错误（例如：对象初始化了一半就被另一个线程使用了）。</p>
</li>
<li>
<p><strong>volatile 的作用：</strong> JVM 会通过插入<strong>内存屏障 (Memory Barrier)</strong> 来禁止特定类型的指令重排序，从而保证有序性。</p>
<ul>
<li><em>经典案例：</em> 单例模式的“双重检查锁”（Double-Checked Locking）。如果不加 <code>volatile</code>，可能导致拿到一个未完全初始化的对象。</li>
</ul>
</li>
</ul>
<h4 id="c-不保证原子性-no-atomicity">C. 不保证原子性 (No Atomicity)
</h4><p>这是面试和开发中最大的坑。</p>
<ul>
<li>
<p><strong>现象：</strong> <code>volatile</code> 不能替代 <code>synchronized</code> 或 <code>Lock</code>。</p>
</li>
<li>
<p><strong>例子：</strong> 对一个 <code>volatile int count</code> 执行 <code>count++</code> 操作。</p>
<ul>
<li>
<p><code>count++</code> 包含三个步骤：读值 -&gt; 加 1 -&gt; 写回。</p>
</li>
<li>
<p>如果两个线程同时读到了 100，都加 1，然后都写回 101。最终结果是 101，而不是期望的 102。</p>
</li>
</ul>
</li>
<li>
<p><strong>结论：</strong> 对于复合操作（Read-Modify-Write），<code>volatile</code> 无法保证线程安全。</p>
</li>
</ul>
<h3 id="3-什么时候使用-volatile">3. 什么时候使用 volatile？
</h3><p>由于 <code>volatile</code> 比 <code>synchronized</code> 开销小（因为它不会引起线程上下文切换），在满足以下两个条件时，推荐使用：</p>
<ol>
<li>
<p><strong>对变量的写操作不依赖于当前值</strong>（例如：不是 <code>i++</code>，而是 <code>flag = true</code>）。</p>
</li>
<li>
<p><strong>该变量没有包含在具有其他变量的不变式中</strong>。</p>
</li>
</ol>
<h4 id="常见场景-1状态标记量-flag">常见场景 1：状态标记量 (Flag)
</h4><p>用于控制线程停止或状态切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">volatile</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">shutdownRequested</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">shutdown</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">shutdownRequested</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doWork</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">shutdownRequested</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 执行业务逻辑</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h4 id="常见场景-2单例模式-double-checked-locking">常见场景 2：单例模式 (Double-Checked Locking)
</h4><p>这是 <code>volatile</code> 防重排最经典的应用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 必须加 volatile，防止指令重排导致 instance 指向未初始化的内存</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">Singleton</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// new 操作并非原子，分为3步：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 1. 分配内存</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 2. 初始化对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 3. 将 instance 指向内存地址</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="c1">// 若发生重排(1-&gt;3-&gt;2)，其他线程可能拿到非空的但未初始化的对象。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><hr>
<h3 id="4-总结volatile-vs-synchronized">4. 总结：volatile vs synchronized
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>volatile</strong></th>
          <th><strong>synchronized</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>可见性</strong></td>
          <td>保证</td>
          <td>保证</td>
      </tr>
      <tr>
          <td><strong>有序性</strong></td>
          <td>保证</td>
          <td>保证</td>
      </tr>
      <tr>
          <td><strong>原子性</strong></td>
          <td><strong>不保证</strong></td>
          <td>保证</td>
      </tr>
      <tr>
          <td><strong>线程阻塞</strong></td>
          <td>不会阻塞线程</td>
          <td>会阻塞线程</td>
      </tr>
      <tr>
          <td><strong>适用范围</strong></td>
          <td>仅变量</td>
          <td>方法、代码块</td>
      </tr>
      <tr>
          <td><strong>性能</strong></td>
          <td>较高 (轻量级)</td>
          <td>较低 (重量级，尽管已有优化)</td>
      </tr>
  </tbody>
</table></div>
<p><strong>一句话总结：</strong> <code>volatile</code> 是 Java 提供的轻量级同步机制，它主要用于保证多线程下的<strong>变量可见性</strong>和<strong>禁止指令重排</strong>，但它<strong>不能保证原子性</strong>，因此不能完全替代锁。</p>
<h3 id="它保证的顺序禁止内部瞎优化指令重排">它保证的“顺序”：禁止<strong>内部</strong>瞎优化（指令重排）
</h3><p>CPU 和编译器为了快，有时候会把你写的代码顺序打乱（只要单线程下逻辑通顺就行）。</p>
<ul>
<li>
<p><strong>Volatile 的作用：</strong> 告诉 CPU，“这行代码很关键，别给我乱动位置”。</p>
</li>
<li>
<p><strong>例子：</strong></p>
<ul>
<li>
<p>你写的是：<code>步骤1 -&gt; 步骤2 -&gt; volatile写</code></p>
</li>
<li>
<p>CPU 不允许优化成：<code>volatile写 -&gt; 步骤1 -&gt; 步骤2</code></p>
</li>
<li>
<p><strong>这就是你说的“保证代码执行顺序不改变”。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-它无法改变的并发无法阻止外部线程的插队">2. 它无法改变的“并发”：无法阻止<strong>外部</strong>线程的“插队”
</h3><p>这正是你后半句说的重点。<code>volatile</code> <strong>不是锁</strong>。</p>
<ul>
<li>
<p><strong>没有排他性：</strong> 它不能像 <code>synchronized</code> 那样让线程排队（Serial Execution）。</p>
</li>
<li>
<p><strong>现象：</strong> 线程 A 和线程 B 可以<strong>同时</strong>去修改这个 <code>volatile</code> 变量。</p>
</li>
<li>
<p><strong>后果：</strong> 如果操作不是原子的（比如 <code>i++</code>），大家还是会“撞车”。</p>
</li>
</ul>
<h2 id="讲解java的threadlocal">讲解Java的ThreadLocal
</h2><p><code>ThreadLocal</code> 是 Java 中一个非常重要且高频面试的并发工具类。它的核心思想是 <strong>“空间换时间”</strong>，为每个线程提供独立的变量副本，从而实现线程隔离。</p>
<p>以下我将从<strong>核心概念、应用场景、底层原理（源码级别）、内存泄漏问题</strong>以及<strong>最佳实践</strong>五个维度为你详细讲解。</p>
<hr>
<h3 id="1-核心概念">1. 核心概念
</h3><p><strong>ThreadLocal</strong>（线程局部变量）提供了线程本地变量。当你在代码中创建一个 <code>ThreadLocal</code> 变量时，访问这个变量的每个线程都会拥有一个<strong>独立的、自己的本地副本</strong>。</p>
<ul>
<li>
<p><strong>它的作用：</strong> 它是为了解决多线程并发访问共享变量时的线程安全问题，但它不是通过加锁（<code>synchronized</code>）来实现的，而是通过让每个线程自己玩自己的，互不干扰。</p>
</li>
<li>
<p><strong>比喻：</strong></p>
<ul>
<li>
<p><code>synchronized</code> 就像只有一个厕所，大家需要排队（锁），同一时间只能一个人用。</p>
</li>
<li>
<p><code>ThreadLocal</code> 就像给每个人发了一个专用的移动厕所，大家互不影响，不需要排队。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-核心应用场景">2. 核心应用场景
</h3><p><code>ThreadLocal</code> 主要有两个经典的使用场景：</p>
<ol>
<li>
<p><strong>线程隔离（每个线程需要一个独享的对象）：</strong></p>
<ul>
<li>
<p><strong>典型案例：</strong> <code>SimpleDateFormat</code>。它是线程不安全的，如果把它定义为 <code>static</code> 并在多线程中共用，会报错。</p>
</li>
<li>
<p><strong>解法：</strong> 使用 <code>ThreadLocal</code> 为每个线程创建一个单独的 <code>SimpleDateFormat</code> 副本。</p>
</li>
<li>
<p><strong>案例：</strong> 数据库连接（Connection）、Session 管理。</p>
</li>
</ul>
</li>
<li>
<p><strong>上下文传递（跨方法传递参数）：</strong></p>
<ul>
<li>
<p><strong>场景：</strong> 在一个 Web 请求中，从 Controller -&gt; Service -&gt; DAO，我们需要传递用户信息（User ID）。</p>
</li>
<li>
<p><strong>问题：</strong> 如果每个方法都加一个 <code>userId</code> 参数，代码会非常臃肿。</p>
</li>
<li>
<p><strong>解法：</strong> 在拦截器处将 User ID 存入 <code>ThreadLocal</code>，后续任何地方都可以直接取出来使用，无需层层传参。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-底层原理重点threadlocalmap">3. 底层原理（重点：ThreadLocalMap）
</h3><p>这是理解 <code>ThreadLocal</code> 的关键。很多人误以为 <code>ThreadLocal</code> 内部维护了一个 Map，Key 是线程，Value 是值。<strong>其实恰恰相反。</strong></p>
<h4 id="31-真实的存储结构">3.1 真实的存储结构
</h4><ul>
<li>
<p><strong>Thread 类中：</strong> 每个 <code>Thread</code> 对象内部维护了一个成员变量 <code>threadLocals</code>。</p>
<p>Java</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Thread.java 源码片段
</span></span><span class="line"><span class="cl">ThreadLocal.ThreadLocalMap threadLocals = null;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p><strong>ThreadLocalMap：</strong> 这是一个类似于 <code>HashMap</code> 的结构，但它是 <code>ThreadLocal</code> 的静态内部类。</p>
</li>
<li>
<p><strong>Key 和 Value：</strong></p>
<ul>
<li>
<p><strong>Key：</strong> 是当前的 <strong><code>ThreadLocal</code> 对象实例本身</strong>（而且是弱引用，WeakReference）。</p>
</li>
<li>
<p><strong>Value：</strong> 是我们 <code>set</code> 进去的具体值。</p>
</li>
</ul>
</li>
</ul>
<h4 id="32-引用关系图">3.2 引用关系图
</h4><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">Thread (当前线程)
</span></span><span class="line"><span class="cl">  └── threadLocals (ThreadLocalMap)
</span></span><span class="line"><span class="cl">       └── Entry[] (数组)
</span></span><span class="line"><span class="cl">            └── Entry (继承自 WeakReference)
</span></span><span class="line"><span class="cl">                 ├── Key (弱引用) ──&gt; ThreadLocal 实例
</span></span><span class="line"><span class="cl">                 └── Value (强引用) ──&gt; 具体对象 (如 Connection)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>结论：</strong> 数据其实是存放在<strong>线程对象（Thread）自己的堆内存里的，<code>ThreadLocal</code> 仅仅是一个访问入口</strong>（Key）。</p>
<h4 id="33-hash-冲突解决">3.3 Hash 冲突解决
</h4><p>与 <code>HashMap</code> 使用链表法/红黑树不同，<code>ThreadLocalMap</code> 使用的是 <strong>线性探测法 (Linear Probing)</strong>。</p>
<ul>
<li>
<p>如果计算出的槽位（slot）已经被占用了，它就往后找下一个空位存放。</p>
</li>
<li>
<p>这也意味着 <code>ThreadLocal</code> 不适合存储极其大量的数据，否则检索效率会下降。</p>
</li>
</ul>
<hr>
<h3 id="4-著名的内存泄漏问题">4. 著名的内存泄漏问题
</h3><p>这是 <code>ThreadLocal</code> 最致命的坑，也是面试必问点。</p>
<h4 id="41-为什么会泄漏">4.1 为什么会泄漏？
</h4><p><code>ThreadLocalMap</code> 的 Entry 对 Key（ThreadLocal） 是<strong>弱引用</strong>，但对 Value 是<strong>强引用</strong>。</p>
<ol>
<li>
<p><strong>Key 被回收：</strong> 如果外界没有 <code>ThreadLocal</code> 的强引用了，在下一次 GC 时，Key 会被回收，Entry 中的 Key 变成了 <code>null</code>。</p>
</li>
<li>
<p><strong>Value 还在：</strong> 但是，Value 是强引用，只要 Current Thread 还在运行（比如线程池中的核心线程，生命周期很长），这个 Value 就会一直存在于内存中，无法被回收。</p>
</li>
<li>
<p><strong>结果：</strong> 出现了一条 <code>Current Thread -&gt; ThreadLocalMap -&gt; Entry -&gt; Value</code> 的强引用链，导致 Value 占用的内存无法释放，形成内存泄漏。</p>
</li>
</ol>
<h4 id="42-各种补救措施探测式清理">4.2 各种补救措施（探测式清理）
</h4><p>Java 的设计者也想到了这点。<code>ThreadLocalMap</code> 在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法时，会顺便检查 Key 为 <code>null</code> 的 Entry，并将对应的 Value 清除。</p>
<h4 id="43-终极解决方案">4.3 终极解决方案
</h4><p><strong>必须在使用完后，手动调用 <code>remove()</code> 方法。</strong></p>
<hr>
<h3 id="5-最佳实践代码示例">5. 最佳实践代码示例
</h3><p>无论是在 Spring 的拦截器中，还是日常开发，请务必遵循 <code>try-finally</code> 模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">UserContext</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 定义 ThreadLocal，通常建议配合 static final 修饰</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ThreadLocal</span><span class="o">&lt;</span><span class="n">UserInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="n">userHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadLocal</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 设置值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setUser</span><span class="p">(</span><span class="n">UserInfo</span><span class="w"> </span><span class="n">user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">userHolder</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">user</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 获取值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">UserInfo</span><span class="w"> </span><span class="nf">getUser</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">userHolder</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. 清除值 (至关重要)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">remove</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">userHolder</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="c1">// 业务使用伪代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doBusiness</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">UserContext</span><span class="p">.</span><span class="na">setUser</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">UserInfo</span><span class="p">(</span><span class="s">&#34;Gemini&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">1</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 执行业务逻辑...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">serviceLayer</span><span class="p">.</span><span class="na">process</span><span class="p">();</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 5. 必须在 finally 中清除，防止内存泄漏和线程复用导致的数据污染</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">UserContext</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="6-父子线程传递-inheritablethreadlocal">6. 父子线程传递 (<code>InheritableThreadLocal</code>)
</h3><p>普通的 <code>ThreadLocal</code> 无法在子线程中获取父线程设置的值。如果需要传递，可以使用 <code>InheritableThreadLocal</code>。</p>
<ul>
<li>
<p><strong>原理：</strong> 在创建子线程（Thread 构造函数）时，会自动把父线程的 <code>inheritableThreadLocals</code> Map 中的数据复制一份给子线程。</p>
</li>
<li>
<p><strong>注意：</strong> 仅限创建时复制，后续父线程修改，子线程不可见（拷贝的是引用）。</p>
</li>
</ul>
<hr>
<h3 id="总结">总结
</h3><ol>
<li>
<p><strong>用途：</strong> 线程隔离（每个线程一份）和 上下文传递（透传参数）。</p>
</li>
<li>
<p><strong>原理：</strong> 每个 <code>Thread</code> 内部维护一个 <code>ThreadLocalMap</code>，Key 是 <code>ThreadLocal</code> 实例本身。</p>
</li>
<li>
<p><strong>坑：</strong></p>
<ul>
<li>
<p><strong>内存泄漏：</strong> 弱引用 Key 导致 Value 滞留。</p>
</li>
<li>
<p><strong>数据污染：</strong> 线程池复用线程时，如果没清理，下一个任务会读到上一个任务的数据。</p>
</li>
</ul>
</li>
<li>
<p><strong>铁律：</strong> 用完必须 <code>remove()</code>。</p>
</li>
</ol>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/ScreenShot_2025-11-27_155633_958.png"
	width="786"
	height="506"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/ScreenShot_2025-11-27_155633_958_hu_dca4a42741916eb.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF2.0/ScreenShot_2025-11-27_155633_958_hu_5a8b77ce7d614203.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="372px"
	
></p>
<p>如果不主动区remove()，那么这个threadLocal内部的key-value就会在下一次调用这个线程的时候访问到，产生内存泄漏。</p>
<h2 id="redo-log是什么">Redo Log是什么
</h2><p><strong>Redo Log</strong>（重做日志）是 MySQL 中 <strong>InnoDB 存储引擎</strong>特有的一种物理日志。</p>
<p>简单来说，它的核心作用是<strong>确保事务的持久性（Durability）</strong>，即防止数据库在发生故障（如断电、宕机）时丢失数据。它是实现 ACID 中 &ldquo;D&rdquo; 的关键。</p>
<p>为了帮助你透彻理解（特别是应对面试），我们可以从以下几个维度来解析：</p>
<hr>
<h3 id="1-为什么需要-redo-log">1. 为什么需要 Redo Log？
</h3><p>在 MySQL 中，数据是存在磁盘上的，但为了性能，更新操作通常是在内存（Buffer Pool）中完成的。</p>
<ul>
<li>
<p><strong>问题：</strong> 如果每次更新数据都直接写回磁盘的数据页（Page），因为数据页在磁盘上是随机分布的，这会产生大量的<strong>随机 I/O</strong>，性能非常差。</p>
</li>
<li>
<p><strong>解决：</strong> 既然直接写数据页太慢，InnoDB 采用了一种策略：当有记录需要更新时，先更新内存，然后<strong>把“在某个数据页上做了什么修改”记录到 Redo Log 中</strong>。</p>
</li>
<li>
<p><strong>优势：</strong> 写 Redo Log 是<strong>顺序 I/O</strong>（追加写入），速度非常快。</p>
</li>
</ul>
<p>这种技术被称为 <strong>WAL (Write-Ahead Logging)</strong>，即“先写日志，再写磁盘”。</p>
<blockquote>
<p><strong>核心场景：</strong> 如果 MySQL 突然宕机，内存中的脏页（修改过但还没写回磁盘的数据）会丢失。重启时，MySQL 可以利用磁盘上的 Redo Log 把这些丢失的修改“重做”一遍，从而恢复数据。</p>
</blockquote>
<hr>
<h3 id="2-redo-log-的工作原理">2. Redo Log 的工作原理
</h3><h4 id="物理结构">物理结构
</h4><p><strong>Redo Log 记录的是物理修改。例如：“在第 10 号表空间的第 50 号页面的偏移量 200 处，将值由 A 改为 B”。</strong></p>
<h4 id="写入流程-循环写入">写入流程 (循环写入)
</h4><p>Redo Log 的文件大小是固定的（例如配置了 4 个文件，每个 1GB）。InnoDB 使用<strong>循环写入</strong>（Circular Buffer）的方式来使用这些文件。</p>
<p>想象一个圆形的缓冲区：</p>
<ol>
<li>
<p><strong><code>write pos</code> (当前写入点)：</strong> 随着事务的执行，不断向前移动，写入新的日志。</p>
</li>
<li>
<p><strong><code>checkpoint</code> (擦除点/安全点)：</strong> 也是向前移动。当数据页被真正刷入磁盘后，对应的 Redo Log 就不需要了，可以被覆盖（擦除）。</p>
</li>
</ol>
<ul>
<li><strong>如果 <code>write pos</code> 追上了 <code>checkpoint</code>：</strong> 说明 Redo Log 满了。此时 MySQL 必须暂停更新操作，强制把内存中的脏页刷到磁盘中，以推进 <code>checkpoint</code>，腾出空间。</li>
</ul>
<hr>
<h3 id="3-关键参数innodb_flush_log_at_trx_commit">3. 关键参数：innodb_flush_log_at_trx_commit
</h3><p>这是面试中常考的配置项，决定了 Redo Log 何时从内存缓冲区（Redo Log Buffer）刷入磁盘文件。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>值</strong></th>
          <th><strong>行为描述</strong></th>
          <th><strong>安全性</strong></th>
          <th><strong>性能</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>0</strong></td>
          <td>每秒将日志写入磁盘一次。事务提交时不强制刷盘。</td>
          <td>低（崩溃可能丢失1秒数据）</td>
          <td>最高</td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>(默认)</strong> 每次事务提交时，都将日志强制写入磁盘。</td>
          <td><strong>高（最安全，保证 ACID）</strong></td>
          <td>一般</td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td>每次事务提交时写到操作系统缓存（OS Cache），由 OS 每秒刷盘一次。</td>
          <td>中（MySQL挂了没事，OS挂了会丢数据）</td>
          <td>高</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h3 id="4-重点区分redo-log-vs-binlog">4. 重点区分：Redo Log vs Binlog
</h3><p>这是面试中最容易混淆的点，必须清晰区分：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>Redo Log (重做日志)</strong></th>
          <th><strong>Binlog (归档日志)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>所属层级</strong></td>
          <td><strong>InnoDB 存储引擎层</strong> (特有)</td>
          <td><strong>MySQL Server 层</strong> (所有引擎通用)</td>
      </tr>
      <tr>
          <td><strong>记录内容</strong></td>
          <td><strong>物理日志</strong> (在某页做了某修改)</td>
          <td><strong>逻辑日志</strong> (SQL 语句或行数据的变更)</td>
      </tr>
      <tr>
          <td><strong>写入方式</strong></td>
          <td><strong>循环写</strong> (空间固定，会覆盖)</td>
          <td><strong>追加写</strong> (写满一个文件切换下一个，不覆盖)</td>
      </tr>
      <tr>
          <td><strong>核心作用</strong></td>
          <td><strong>崩溃恢复 (Crash-Safe)</strong></td>
          <td><strong>主从复制</strong>、数据备份/恢复</td>
      </tr>
  </tbody>
</table></div>
<h3 id="5-总结">5. 总结
</h3><p>如果把 MySQL 比如一本账本：</p>
<ul>
<li>
<p><strong>数据文件 (ibd)</strong> 是厚重的总账本，整理起来很慢。</p>
</li>
<li>
<p><strong>Redo Log</strong> 是手边的<strong>粉板（或记事贴）</strong>。</p>
</li>
</ul>
<h2 id="bin-log是什么">Bin Log是什么
</h2><p><strong>Binlog</strong>（Binary Log，二进制日志）是 MySQL <strong>Server 层</strong>（即通用层，不依赖于存储引擎）维护的一种日志文件。</p>
<p>如果说 Redo Log 是 InnoDB 引擎的“救命稻草”（用于崩溃恢复），那么 Binlog 就是 MySQL 的**“历史档案”**。</p>
<p>以下是关于 Binlog 的核心知识点，覆盖了原理、用途和常见的面试考点：</p>
<hr>
<h3 id="1-核心作用">1. 核心作用
</h3><p><strong>Binlog 记录了数据库中所有修改数据的操作（如 <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE</code>, <code>DROP</code> 等），不包括查询（<code>SELECT</code>, <code>SHOW</code>）。</strong></p>
<p>它的主要用途有两个：</p>
<ol>
<li>
<p><strong>主从复制 (Master-Slave Replication)：</strong></p>
<ul>
<li>这是最常见的用途。Master 节点把它的 Binlog 传递给 Slave 节点，Slave 接收并重放这些日志，从而保证主从数据一致。</li>
</ul>
</li>
<li>
<p><strong>数据恢复 (Point-in-Time Recovery)：</strong></p>
<ul>
<li>如果数据库误删了数据，可以使用最近的一次全量备份（Full Backup）恢复到某个时间点，然后通过重放 Binlog，把数据恢复到误操作的前一秒。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-记录格式-binlog_format">2. 记录格式 (binlog_format)
</h3><p>这是面试中的高频考点。Binlog 有三种记录模式，各有优劣：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>格式</strong></th>
          <th><strong>描述</strong></th>
          <th><strong>优点</strong></th>
          <th><strong>缺点</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>STATEMENT</strong></td>
          <td>记录执行的 <strong>SQL 语句原文</strong>（如 <code>UPDATE t SET a=1 WHERE id=10</code>）。</td>
          <td>日志文件小，网络传输快，IO 压力小。</td>
          <td><strong>存在数据不一致风险</strong>。如果 SQL 中包含 <code>NOW()</code>、<code>UUID()</code> 等函数，在从库执行时结果可能与主库不同。</td>
      </tr>
      <tr>
          <td><strong>ROW</strong></td>
          <td>记录<strong>每一行数据被修改成的样子</strong>（物理变更）。</td>
          <td><strong>非常安全</strong>，严格保证数据一致性。</td>
          <td>日志文件非常大（特别是批量 <code>UPDATE</code> 或 <code>DELETE</code> 时），消耗网络 bandwidth。</td>
      </tr>
      <tr>
          <td><strong>MIXED</strong></td>
          <td>混合模式。</td>
          <td>一般用 Statement，遇到可能导致不一致的 SQL（如用到系统变量）时自动切换为 Row。</td>
          <td>试图平衡两者，但有时难以预测 MySQL 的选择。</td>
      </tr>
  </tbody>
</table></div>
<blockquote>
<p><strong>最佳实践：</strong> 目前生产环境（特别是涉及金钱或核心数据时）推荐使用 <strong><code>ROW</code></strong> 格式，虽然空间占用大，但能保证数据的绝对一致性。</p>
</blockquote>
<hr>
<h3 id="3-写入机制-append-only">3. 写入机制 (Append Only)
</h3><p>与 Redo Log 的“循环写”（写满覆盖）不同，Binlog 是<strong>追加写</strong>（Append Only）。</p>
<ul>
<li>
<p>当一个 Binlog 文件写到一定大小（由 <code>max_binlog_size</code> 控制）后，会切换创建一个新的文件（例如 <code>mysql-bin.000001</code>, <code>mysql-bin.000002</code>）。</p>
</li>
<li>
<p>之前的日志<strong>不会被覆盖</strong>，除非你手动清理或设置了过期时间。</p>
</li>
</ul>
<hr>
<h3 id="4-关键参数sync_binlog">4. 关键参数：sync_binlog
</h3><p>这个参数控制 Binlog 什么时候刷入磁盘，与性能和安全息息相关：</p>
<ul>
<li>
<p><strong><code>sync_binlog = 0</code></strong>：MySQL 每次将 Binlog 写入 OS Cache，由操作系统决定何时刷盘。性能好，但机器宕机可能丢数据。</p>
</li>
<li>
<p><strong><code>sync_binlog = 1</code></strong>：每次事务提交都强制刷盘。<strong>最安全</strong>，但性能损耗最大。</p>
</li>
<li>
<p><strong><code>sync_binlog = N</code></strong>：每 N 次事务提交刷盘一次。</p>
</li>
</ul>
<blockquote>
<p><strong>双 1 配置：</strong> 在要求数据严谨的生产环境，通常建议 <code>sync_binlog = 1</code> 配合 <code>innodb_flush_log_at_trx_commit = 1</code>，这就是常说的“双 1 配置”，能最大程度保证数据不丢失。</p>
</blockquote>
<hr>
<h3 id="5-再次对比redo-log-vs-binlog">5. 再次对比：Redo Log vs Binlog
</h3><p>为了加深记忆，这里再次从另一个角度对比这两个日志：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特征</strong></th>
          <th><strong>Redo Log (重做日志)</strong></th>
          <th><strong>Binlog (归档日志)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>生动比喻</strong></td>
          <td><strong>草稿纸/记事贴</strong> (用完即丢)</td>
          <td><strong>历史档案馆/录像带</strong> (永久保存)</td>
      </tr>
      <tr>
          <td><strong>产生者</strong></td>
          <td>InnoDB 引擎特有</td>
          <td>MySQL Server 层 (所有引擎都有)</td>
      </tr>
      <tr>
          <td><strong>内容形式</strong></td>
          <td>物理日志 (&ldquo;在某页改了某值&rdquo;)</td>
          <td>逻辑日志 (&ldquo;执行了某SQL&rdquo; 或 &ldquo;某行变为了X&rdquo;)</td>
      </tr>
      <tr>
          <td><strong>主要场景</strong></td>
          <td>宕机恢复 (Crash Safe)</td>
          <td>主从复制、数据恢复</td>
      </tr>
      <tr>
          <td><strong>事务性</strong></td>
          <td>事务执行过程中不断写入</td>
          <td>事务<strong>提交时</strong>一次性写入</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h3 id="6-一个经典问题为什么需要两份日志">6. 一个经典问题：为什么需要两份日志？
</h3><p>你可能会问：<em>既然 Binlog 也有数据记录，为什么 InnoDB 还需要 Redo Log？</em></p>
<ol>
<li>
<p><strong>历史原因：</strong> MySQL 最早只有 Binlog（Server层），没有 Crash-safe 能力。后来引入 InnoDB 引擎，InnoDB 为了实现 ACID 中的持久性，自己搞了一套 Redo Log。</p>
</li>
<li>
<p><strong>效率原因：</strong> Binlog 是逻辑日志，恢复速度慢（需要重新执行 SQL 或重放行变更）；Redo Log 是物理日志，直接映射磁盘位置，恢复速度极快。</p>
</li>
</ol>
<h2 id="介绍一下kafka和rocketmq的刷盘策略">介绍一下kafka和RocketMQ的刷盘策略
</h2><p>这是一个非常经典的中间件对比问题。刷盘策略（Flushing Strategy）直接决定了消息队列（MQ）的<strong>吞吐量（Performance）和数据可靠性（Reliability）</strong>。</p>
<p>Kafka 和 RocketMQ 在这方面的设计理念有明显的区别：</p>
<ul>
<li>
<p><strong>RocketMQ：</strong> 提供了灵活的选择，由用户决定是追求极致性能还是极致数据安全。</p>
</li>
<li>
<p><strong>Kafka：</strong> 倾向于极致的吞吐量，将“数据可靠性”交给多副本复制（Replication）机制，而不是单机的强刷盘。</p>
</li>
</ul>
<p>以下是详细对比：</p>
<hr>
<h3 id="1-rocketmq-的刷盘策略">1. RocketMQ 的刷盘策略
</h3><p>RocketMQ 在 Broker 的配置文件中，通过 <code>flushDiskType</code> 参数提供了两种明确的策略。它的设计思路很像 MySQL 的配置，让用户自己权衡。</p>
<h4 id="a-异步刷盘-async_flush--默认策略">A. 异步刷盘 (ASYNC_FLUSH) —— <strong>默认策略</strong>
</h4><ul>
<li>
<p><strong>机制：</strong> 生产者发送消息后，Broker 只要把消息写入内存（Page Cache / MappedByteBuffer）就立刻返回“发送成功”。</p>
</li>
<li>
<p><strong>刷盘时机：</strong> 后台有一个线程会定时（通常每隔几毫秒）把内存中的数据刷入磁盘。</p>
</li>
<li>
<p><strong>优缺点：</strong></p>
<ul>
<li>
<p>✅ <strong>吞吐量高</strong>，延迟低。</p>
</li>
<li>
<p>⚠️ <strong>有数据丢失风险</strong>：如果服务器突然断电（宕机），内存中未刷盘的消息会丢失。</p>
</li>
</ul>
</li>
</ul>
<h4 id="b-同步刷盘-sync_flush">B. 同步刷盘 (SYNC_FLUSH)
</h4><ul>
<li>
<p><strong>机制：</strong> 生产者发送消息后，Broker 必须先把消息写入内存，<strong>并且强制调用 <code>fsync</code> 刷入磁盘后</strong>，才返回“发送成功”。</p>
</li>
<li>
<p><strong>优化（Group Commit）：</strong> 为了不让性能太差，RocketMQ 实现了**Group Commit（组提交）**机制。它不会每来一条消息就刷一次盘，而是攒一小批消息（微秒级等待），一次性 <code>fsync</code>，类似 MySQL 的机制。</p>
</li>
<li>
<p><strong>优缺点：</strong></p>
<ul>
<li>
<p>✅ <strong>数据绝对安全</strong>，断电不丢数据。</p>
</li>
<li>
<p>⚠️ <strong>吞吐量下降</strong>，延迟变高。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>适用场景：</strong> 金融、交易链路等对数据丢失“零容忍”的场景，必须用 <strong>SYNC_FLUSH</strong>。</p>
</blockquote>
<hr>
<h3 id="2-kafka-的刷盘策略">2. Kafka 的刷盘策略
</h3><p>Kafka 的设计哲学完全不同。它官方<strong>强烈不推荐</strong>用户强制控制刷盘，而是把这个工作完全交给<strong>操作系统</strong>。</p>
<h4 id="a-异步刷盘-依赖-os-page-cache--核心策略">A. 异步刷盘 (依赖 OS Page Cache) —— <strong>核心策略</strong>
</h4><ul>
<li>
<p><strong>机制：</strong> Kafka 收到消息后，通过 <code>write()</code> 系统调用把数据写入文件系统的 Page Cache（页缓存），然后立刻返回。</p>
</li>
<li>
<p><strong>刷盘时机：</strong> Kafka <strong>不主动</strong>调用 <code>fsync</code>。它依赖 Linux 系统的后台线程（pdflush/flush）根据系统的脏页策略（<code>vm.dirty_background_ratio</code> 等）自动将数据刷入磁盘。</p>
</li>
<li>
<p><strong>为什么这么设计？</strong></p>
<ul>
<li>
<p>Kafka 认为在分布式系统中，单机的持久化并不能保证绝对安全（硬盘坏了照样丢）。</p>
</li>
<li>
<p>Kafka 的安全性是通过 <strong>多副本机制 (Replication)</strong> 来保证的。只要消息被写入了多个副本（ISR 集合），即使主节点宕机且数据未刷盘，数据也可以从其他副本恢复。</p>
</li>
</ul>
</li>
</ul>
<h4 id="b-同步刷盘-可配置但很少用">B. 同步刷盘 (可配置，但很少用)
</h4><ul>
<li>
<p>虽然 Kafka 提供了 <code>log.flush.interval.messages</code>（每多少条刷一次）和 <code>log.flush.interval.ms</code>（每多少毫秒刷一次）参数，但官方建议保持默认值（即不配置，无限大），交给 OS 管理。</p>
</li>
<li>
<p>频繁调用 <code>fsync</code> 会极大地破坏 Kafka 的高吞吐特性。</p>
</li>
</ul>
<hr>
<h3 id="3-横向对比总结-面试必杀技">3. 横向对比总结 (面试必杀技)
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>RocketMQ</strong></th>
          <th><strong>Kafka</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>主要刷盘方式</strong></td>
          <td><strong>支持同步 &amp; 异步</strong></td>
          <td><strong>几乎全靠异步 (OS Page Cache)</strong></td>
      </tr>
      <tr>
          <td><strong>配置参数</strong></td>
          <td><code>flushDiskType</code> (SYNC_FLUSH / ASYNC_FLUSH)</td>
          <td><code>log.flush.interval</code> (建议忽略)</td>
      </tr>
      <tr>
          <td><strong>数据安全性保障</strong></td>
          <td><strong>单机层面</strong>：靠同步刷盘保证。<br><strong>集群层面</strong>：靠主从复制。</td>
          <td><strong>完全依赖集群层面</strong>的副本复制机制 (Replication / ISR)。</td>
      </tr>
      <tr>
          <td><strong>设计哲学</strong></td>
          <td>像传统数据库，提供“金融级”的单机可靠性选项。</td>
          <td>追求极致吞吐，相信操作系统和集群副本。</td>
      </tr>
      <tr>
          <td><strong>性能</strong></td>
          <td>异步刷盘极快；同步刷盘较慢（但有组提交优化）。</td>
          <td>极快（因为本质上是写内存）。</td>
      </tr>
  </tbody>
</table></div>
<hr>
<h3 id="4-深度思考为什么-kafka-敢不刷盘">4. 深度思考：为什么 Kafka 敢不刷盘？
</h3><p>这往往是面试官的追问：<em>“Kafka 异步刷盘，万一掉电了怎么办？”</em></p>
<p>回答的关键在于 <strong><code>acks</code> 参数</strong>：</p>
<ul>
<li>
<p>如果设置 <code>acks=all</code> (或 <code>-1</code>)：</p>
<ul>
<li>
<p>Kafka 会确保消息不仅写入了 Leader 的内存，还同步到了所有 ISR（In-Sync Replicas）节点的内存中，才会告诉生产者“成功”。</p>
</li>
<li>
<p><strong>容灾逻辑：</strong> 即使 Leader 突然断电且未刷盘，只要集群中还有一个 ISR 节点活着，数据就不会丢。</p>
</li>
</ul>
</li>
</ul>
<p><strong>结论：</strong></p>
<ul>
<li>
<p><strong>RocketMQ</strong> 的同步刷盘是<strong>物理层面的</strong>（写进硬盘才算完）。</p>
</li>
<li>
<p><strong>Kafka</strong> 的安全是<strong>逻辑层面的</strong>（复制到多台机器的内存才算完）。</p>
</li>
</ul>
<h2 id="page-cache是什么">Page Cache是什么？
</h2><p>简单一句话总结：<strong>Page Cache（页缓存）就是操作系统拿出一部分内存（RAM），专门用来给硬盘（Disk）“加速”的。</strong></p>
<p>我们从“在哪里”和“干什么”两个方面来拆解：</p>
<hr>
<h3 id="1-存储在哪里">1. 存储在哪里？
</h3><p><strong>它就在你的内存条里（RAM）。</strong></p>
<p>Page Cache 不是什么特殊的硬件，也不是硬盘里的一部分。</p>
<ul>
<li>
<p>当你买了一台服务器，比如有 32GB 内存。</p>
</li>
<li>
<p>你的 Java 程序只用了 4GB。</p>
</li>
<li>
<p>剩下的 28GB 内存闲着也是闲着，<strong>操作系统（Linux）就会毫不客气地把这些空闲内存征用</strong>，当作 Page Cache 使用。</p>
</li>
</ul>
<blockquote>
<p><strong>注意：</strong> 它是<strong>易失性</strong>的。既然是在内存里，一旦断电或者重启，Page Cache 里的东西瞬间就没了。</p>
</blockquote>
<hr>
<h3 id="2-它是干啥的为什么要用它">2. 它是干啥的？（为什么要用它？）
</h3><p>核心原因只有一个：<strong>硬盘太慢了，内存太快了。</strong></p>
<ul>
<li>
<p><strong>内存（RAM）</strong> 的速度像<strong>法拉利</strong>。</p>
</li>
<li>
<p><strong>硬盘（Disk）</strong> 的速度像<strong>蜗牛</strong>。</p>
</li>
</ul>
<p>如果 CPU 每次读写数据都要等着硬盘（蜗牛）慢慢爬，那 CPU（法拉利）大部分时间都在“发呆”等待。为了解决这个速度不匹配的问题，Linux 引入了 Page Cache 当作“中间商”。</p>
<h4 id="a-写操作write的加速-骗你写完了">A. 写操作（Write）的加速： “骗”你写完了
</h4><p>当 Kafka 说“我要把消息写到硬盘”时：</p>
<ol>
<li>
<p>操作系统直接把数据丢进 <strong>Page Cache（内存）</strong>。</p>
</li>
<li>
<p>操作系统立刻告诉 Kafka：“写完了，你走吧！”（其实还没进硬盘）。</p>
</li>
<li>
<p><strong>结果：</strong> Kafka 觉得写硬盘飞快（其实是写了内存），吞吐量极高。</p>
</li>
<li>
<p><strong>后续：</strong> 操作系统会在后台，找个空闲时间，慢慢把 Page Cache 里的数据搬运到硬盘里（这个过程叫 <strong>Flush/刷盘</strong>）。</p>
</li>
</ol>
<blockquote>
<p><strong>比喻：</strong> 你去图书馆还书（写数据）。
如果没有 Page Cache，你得自己跑进库房把书插回架子上（写磁盘），很慢。
有了 Page Cache，前台放了一个<strong>还书箱（内存）</strong>，你把书往箱子里一扔就走了（瞬间完成）。管理员晚点再把箱子里的书摆回架子。</p>
</blockquote>
<h4 id="b-读操作read的加速-猜你会再用">B. 读操作（Read）的加速： “猜”你会再用
</h4><p>当你要从硬盘读取一个文件时：</p>
<ol>
<li>
<p>操作系统把文件从硬盘读出来。</p>
</li>
<li>
<p>先在 <strong>Page Cache（内存）</strong> 里留一份备份，然后再给你。</p>
</li>
<li>
<p><strong>结果：</strong> 下次你（或者别人）再来读同一个文件时，操作系统直接从内存里拿给你，完全不需要动硬盘。速度提升几百倍。</p>
</li>
</ol>
<hr>
<h3 id="3-一个直观的现象linux-内存占用">3. 一个直观的现象（Linux 内存占用）
</h3><p>很多新手在用 Linux 时会发现一个“奇怪”的现象：</p>
<ul>
<li>
<p>我看机器空闲着，没跑什么程序。</p>
</li>
<li>
<p>但用 <code>free</code> 命令一看，<strong>内存（Memory）怎么被占用了 90% 以上？</strong></p>
</li>
</ul>
<p><strong>原因就是 Page Cache。</strong> Linux 的逻辑是：<strong>“闲着的内存就是浪费”</strong>。与其空着，不如把所有读写过的文件都缓存起来。</p>
<ul>
<li><strong>如果你的程序突然需要内存怎么办？</strong> 放心，Linux 会瞬间释放掉一部分 Page Cache 腾出空间给你的程序用。它是“借用”，不是“霸占”。</li>
</ul>
<hr>
<h3 id="4-总结">4. 总结
</h3><p>回到 Kafka 和 MySQL 的场景：</p>
<ol>
<li>
<p><strong>Page Cache 是谁？</strong> 是 Linux 操作系统利用空闲内存构建的一层缓存。</p>
</li>
<li>
<p><strong>在哪里？</strong> 在内存条里（RAM）。</p>
</li>
<li>
<p><strong>Kafka 为什么快？</strong> 因为 Kafka 写数据实际上是写到了 Page Cache（内存）里，相当于写内存，当然快。</p>
</li>
<li>
<p><strong>风险是什么？</strong> 既然在内存里，<strong>断电即失</strong>。</p>
<ul>
<li>
<p>这就是为什么 Kafka 叫“异步刷盘”（写完内存就算成功）。</p>
</li>
<li>
<p>这也是为什么 MySQL 为了安全要搞“同步刷盘”（必须从 Page Cache 逼到硬盘里才算成功）。</p>
</li>
</ul>
</li>
</ol>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 LuciusWan
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
