# # 面试题总结- Java基础篇

## HashMap的底层原理

Hashap 是基于哈希表的数据结构，用于存储键值对(key-value )。其核心是将键的哈希值映射到数组索引位置，通过数组 +链表(在 Java 8 及之后是数组 +链表 +红黑树)来处理哈希冲突。

Hashmap 的默认初始容量为 16，负载因子为 0.75。也就是说，当存储的元素数量超过16x0.75=12个时， Hashmap 会触
发扩容操作，容量x2并重新分配元素位置。这种扩容是比较耗时的操作，频繁扩容会影响性能。

### HashMap 的红黑树优化:

从Java8开始，为了优化当多个元素映射到同一个哈希桶(即发生哈希冲突)时的查找性能，当链表长度超过8时，链表会转变为红黑树。红黑树是一种自平衡二叉搜索树，能够将最坏情况下的査找复杂度从 O(n) 降低到 O(log n)。如果树中元素的数量低于 6，红黑树会转换回链表，以减少不必要的树操作开销。

### hashCode()和 equals()的重要性:

HashMp 的键必须实现 hashcode()和 equals()方法。 hashcode()用于计算哈希值，以决定键的存储位置，而 equals()用于比较两个键是否相同。在 put 操作时，如果两个键的 hashcode()相同，但 equals()返回 false，则这两个键会被视为不同的键，存储在同一个桶的不同位置。

### 经典的“哈希冲突”案例

在 Java 中，最著名的例子就是字符串 `"Aa"` 和 `"BB"`。

Java

```
String s1 = "Aa";
String s2 = "BB";

System.out.println(s1.hashCode()); // 输出 2112
System.out.println(s2.hashCode()); // 输出 2112
System.out.println(s1.equals(s2)); // 输出 false
```

发生了什么？

Java 字符串的哈希算法是 s[0]*31 + s[1]：

- `'A'` 是 65，`'a'` 是 97 $\rightarrow 65 \times 31 + 97 = 2112$

- `'B'` 是 66 $\rightarrow 66 \times 31 + 66 = 2112$

虽然算出来的数字一样，但显然 `"Aa"` 和 `"BB"` 是完全不同的字符串。

### HashMap成环

![](C:\Users\86180\AppData\Roaming\marktext\images\2025-11-21-10-33-37-image.png)

![](C:\Users\86180\AppData\Roaming\marktext\images\2025-11-21-10-35-17-image.png)

![](C:\Users\86180\AppData\Roaming\marktext\images\2025-11-21-10-35-31-image.png)

![](C:\Users\86180\AppData\Roaming\marktext\images\2025-11-21-10-35-53-image.png)

![](C:\Users\86180\AppData\Roaming\marktext\images\2025-11-21-10-36-04-image.png)

由于线程1已经指向了B和A，线程2却先一步执行了扩容操作，而停止循环的条件就是e.next为null，当执行完扩容后，线程1苏醒，此时e为B，e.next为A，当前e的next指向A，导致A与B之间产生死循环，颠倒后依旧产生连接，就形成了环。

[JDK1.7HashMap多线程死循环问题_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hN411L7dy?vd_source=df996e877d54bec22f414fed7cb7fac4)

## Synchronized 和 ReentrantLock有什么区别?

### 实现层面

**`synchronized`**：

- 是 Java 的**关键字**，属于 **JVM 层面**的实现。

**`ReentrantLock`**：

- 是 JDK 提供的一个**类**（`java.util.concurrent.locks.ReentrantLock`），属于 **API 层面**的实现。

### 锁的释放

**`synchronized`**：

- **自动释放**。代码执行完同步代码块，或者抛出异常时，JVM 会自动释放锁，不会导致死锁。

**`ReentrantLock`**：

- **手动释放**。必须手动调用 `unlock()` 方法。

### 锁的公平性

**`synchronized`**：

- 只能是**非公平锁**。线程获取锁的顺序是不确定的，可能发生“饥饿”现象。

**`ReentrantLock`**：

- 默认是**非公平锁**（性能更好）。

- 可以通过构造函数 `new ReentrantLock(true)` 指定为**公平锁**（**遵循先来后到原则**），但性能会下降。

### 等待可中断

**`synchronized`**：

- **不可中断**。如果一个线程正在等待获取锁，它不能被中断（`interrupt`），只能一直阻塞等待。

**`ReentrantLock`**：

- **可中断**。通过 `lockInterruptibly()` 方法，可以让正在等待锁的线程响应中断，放弃等待去处理其他事情。

### 尝试获取锁

**`synchronized`**：

- 不行。要么拿到锁，要么阻塞死等。

**`ReentrantLock`**：

- 提供 `tryLock()` 方法。可以尝试获取锁，如果锁被占用，可以选择立即返回 `false` 或者等待一段指定的时间，非常灵活。

| **特性**   | **synchronized（隐式锁）** | **ReentrantLock（显式锁）**       |
| -------- | --------------------- | ---------------------------- |
| **实现方式** | 关键字 (JVM 层面)          | 类 (JDK API 层面)               |
| **锁的释放** | 隐式自动释放                | 显式手动释放 (需在 finally 中 unlock) |
| **公平性**  | 非公平                   | 默认非公平，可设置为公平                 |
| **响应中断** | 不支持                   | 支持 (`lockInterruptibly`)     |
| **条件队列** | 单个 (wait/notify)      | 多个 (Condition)               |
| **尝试获取** | 不支持 (死等)              | 支持 (`tryLock`)               |
| **灵活性**  | 低                     | 高                            |

## 锁升级

### 锁升级流程图解

| **锁状态**  | **触发条件**      | **优点**                  | **缺点**                |
| -------- | ------------- | ----------------------- | --------------------- |
| **偏向锁**  | 只有一个线程反复加锁    | 加锁/解锁几乎零消耗              | 如果存在线程竞争，撤销偏向锁会有额外开销  |
| **轻量级锁** | 线程交替执行，无同时竞争  | 不会阻塞线程，利用 CAS 和自旋，响应速度快 | 如果始终得不到锁，自旋会空耗 CPU    |
| **重量级锁** | 发生长时间或多线程同时竞争 | 不会空耗 CPU，未获锁线程进入阻塞      | 线程阻塞/唤醒涉及上下文切换，开销大，较慢 |

## CAS与自旋

### 什么是CAS（乐观锁）

- 你看到原句是“Hello”（**A**）。

- 你想改成“Hi”（**B**）。

- 在你提交修改的一瞬间，系统检查文档当前还是不是“Hello”（**V**）。
  
  - 如果是，修改成功。
  
  - 如果文档已经被别人改成了“Hello World”，你的预期（A）和实际（V）不符，提交失败，你需要重新读取再尝试。

### **CAS 的三大问题**

1. **ABA 问题**（最著名的坑）：
   
   - 虽然 V 还是 A，但不代表它没变过。它可能经历了 `A -> B -> A` 的过程。
   
   - **比喻**：桌上有一杯水（A），你离开了一会儿。回来时水还是满的（A），你以为没人动过。实际上可能有人喝光了（B），又给你倒满了（A）。虽然结果一样，但过程可能由于“杯子被用过”而产生副作用。
   
   - **解决**：加**版本号**。变成 `1A -> 2B -> 3A`。Java 中的 `AtomicStampedReference` 就是干这个的。给提交结果加版本号

2. **只能保证一个变量的原子性**：无法同时操作多个变量。

3. **CPU 开销大**：这通常与“自旋”结合在一起，见下文。

### 什么是 自旋 ？

**自旋**是一种线程等待的策略。

当线程抢不到锁（或 CAS 失败）时，它**不放弃 CPU，不进入阻塞状态（不睡觉）**，而是执行一个**空循环**（Loop），不断地检查“锁释放了吗？”或者“我能重试 CAS 了吗？”。

#### **为什么要自旋？**

为了**避免上下文切换**的开销。

- **阻塞/唤醒**：线程挂起和恢复需要操作系统介入，保存和恢复现场，非常耗时（可能比执行代码本身还慢）。

- **自旋**：如果锁被占用的时间很短，我在门口转两圈（自旋）锁就释放了，这样比“回家睡觉再被电话叫醒”快得多。

| **概念**  | **作用** | **核心词**   | **优缺点**                 |
| ------- | ------ | --------- | ----------------------- |
| **CAS** | 实现原子更新 | **比较并交换** | 优点：非阻塞，性能好<br>缺点：ABA 问题 |
| **自旋**  | 等待锁的策略 | **循环重试**  | 优点：避免上下文切换<br>缺点：耗费 CPU |
