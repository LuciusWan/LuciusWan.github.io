<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="记录一下八股">
<title>面试八股/场景</title>

<link rel='canonical' href='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/'>

<link rel="stylesheet" href="/scss/style.min.6a692fd055deae459f2a9767f57f3855ba80cafd5041317f24f7360f6ca47cdf.css"><meta property='og:title' content="面试八股/场景">
<meta property='og:description' content="记录一下八股">
<meta property='og:url' content='https://LuciusWan.github.io/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/'>
<meta property='og:site_name' content='LuciusWan'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-11-21T21:35:16&#43;08:00'/><meta property='article:modified_time' content='2025-11-21T21:35:16&#43;08:00'/>
<meta name="twitter:title" content="面试八股/场景">
<meta name="twitter:description" content="记录一下八股">
    <link rel="shortcut icon" href="/favicon.ico" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_a00c4178710685fc.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🎇</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">LuciusWan</a></h1>
            <h2 class="site-description">欢迎来到我的blog</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/440554295'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v6a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4v-6z" /><path d="M8 3l2 3" /><path d="M16 3l-2 3" /><path d="M9 13v-2" /><path d="M15 11v2" /></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/LuciusWan'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>友情链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#hashmap的底层原理">HashMap的底层原理</a>
      <ol>
        <li><a href="#hashmap-的红黑树优化">HashMap 的红黑树优化:</a></li>
        <li><a href="#hashcode和-equals的重要性">hashCode()和 equals()的重要性:</a></li>
        <li><a href="#经典的哈希冲突案例">经典的“哈希冲突”案例</a></li>
        <li><a href="#hashmap成环">HashMap成环</a></li>
      </ol>
    </li>
    <li><a href="#synchronized-和-reentrantlock有什么区别">Synchronized 和 ReentrantLock有什么区别?</a>
      <ol>
        <li><a href="#实现层面">实现层面</a></li>
        <li><a href="#锁的释放">锁的释放</a></li>
        <li><a href="#锁的公平性">锁的公平性</a></li>
        <li><a href="#等待可中断">等待可中断</a></li>
        <li><a href="#尝试获取锁">尝试获取锁</a></li>
      </ol>
    </li>
    <li><a href="#锁升级">锁升级</a>
      <ol>
        <li><a href="#锁升级流程图解">锁升级流程图解</a></li>
      </ol>
    </li>
    <li><a href="#cas与自旋">CAS与自旋</a>
      <ol>
        <li><a href="#什么是cas乐观锁">什么是CAS（乐观锁）</a></li>
        <li><a href="#cas-的三大问题"><strong>CAS 的三大问题</strong></a></li>
        <li><a href="#什么是-自旋-">什么是 自旋 ？</a>
          <ol>
            <li><a href="#为什么要自旋"><strong>为什么要自旋？</strong></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#springbean的生命周期">SpringBean的生命周期</a>
      <ol>
        <li><a href="#阶段一创建与注入-的基础">阶段一：创建与注入 (的基础)</a>
          <ol>
            <li><a href="#1-实例化-instantiation">1. 实例化 (Instantiation)</a></li>
            <li><a href="#2-属性赋值-populate-properties">2. 属性赋值 (Populate Properties)</a></li>
          </ol>
        </li>
        <li><a href="#阶段二容器感知-aware-接口回调">阶段二：容器感知 (Aware 接口回调)</a>
          <ol>
            <li><a href="#3-aware-接口回调-invoke-aware-interfaces">3. Aware 接口回调 (Invoke Aware Interfaces)</a></li>
          </ol>
        </li>
        <li><a href="#阶段三初始化与增强-最关键的步骤">阶段三：初始化与增强 (最关键的步骤)</a></li>
      </ol>
    </li>
    <li><a href="#redis和memcached的区别">Redis和Memcached的区别</a>
      <ol>
        <li><a href="#a-数据类型-data-types--最大的区别">A. 数据类型 (Data Types) —— 最大的区别</a></li>
        <li><a href="#b-线程模型-threading-model--性能的分水岭">B. 线程模型 (Threading Model) —— 性能的分水岭</a></li>
        <li><a href="#c-持久化-persistence--数据安全性">C. 持久化 (Persistence) —— 数据安全性</a></li>
        <li><a href="#d-分布式集群-clustering">D. 分布式/集群 (Clustering)</a></li>
      </ol>
    </li>
    <li><a href="#内核内存-vs-用户内存-the-two-worlds">内核内存 vs. 用户内存 (The Two Worlds)</a>
      <ol>
        <li>
          <ol>
            <li><a href="#1-内核内存-kernel-memory--kernel-space">1. 内核内存 (Kernel Memory / Kernel Space)</a></li>
            <li><a href="#2-用户内存-user-memory--user-space">2. 用户内存 (User Memory / User Space)</a></li>
          </ol>
        </li>
        <li><a href="#socket-是什么-the-abstraction">Socket 是什么？ (The Abstraction)</a></li>
      </ol>
    </li>
    <li><a href="#redis数据的全生命周期流程">Redis数据的全生命周期流程</a>
      <ol>
        <li><a href="#1-物理层网卡收货-nic">1. 物理层：网卡收货 (NIC)</a></li>
        <li><a href="#2-链路层--网络层内核协议栈介入">2. 链路层 &amp; 网络层：内核协议栈介入</a></li>
        <li><a href="#3-传输层分发给-socket-demultiplexing">3. 传输层：分发给 Socket (Demultiplexing)</a></li>
        <li><a href="#4-应用层数据搬运-copy-to-user">4. 应用层：数据搬运 (Copy to User)</a></li>
      </ol>
    </li>
    <li><a href="#那-redis-60-的-io-线程到底解决了什么">那 Redis 6.0 的 I/O 线程到底解决了什么？</a>
      <ol>
        <li><a href="#场景如果你只有主线程redis--60">场景：如果你只有主线程（Redis &lt; 6.0）</a></li>
        <li><a href="#场景你有-io-线程redis-60">场景：你有 I/O 线程（Redis 6.0+）</a></li>
      </ol>
    </li>
    <li><a href="#内核线程内核级线程用户级线程">内核线程，内核级线程，用户级线程</a>
      <ol>
        <li><a href="#用户级线程是怎么骗过内核的mn-模型">用户级线程是怎么“骗”过内核的？（M:N 模型）</a></li>
        <li><a href="#一-详细拆解三者的定义与区别">一、 详细拆解：三者的定义与区别</a>
          <ol>
            <li><a href="#1-内核线程-kernel-thread--kthread">1. 内核线程 (Kernel Thread / kthread)</a></li>
            <li><a href="#2-内核级线程-kernel-level-thread-klt">2. 内核级线程 (Kernel-Level Thread, KLT)</a></li>
            <li><a href="#3-用户级线程-user-level-thread-ult">3. 用户级线程 (User-Level Thread, ULT)</a></li>
          </ol>
        </li>
        <li><a href="#二-它们之间的映射模型-the-mapping-models">二、 它们之间的映射模型 (The Mapping Models)</a>
          <ol>
            <li><a href="#1-多对一模型-m--1--上古时代的产物">1. 多对一模型 (M : 1) —— 上古时代的产物</a></li>
            <li><a href="#2-一对一模型-1--1--现代主流-redis-nginx-java">2. 一对一模型 (1 : 1) —— 现代主流 (Redis, Nginx, Java)</a></li>
            <li><a href="#3-多对多模型-m--n--高并发的未来-gojava21-virtual-threads">3. 多对多模型 (M : N) —— 高并发的未来 (Go,Java21 Virtual Threads)</a></li>
          </ol>
        </li>
        <li><a href="#三-总结与对比表">三、 总结与对比表</a></li>
      </ol>
    </li>
    <li><a href="#一般什么情况下需要陷入内核态">一般什么情况下需要陷入内核态？</a>
      <ol>
        <li><a href="#1-系统调用-system-call--主动请求">1. 系统调用 (System Call) —— 主动请求</a></li>
        <li><a href="#2-异常-exception--内部错误或特殊事件">2. 异常 (Exception) —— 内部错误或特殊事件</a></li>
        <li><a href="#3-硬件中断-hardware-interrupt--被动打断">3. 硬件中断 (Hardware Interrupt) —— 被动打断</a></li>
      </ol>
    </li>
    <li><a href="#redis单线程避免上下文切换的开销">Redis单线程避免上下文切换的开销</a>
      <ol>
        <li><a href="#1-什么是昂贵的上下文切换">1. 什么是“昂贵”的上下文切换？</a></li>
        <li><a href="#2-多线程模式的痛点-the-context-switch-storm">2. 多线程模式的痛点 (The &ldquo;Context Switch Storm&rdquo;)</a></li>
        <li><a href="#3-redis-的单线程魔法-the-run-to-completion">3. Redis 的单线程魔法 (The &ldquo;Run-to-Completion&rdquo;)</a>
          <ol>
            <li><a href="#a-彻底消灭锁竞争">A. 彻底消灭“锁竞争”</a></li>
            <li><a href="#b-极致的-cache-亲和性-cache-affinity">B. 极致的 Cache 亲和性 (Cache Affinity)</a></li>
            <li><a href="#c-io-多路复用-epoll--避免-io-阻塞">C. I/O 多路复用 (Epoll) —— 避免 I/O 阻塞</a></li>
          </ol>
        </li>
        <li><a href="#4-总结对比多线程-vs-单线程">4. 总结对比：多线程 vs 单线程</a></li>
        <li><a href="#5-什么时候-redis-还是会切换">5. 什么时候 Redis 还是会切换？</a></li>
      </ol>
    </li>
    <li><a href="#redis写数据全生命周期">Redis写数据全生命周期</a>
      <ol>
        <li><a href="#第一阶段请求到达与分发-进---io-阶段">第一阶段：请求到达与分发 (进 - I/O 阶段)</a></li>
        <li><a href="#第二阶段命令执行-做---执行阶段">第二阶段：命令执行 (做 - 执行阶段)</a></li>
        <li><a href="#第三阶段响应返回-出---io-阶段">第三阶段：响应返回 (出 - I/O 阶段)</a></li>
        <li><a href="#第四阶段持久化-存---后台阶段">第四阶段：持久化 (存 - 后台阶段)</a></li>
      </ol>
    </li>
    <li><a href="#kafka为什么比rocketmq快">Kafka为什么比RocketMQ快</a>
      <ol>
        <li><a href="#参照物传统-io-standard-io">参照物：传统 I/O (Standard I/O)</a></li>
        <li><a href="#kafka-的绝技sendfile-数据管道">Kafka 的绝技：<code>sendfile</code> (数据管道)</a>
          <ol>
            <li><a href="#核心机制">核心机制</a></li>
          </ol>
        </li>
        <li><a href="#rocketmq-的绝技mmap-内存映射">RocketMQ 的绝技：mmap (内存映射)</a>
          <ol>
            <li><a href="#核心机制-1">核心机制</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#为什么rpchttp2能比http11快那么多">为什么RPC/HTTP2能比HTTP1.1快那么多</a>
      <ol>
        <li><a href="#1-多路复用-multiplexing--解决核心痛点">1. 多路复用 (Multiplexing) —— 解决核心痛点</a></li>
        <li><a href="#2-头部压缩-hpack--节省带宽">2. 头部压缩 (HPACK) —— 节省带宽</a></li>
        <li><a href="#3-二进制分帧-binary-framing--解析更快">3. 二进制分帧 (Binary Framing) —— 解析更快</a></li>
        <li><a href="#4-序列化协议-serialization--rpc-的独门秘籍">4. 序列化协议 (Serialization) —— RPC 的独门秘籍</a></li>
        <li><a href="#5-服务端推送-server-push">5. 服务端推送 (Server Push)</a></li>
        <li><a href="#总结对比">总结对比</a></li>
      </ol>
    </li>
    <li><a href="#heavykeeper和lrulfu">HeavyKeeper和LRU，LFU</a>
      <ol>
        <li><a href="#1-lru-least-recently-used---最近最少使用">1. LRU (Least Recently Used) - 最近最少使用</a></li>
        <li><a href="#2-lfu-least-frequently-used---最不经常使用">2. LFU (Least Frequently Used) - 最不经常使用</a></li>
        <li><a href="#3-heavykeeper---专门抓大象的守门员">3. HeavyKeeper - 专门抓“大象”的守门员</a></li>
        <li><a href="#总结对比表">总结对比表</a></li>
        <li><a href="#lru代码实现">LRU代码实现</a></li>
      </ol>
    </li>
    <li><a href="#redis的大key的问题怎么解决">Redis的大key的问题怎么解决</a>
      <ol>
        <li><a href="#一-什么是-big-key标准定义">一、 什么是 Big Key？（标准定义）</a></li>
        <li><a href="#二-如何发现-big-key">二、 如何发现 Big Key？</a></li>
        <li><a href="#三-如何安全地删除-big-key">三、 如何安全地删除 Big Key？</a>
          <ol>
            <li><a href="#1-redis-40-及以上版本推荐">1. Redis 4.0 及以上版本（推荐）</a></li>
            <li><a href="#2-redis-40-以下版本手动渐进式删除">2. Redis 4.0 以下版本（手动渐进式删除）</a></li>
          </ol>
        </li>
        <li><a href="#四-如何彻底解决设计与预防">四、 如何彻底解决（设计与预防）？</a>
          <ol>
            <li><a href="#1-拆分split">1. 拆分（Split）</a></li>
            <li><a href="#2-压缩compression">2. 压缩（Compression）</a></li>
            <li><a href="#3-剪裁与清洗pruning">3. 剪裁与清洗（Pruning）</a></li>
            <li><a href="#4-设置过期时间ttl">4. 设置过期时间（TTL）</a></li>
            <li><a href="#5-存储转移offloading">5. 存储转移（Offloading）</a></li>
          </ol>
        </li>
        <li><a href="#总结对照表">总结对照表</a></li>
      </ol>
    </li>
    <li><a href="#redis是怎么找到key存储在哪个节点上">Redis是怎么找到key存储在哪个节点上？</a>
      <ol>
        <li><a href="#一-核心算法crc16--取模">一、 核心算法：CRC16 + 取模</a></li>
        <li><a href="#二-生动比喻快递分拣中心">二、 生动比喻：快递分拣中心</a></li>
        <li><a href="#三-客户端是怎么知道去哪个节点的">三、 客户端是怎么知道去哪个节点的？</a>
          <ol>
            <li><a href="#1-笨客户端每次都问或问错了-moved-重定向错误">1. 笨客户端（每次都问，或问错了）—— MOVED 重定向错误</a></li>
            <li><a href="#2-聪明客户端smart-client如-jedis-lettuce-本地缓存">2. 聪明客户端（Smart Client，如 Jedis, Lettuce）—— 本地缓存</a></li>
          </ol>
        </li>
        <li><a href="#四-特殊情况hash-tag强制特定-key-去特定节点">四、 特殊情况：Hash Tag（强制特定 Key 去特定节点）</a></li>
        <li><a href="#1-没有-hash-tag老实模式">1. <strong>没有 Hash Tag（老实模式）</strong></a></li>
        <li><a href="#2-有-hash-tag偷懒模式">2. <strong>有 Hash Tag（偷懒模式）</strong></a></li>
        <li><a href="#小贴士hash-tag使用风险">小贴士（Hash Tag使用风险）</a></li>
      </ol>
    </li>
    <li><a href="#mysql三层b树能存储多少数据">MySQL三层B+树能存储多少数据?</a>
      <ol>
        <li><a href="#1-核心预设条件">1. 核心预设条件</a></li>
        <li><a href="#2-b-树结构拆解">2. B+ 树结构拆解</a>
          <ol>
            <li><a href="#第一步计算非叶子节点能存多少索引">第一步：计算非叶子节点能存多少索引？</a></li>
            <li><a href="#第二步计算叶子节点能存多少数据">第二步：计算叶子节点能存多少数据？</a></li>
          </ol>
        </li>
        <li><a href="#3-三层-b-树容量计算">3. 三层 B+ 树容量计算</a></li>
        <li><a href="#4-如果数据行很小怎么办">4. 如果数据行很小怎么办？</a></li>
        <li><a href="#5-现实中的误差fill-factor">5. 现实中的误差（Fill Factor）</a></li>
      </ol>
    </li>
    <li><a href="#事务的四大特性acid">事务的四大特性（ACID）</a></li>
    <li><a href="#mysql的事务隔离级别">MySQL的事务隔离级别</a>
      <ol>
        <li><a href="#并发事务的三大问题">并发事务的三大问题</a></li>
        <li><a href="#四种隔离级别详解">四种隔离级别详解</a>
          <ol>
            <li><a href="#1-读未提交-read-uncommitted">1. 读未提交 (Read Uncommitted)</a></li>
            <li><a href="#2-读已提交-read-committed---rc">2. 读已提交 (Read Committed - RC)</a></li>
            <li><a href="#3-可重复读-repeatable-read---rr--mysql-默认">3. 可重复读 (Repeatable Read - RR) —— <strong>MySQL 默认</strong></a></li>
            <li><a href="#4-串行化-serializable">4. 串行化 (Serializable)</a></li>
          </ol>
        </li>
        <li><a href="#隔离级别对比总结表">隔离级别对比总结表</a></li>
      </ol>
    </li>
    <li><a href="#为什么可重复读的情况下不能避免幻读">为什么可重复读的情况下不能避免幻读</a>
      <ol>
        <li><a href="#幻读示例自己修改或插入的数据trx_id会变为自己的可见">幻读示例（自己修改或插入的数据，trx_id会变为自己的，可见）</a>
          <ol>
            <li><a href="#阶段-1事务-a-开启生成-readview">阶段 1：事务 A 开启，生成 ReadView</a></li>
            <li><a href="#阶段-2事务-b-插入并提交">阶段 2：事务 B 插入并提交</a></li>
            <li><a href="#阶段-3事务-a-第一次查询-id5">阶段 3：事务 A 第一次查询 <code>id=5</code></a></li>
            <li><a href="#阶段-4事务-a-执行-update关键转折点">阶段 4：事务 A 执行 UPDATE（关键转折点！）</a></li>
            <li><a href="#阶段-5事务-a-第二次查询-id5">阶段 5：事务 A 第二次查询 <code>id=5</code></a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#readview-到底存了什么">ReadView 到底存了什么？</a>
      <ol>
        <li><a href="#mvcc简单的流程">MVCC简单的流程</a></li>
      </ol>
    </li>
    <li><a href="#mysql的锁">MySQL的锁</a>
      <ol>
        <li><a href="#共享锁">共享锁</a></li>
        <li><a href="#排他锁">排他锁</a></li>
        <li><a href="#表锁">表锁</a></li>
        <li><a href="#意向锁">意向锁</a></li>
        <li><a href="#行锁">行锁</a></li>
        <li><a href="#间隙锁">间隙锁</a></li>
        <li><a href="#next-key-lock">Next-Key Lock</a></li>
        <li><a href="#mdl锁">MDL锁</a></li>
      </ol>
    </li>
    <li><a href="#索引下推是什么">索引下推是什么？</a>
      <ol>
        <li><a href="#mysql-处理-sql-语句时主要分为两层">MySQL 处理 SQL 语句时，主要分为两层：</a></li>
        <li><a href="#场景复盘">场景复盘</a>
          <ol>
            <li><a href="#为什么这个场景特殊">为什么这个场景特殊？</a></li>
          </ol>
        </li>
        <li><a href="#详细对比无-icp-vs-有-icp">详细对比：无 ICP vs 有 ICP</a>
          <ol>
            <li><a href="#-阶段一没有-icp-mysql-56-之前">❌ 阶段一：没有 ICP (MySQL 5.6 之前)</a></li>
            <li><a href="#-阶段二开启-icp-mysql-56-及以后">✅ 阶段二：开启 ICP (MySQL 5.6 及以后)</a></li>
          </ol>
        </li>
        <li><a href="#怎么看有没有用到-icp">怎么看有没有用到 ICP？</a></li>
        <li><a href="#正常的联合索引完美匹配">正常的联合索引（完美匹配）</a></li>
        <li><a href="#索引下推-icp范围查询导致断档">索引下推 ICP（范围查询导致断档）</a></li>
        <li><a href="#server层处理无法下推的条件">Server层处理“无法下推”的条件</a></li>
      </ol>
    </li>
    <li><a href="#索引下推查询的全流程">索引下推查询的全流程</a>
      <ol>
        <li><a href="#场景设定">场景设定</a></li>
        <li><a href="#2-详细执行流程-pipeline">2. 详细执行流程 (Pipeline)</a>
          <ol>
            <li><a href="#第一步server-层准备阶段">第一步：Server 层（准备阶段）</a></li>
            <li><a href="#第二步innodb-存储引擎层icp-核心阶段">第二步：InnoDB 存储引擎层（ICP 核心阶段）</a></li>
            <li><a href="#第三步innodb-存储引擎层回表阶段">第三步：InnoDB 存储引擎层（回表阶段）</a></li>
            <li><a href="#第四步server-层最终兜底阶段">第四步：Server 层（最终兜底阶段）</a></li>
          </ol>
        </li>
        <li><a href="#3-流程总结图解">3. 流程总结图解</a></li>
      </ol>
    </li>
    <li><a href="#priorityqueue的相关api">PriorityQueue的相关API</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/redis/" style="background-color: #eb1212d1; color: #fff;">
                Redis
            </a>
        
            <a href="/categories/java/" style="background-color: #FFB90F; color: #fff;">
                Java
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/">面试八股/场景</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            记录一下八股
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-11-21</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 55 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h1 id="面试题总结">面试题总结
</h1><h2 id="hashmap的底层原理">HashMap的底层原理
</h2><p>Hashap 是基于哈希表的数据结构，用于存储键值对(key-value )。其核心是将键的哈希值映射到数组索引位置，通过数组 +链表(在 Java 8 及之后是数组 +链表 +红黑树)来处理哈希冲突。</p>
<p>Hashmap 的默认初始容量为 16，负载因子为 0.75。也就是说，当存储的元素数量超过16x0.75=12个时， Hashmap 会触
发扩容操作，容量x2并重新分配元素位置。这种扩容是比较耗时的操作，频繁扩容会影响性能。</p>
<h3 id="hashmap-的红黑树优化">HashMap 的红黑树优化:
</h3><p>从Java8开始，为了优化当多个元素映射到同一个哈希桶(即发生哈希冲突)时的查找性能，当链表长度超过8时，链表会转变为红黑树。红黑树是一种自平衡二叉搜索树，能够将最坏情况下的査找复杂度从 O(n) 降低到 O(log n)。如果树中元素的数量低于 6，红黑树会转换回链表，以减少不必要的树操作开销。</p>
<h3 id="hashcode和-equals的重要性">hashCode()和 equals()的重要性:
</h3><p>HashMp 的键必须实现 hashcode()和 equals()方法。 hashcode()用于计算哈希值，以决定键的存储位置，而 equals()用于比较两个键是否相同。在 put 操作时，如果两个键的 hashcode()相同，但 equals()返回 false，则这两个键会被视为不同的键，存储在同一个桶的不同位置。</p>
<h3 id="经典的哈希冲突案例">经典的“哈希冲突”案例
</h3><p>在 Java 中，最著名的例子就是字符串 <code>&quot;Aa&quot;</code> 和 <code>&quot;BB&quot;</code>。</p>
<p>Java</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">String s1 = &#34;Aa&#34;;
</span></span><span class="line"><span class="cl">String s2 = &#34;BB&#34;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">System.out.println(s1.hashCode()); // 输出 2112
</span></span><span class="line"><span class="cl">System.out.println(s2.hashCode()); // 输出 2112
</span></span><span class="line"><span class="cl">System.out.println(s1.equals(s2)); // 输出 false
</span></span></code></pre></td></tr></table>
</div>
</div><p>发生了什么？</p>
<p>Java 字符串的哈希算法是 s[0]*31 + s[1]：</p>
<ul>
<li>
<p><code>'A'</code> 是 65，<code>'a'</code> 是 97 \rightarrow 65 \times 31 + 97 = 2112</p>
</li>
<li>
<p><code>'B'</code> 是 66 \rightarrow 66 \times 31 + 66 = 2112</p>
</li>
</ul>
<p>虽然算出来的数字一样，但显然 <code>&quot;Aa&quot;</code> 和 <code>&quot;BB&quot;</code> 是完全不同的字符串。</p>
<h3 id="hashmap成环">HashMap成环
</h3><p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-33-37-image.png"
	width="1046"
	height="496"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-33-37-image_hu_245e35e2ba895441.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-33-37-image_hu_99cead4911386ea3.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="210"
		data-flex-basis="506px"
	
></p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-17-image.png"
	width="1370"
	height="672"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-17-image_hu_d4551b7e186d0924.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-17-image_hu_cf4451a0d7533d2c.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="203"
		data-flex-basis="489px"
	
></p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-31-image.png"
	width="1365"
	height="666"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-31-image_hu_569407ec3d36eaa0.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-31-image_hu_10318e994b3afc1e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="204"
		data-flex-basis="491px"
	
></p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-53-image.png"
	width="1003"
	height="475"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-53-image_hu_d06933d3711cdba2.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-35-53-image_hu_118961ddc2fcce3b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="211"
		data-flex-basis="506px"
	
></p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-36-04-image.png"
	width="953"
	height="502"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-36-04-image_hu_859596b78859ff6c.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/2025-11-21-10-36-04-image_hu_884412cd639396be.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="189"
		data-flex-basis="455px"
	
></p>
<p>由于线程1已经指向了B和A，线程2却先一步执行了扩容操作，而停止循环的条件就是e.next为null，当执行完扩容后，线程1苏醒，此时e为B，e.next为A，当前e的next指向A，导致A与B之间产生死循环，颠倒后依旧产生连接，就形成了环。</p>
<p><a class="link" href="https://www.bilibili.com/video/BV1hN411L7dy?vd_source=df996e877d54bec22f414fed7cb7fac4"  target="_blank" rel="noopener"
    >JDK1.7HashMap多线程死循环问题_哔哩哔哩_bilibili</a></p>
<h2 id="synchronized-和-reentrantlock有什么区别">Synchronized 和 ReentrantLock有什么区别?
</h2><h3 id="实现层面">实现层面
</h3><p><strong><code>synchronized</code></strong>：</p>
<ul>
<li>是 Java 的<strong>关键字</strong>，属于 <strong>JVM 层面</strong>的实现。</li>
</ul>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li>是 JDK 提供的一个<strong>类</strong>（<code>java.util.concurrent.locks.ReentrantLock</code>），属于 <strong>API 层面</strong>的实现。</li>
</ul>
<h3 id="锁的释放">锁的释放
</h3><p><strong><code>synchronized</code></strong>：</p>
<ul>
<li><strong>自动释放</strong>。代码执行完同步代码块，或者抛出异常时，JVM 会自动释放锁，不会导致死锁。</li>
</ul>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li><strong>手动释放</strong>。必须手动调用 <code>unlock()</code> 方法。</li>
</ul>
<h3 id="锁的公平性">锁的公平性
</h3><p><strong><code>synchronized</code></strong>：</p>
<ul>
<li>只能是<strong>非公平锁</strong>。线程获取锁的顺序是不确定的，可能发生“饥饿”现象。</li>
</ul>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li>
<p>默认是<strong>非公平锁</strong>（性能更好）。</p>
</li>
<li>
<p>可以通过构造函数 <code>new ReentrantLock(true)</code> 指定为<strong>公平锁</strong>（<strong>遵循先来后到原则</strong>），但性能会下降。</p>
</li>
</ul>
<h3 id="等待可中断">等待可中断
</h3><p><strong><code>synchronized</code></strong>：</p>
<ul>
<li><strong>不可中断</strong>。如果一个线程正在等待获取锁，它不能被中断（<code>interrupt</code>），只能一直阻塞等待。</li>
</ul>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li><strong>可中断</strong>。通过 <code>lockInterruptibly()</code> 方法，可以让正在等待锁的线程响应中断，放弃等待去处理其他事情。</li>
</ul>
<h3 id="尝试获取锁">尝试获取锁
</h3><p><strong><code>synchronized</code></strong>：</p>
<ul>
<li>不行。要么拿到锁，要么阻塞死等。</li>
</ul>
<p><strong><code>ReentrantLock</code></strong>：</p>
<ul>
<li>提供 <code>tryLock()</code> 方法。可以尝试获取锁，如果锁被占用，可以选择立即返回 <code>false</code> 或者等待一段指定的时间，非常灵活。</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>synchronized（隐式锁）</strong></th>
          <th><strong>ReentrantLock（显式锁）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>实现方式</strong></td>
          <td>关键字 (JVM 层面)</td>
          <td>类 (JDK API 层面)</td>
      </tr>
      <tr>
          <td><strong>锁的释放</strong></td>
          <td>隐式自动释放</td>
          <td>显式手动释放 (需在 finally 中 unlock)</td>
      </tr>
      <tr>
          <td><strong>公平性</strong></td>
          <td>非公平</td>
          <td>默认非公平，可设置为公平</td>
      </tr>
      <tr>
          <td><strong>响应中断</strong></td>
          <td>不支持</td>
          <td>支持 (<code>lockInterruptibly</code>)</td>
      </tr>
      <tr>
          <td><strong>条件队列</strong></td>
          <td>单个 (wait/notify)</td>
          <td>多个 (Condition)</td>
      </tr>
      <tr>
          <td><strong>尝试获取</strong></td>
          <td>不支持 (死等)</td>
          <td>支持 (<code>tryLock</code>)</td>
      </tr>
      <tr>
          <td><strong>灵活性</strong></td>
          <td>低</td>
          <td>高</td>
      </tr>
  </tbody>
</table></div>
<h2 id="锁升级">锁升级
</h2><h3 id="锁升级流程图解">锁升级流程图解
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>锁状态</strong></th>
          <th><strong>触发条件</strong></th>
          <th><strong>优点</strong></th>
          <th><strong>缺点</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>偏向锁</strong></td>
          <td>只有一个线程反复加锁</td>
          <td>加锁/解锁几乎零消耗</td>
          <td>如果存在线程竞争，撤销偏向锁会有额外开销</td>
      </tr>
      <tr>
          <td><strong>轻量级锁</strong></td>
          <td>线程交替执行，无同时竞争</td>
          <td>不会阻塞线程，利用 CAS 和自旋，响应速度快</td>
          <td>如果始终得不到锁，自旋会空耗 CPU</td>
      </tr>
      <tr>
          <td><strong>重量级锁</strong></td>
          <td>发生长时间或多线程同时竞争</td>
          <td>不会空耗 CPU，未获锁线程进入阻塞</td>
          <td>线程阻塞/唤醒涉及上下文切换，开销大，较慢</td>
      </tr>
  </tbody>
</table></div>
<h2 id="cas与自旋">CAS与自旋
</h2><h3 id="什么是cas乐观锁">什么是CAS（乐观锁）
</h3><ul>
<li>
<p>你看到原句是“Hello”（<strong>A</strong>）。</p>
</li>
<li>
<p>你想改成“Hi”（<strong>B</strong>）。</p>
</li>
<li>
<p>在你提交修改的一瞬间，系统检查文档当前还是不是“Hello”（<strong>V</strong>）。</p>
<ul>
<li>
<p>如果是，修改成功。</p>
</li>
<li>
<p>如果文档已经被别人改成了“Hello World”，你的预期（A）和实际（V）不符，提交失败，你需要重新读取再尝试。</p>
</li>
</ul>
</li>
</ul>
<h3 id="cas-的三大问题"><strong>CAS 的三大问题</strong>
</h3><ol>
<li>
<p><strong>ABA 问题</strong>（最著名的坑）：</p>
<ul>
<li>
<p>虽然 V 还是 A，但不代表它没变过。它可能经历了 <code>A -&gt; B -&gt; A</code> 的过程。</p>
</li>
<li>
<p><strong>比喻</strong>：桌上有一杯水（A），你离开了一会儿。回来时水还是满的（A），你以为没人动过。实际上可能有人喝光了（B），又给你倒满了（A）。虽然结果一样，但过程可能由于“杯子被用过”而产生副作用。</p>
</li>
<li>
<p><strong>解决</strong>：加<strong>版本号</strong>。变成 <code>1A -&gt; 2B -&gt; 3A</code>。Java 中的 <code>AtomicStampedReference</code> 就是干这个的。给提交结果加版本号</p>
</li>
</ul>
</li>
<li>
<p><strong>只能保证一个变量的原子性</strong>：无法同时操作多个变量。</p>
</li>
<li>
<p><strong>CPU 开销大</strong>：这通常与“自旋”结合在一起，见下文。</p>
</li>
</ol>
<h3 id="什么是-自旋-">什么是 自旋 ？
</h3><p><strong>自旋</strong>是一种线程等待的策略。</p>
<p>当线程抢不到锁（或 CAS 失败）时，它<strong>不放弃 CPU，不进入阻塞状态（不睡觉）</strong>，而是执行一个<strong>空循环</strong>（Loop），不断地检查“锁释放了吗？”或者“我能重试 CAS 了吗？”。</p>
<h4 id="为什么要自旋"><strong>为什么要自旋？</strong>
</h4><p>为了<strong>避免上下文切换</strong>的开销。</p>
<ul>
<li>
<p><strong>阻塞/唤醒</strong>：线程挂起和恢复需要操作系统介入，保存和恢复现场，非常耗时（可能比执行代码本身还慢）。</p>
</li>
<li>
<p><strong>自旋</strong>：如果锁被占用的时间很短，我在门口转两圈（自旋）锁就释放了，这样比“回家睡觉再被电话叫醒”快得多。</p>
</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>概念</strong></th>
          <th><strong>作用</strong></th>
          <th><strong>核心词</strong></th>
          <th><strong>优缺点</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>CAS</strong></td>
          <td>实现原子更新</td>
          <td><strong>比较并交换</strong></td>
          <td>优点：非阻塞，性能好<br>缺点：ABA 问题</td>
      </tr>
      <tr>
          <td><strong>自旋</strong></td>
          <td>等待锁的策略</td>
          <td><strong>循环重试</strong></td>
          <td>优点：避免上下文切换<br>缺点：耗费 CPU</td>
      </tr>
  </tbody>
</table></div>
<h2 id="springbean的生命周期">SpringBean的生命周期
</h2><h3 id="阶段一创建与注入-的基础">阶段一：创建与注入 (的基础)
</h3><h4 id="1-实例化-instantiation">1. 实例化 (Instantiation)
</h4><ul>
<li>
<p><strong>发生了什么：</strong> Spring 容器通过反射（<code>Constructor.newInstance()</code>）调用 Bean 的构造函数。</p>
</li>
<li>
<p><strong>状态：</strong> 此时对象已经在堆内存中存在了，但它只是一个“空壳子”，里面的属性（依赖）全是 <code>null</code>。</p>
</li>
<li>
<p><strong>类比：</strong> 刚买了一个毛坯房，房子建好了，但里面什么家具都没有。</p>
</li>
</ul>
<h4 id="2-属性赋值-populate-properties">2. 属性赋值 (Populate Properties)
</h4><ul>
<li>
<p><strong>发生了什么：</strong> Spring 依据配置（XML 或 <code>@Autowired</code>、<code>@Value</code>），将依赖的对象或属性值注入到 Bean 中。</p>
</li>
<li>
<p><strong>状态：</strong> 对象内部的依赖已经填充完毕。</p>
</li>
<li>
<p><strong>类比：</strong> 装修工进场，把沙发（Service）、电视（Dao）都搬进了房子里。</p>
</li>
</ul>
<h3 id="阶段二容器感知-aware-接口回调">阶段二：容器感知 (Aware 接口回调)
</h3><h4 id="3-aware-接口回调-invoke-aware-interfaces">3. Aware 接口回调 (Invoke Aware Interfaces)
</h4><ul>
<li><strong>发生了什么：</strong> 如果 Bean 实现了特定的 <code>Aware</code> 接口，Spring 会把容器内部的一些资源“告诉”这个 Bean。</li>
</ul>
<h3 id="阶段三初始化与增强-最关键的步骤">阶段三：初始化与增强 (最关键的步骤)
</h3><p>所谓的“初始化阶段”，就是 Spring 给你一个机会，在“属性都装好了”之后，但在“给别人使用”之前，让你执行一段自己的业务代码（比如连数据库、加载缓存、校验配置）。</p>
<p><strong>Spring AOP</strong>（默认机制）使用的是 <strong>动态代理（Dynamic Proxy）</strong>。它的逻辑是<strong>委托（Delegation）</strong>。</p>
<ul>
<li>
<p>原本的流程：</p>
<p>调用者 \rightarrow 目标对象（Target）</p>
</li>
<li>
<p>Spring AOP 的流程：</p>
<p>调用者 \rightarrow 代理对象（Proxy） \rightarrow 执行增强代码（Before） \rightarrow 调用目标对象 \rightarrow 执行增强代码（After） \rightarrow 返回</p>
</li>
</ul>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>Spring AOP</strong></th>
          <th><strong>AspectJ（静态代理）</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>原理</strong></td>
          <td><strong>动态代理</strong> (Proxy)</td>
          <td><strong>字节码织入</strong> (Bytecode Weaving)</td>
      </tr>
      <tr>
          <td><strong>修改方式</strong></td>
          <td>运行时生成新类包裹目标</td>
          <td>编译期/加载期直接修改目标类字节码</td>
      </tr>
      <tr>
          <td><strong>是否需要接口</strong></td>
          <td>JDK模式需要，CGLIB不需要</td>
          <td>不需要</td>
      </tr>
      <tr>
          <td><strong>性能</strong></td>
          <td>稍慢（有反射和代理调用的开销）</td>
          <td><strong>极快</strong>（就是普通的方法调用）</td>
      </tr>
      <tr>
          <td><strong>能力范围</strong></td>
          <td>只能拦截 <strong>public 方法</strong> 的调用</td>
          <td><strong>无所不能</strong>：可拦截 private 方法、静态方法、构造函数、字段访问等</td>
      </tr>
      <tr>
          <td><strong>内部调用(this)</strong></td>
          <td><strong>失效</strong></td>
          <td><strong>有效</strong> (完美解决自调用问题)</td>
      </tr>
      <tr>
          <td><strong>复杂度</strong></td>
          <td>低（Spring Boot 开箱即用）</td>
          <td>高（需要配置编译器或 JVM Agent）</td>
      </tr>
  </tbody>
</table></div>
<h2 id="redis和memcached的区别">Redis和Memcached的区别
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>Memcached</strong></th>
          <th><strong>Redis</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数据结构</strong></td>
          <td><strong>单一</strong> (仅支持 String/二进制块)</td>
          <td><strong>丰富</strong> (String, List, Hash, Set, ZSet, Bitmap, HyperLogLog, Stream, Geo)</td>
      </tr>
      <tr>
          <td><strong>线程模型</strong></td>
          <td><strong>多线程</strong> (Multi-threaded)</td>
          <td><strong>单线程</strong> (主逻辑) + I/O 多线程 (Redis 6.0+)</td>
      </tr>
      <tr>
          <td><strong>持久化</strong></td>
          <td><strong>不支持</strong> (重启后数据丢失)</td>
          <td><strong>支持</strong> (RDB 快照 &amp; AOF 日志)</td>
      </tr>
      <tr>
          <td><strong>分布式支持</strong></td>
          <td><strong>客户端实现</strong> (服务端互不通信)</td>
          <td><strong>服务端支持</strong> (Redis Cluster, Sentinel)</td>
      </tr>
      <tr>
          <td><strong>内存管理</strong></td>
          <td><strong>Slab Allocation</strong> (预分配，无碎片，但在非均匀大小数据下有浪费)</td>
          <td><strong>jemalloc/libc</strong> (按需分配，利用率高，但可能有内存碎片)</td>
      </tr>
      <tr>
          <td><strong>功能丰富度</strong></td>
          <td>仅缓存</td>
          <td>Lua 脚本、发布/订阅 (Pub/Sub)、事务、Pipeline</td>
      </tr>
      <tr>
          <td><strong>最大值限制</strong></td>
          <td>Value 最大 <strong>1MB</strong></td>
          <td>Value 最大 <strong>512MB</strong></td>
      </tr>
  </tbody>
</table></div>
<h3 id="a-数据类型-data-types--最大的区别">A. 数据类型 (Data Types) —— 最大的区别
</h3><ul>
<li>
<p><strong>Memcached:</strong> 就像一个巨大的 <code>Map&lt;String, String&gt;</code>。如果你想存一个列表，必须先把列表序列化成 JSON 字符串存进去；取出来时，必须把整个字符串取出来反序列化，修改后再序列化存回去。<strong>这非常消耗网络带宽和 CPU。</strong></p>
</li>
<li>
<p><strong>Redis:</strong> 就像一个瑞士军刀。你可以直接在服务端操作数据结构。</p>
<ul>
<li>
<p><em>例子：</em> 你想给一个排行榜加分。</p>
</li>
<li>
<p><strong>Redis:</strong> <code>ZINCRBY rank_list 10 &quot;user_id&quot;</code> (直接在内存里改数值，极快)。</p>
</li>
<li>
<p><strong>Memcached:</strong> <code>get</code> -&gt; 反序列化 -&gt; <code>value + 10</code> -&gt; 序列化 -&gt; <code>set</code> (并发下还需要加锁，否则数据不一致)。</p>
</li>
</ul>
</li>
</ul>
<h3 id="b-线程模型-threading-model--性能的分水岭">B. 线程模型 (Threading Model) —— 性能的分水岭
</h3><ul>
<li>
<p><strong>Redis (单线程为主):</strong></p>
<ul>
<li>
<p>Redis 的核心操作（执行命令）是单线程的。</p>
</li>
<li>
<p><strong>优势：</strong> 没有线程切换开销，没有锁竞争（Lock-free），代码简单稳定。</p>
</li>
<li>
<p><strong>劣势：</strong> 无法利用多核 CPU 的优势（但在 6.0 版本引入了多线程 I/O 来处理网络读写，核心计算依然是单线程）。</p>
</li>
</ul>
</li>
<li>
<p><strong>Memcached (多线程):</strong></p>
<ul>
<li>
<p>它使用主线程监听端口，Worker 线程处理读写。</p>
</li>
<li>
<p><strong>优势：</strong> 可以轻松利用 64 核 CPU 的计算能力，在<strong>极高并发</strong>（数十万 QPS 以上）且 <strong>Value 很小</strong> 的场景下，吞吐量可能高于 Redis。</p>
</li>
</ul>
</li>
</ul>
<h3 id="c-持久化-persistence--数据安全性">C. 持久化 (Persistence) —— 数据安全性
</h3><ul>
<li>
<p><strong>Memcached:</strong> 把它当作一个<strong>易失性</strong>缓存。如果服务器断电或重启，所有缓存数据瞬间清空，数据库会瞬间面临巨大的“缓存击穿”压力。</p>
</li>
<li>
<p><strong>Redis:</strong> 支持持久化。</p>
<ul>
<li>
<p><strong>RDB:</strong> 定期生成快照保存在磁盘。</p>
</li>
<li>
<p><strong>AOF:</strong> 记录每一条写命令。</p>
</li>
<li>
<p><strong>用途：</strong> 重启后可以自动恢复数据，甚至可以用来做主数据库使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="d-分布式集群-clustering">D. 分布式/集群 (Clustering)
</h3><ul>
<li>
<p><strong>Memcached:</strong> 服务端是“傻瓜式”的，节点之间互不通信。分布式的逻辑完全由<strong>客户端</strong>（Client）控制（通常使用<strong>一致性哈希</strong>算法）。如果你加一台服务器，客户端需要重新计算哈希。</p>
</li>
<li>
<p><strong>Redis:</strong> 支持原生的 <strong>Redis Cluster</strong>。服务端之间会通信（Gossip 协议），支持自动分片、故障转移（Failover）。</p>
</li>
</ul>
<h2 id="内核内存-vs-用户内存-the-two-worlds">内核内存 vs. 用户内存 (The Two Worlds)
</h2><p>操作系统（如 Linux）为了安全和稳定，把内存划分成了两个隔离的区域：</p>
<h4 id="1-内核内存-kernel-memory--kernel-space">1. 内核内存 (Kernel Memory / Kernel Space)
</h4><ul>
<li>
<p><strong>权限：</strong> <strong>最高权限 (Ring 0)</strong>。CPU 可以执行任何指令，访问任何硬件地址。</p>
</li>
<li>
<p><strong>居住者：</strong> 操作系统内核代码、驱动程序（网卡驱动）、硬件缓冲区。</p>
</li>
<li>
<p><strong>特点：</strong> 如果这块区域的代码崩溃了，整个操作系统就蓝屏或死机了。它是神圣不可侵犯的。</p>
</li>
</ul>
<h4 id="2-用户内存-user-memory--user-space">2. 用户内存 (User Memory / User Space)
</h4><ul>
<li>
<p><strong>权限：</strong> <strong>受限权限 (Ring 3)</strong>。只能访问自己的内存空间，<strong>严禁直接访问硬件</strong>（不能直接读写网卡、硬盘）。</p>
</li>
<li>
<p><strong>居住者：</strong> 你运行的应用程序（Redis, Java JVM, 浏览器, QQ）。</p>
</li>
<li>
<p><strong>特点：</strong> 如果你的 Redis 崩了，只是这一个进程死掉，操作系统照样运行。</p>
</li>
</ul>
<blockquote>
<p><strong>核心矛盾：</strong> 网卡收到的数据首先必须存放在<strong>内核内存</strong>（因为它是由驱动程序管理的）。但是，你的 Redis 运行在<strong>用户内存</strong>。</p>
<p><strong>代价：</strong> 数据必须从“内核态”<strong>拷贝 (Copy)</strong> 到“用户态”，应用程序才能处理。这就是 Redis 6.0 引入多线程 I/O 想要优化的那个“搬运”过程。###</p>
</blockquote>
<h3 id="socket-是什么-the-abstraction">Socket 是什么？ (The Abstraction)
</h3><p>很多初学者认为 Socket 就是“插座”或者“连接”。在操作系统层面，<strong>Socket 本质上是内核内存中的两个缓冲区（Buffer）</strong>。</p>
<p>当你创建一个 Socket（比如 Java 的 <code>new Socket()</code> 或 Redis 监听的端口），内核会在<strong>内核内存</strong>里为你申请两块地：</p>
<ol>
<li>
<p><strong>接收缓冲区 (Recv Buffer):</strong> 存放网卡发过来、等待你读取的数据。</p>
</li>
<li>
<p><strong>发送缓冲区 (Send Buffer):</strong> 存放你写进去、等待网卡发送的数据。</p>
</li>
</ol>
<p>Socket 就是应用程序（用户态）和网络协议栈（内核态）交互的<strong>句柄 (File Descriptor)</strong>。</p>
<h2 id="redis数据的全生命周期流程">Redis数据的全生命周期流程
</h2><p>假设外网发来一个 TCP 包给 Redis（端口 6379），流程如下：</p>
<h3 id="1-物理层网卡收货-nic">1. 物理层：网卡收货 (NIC)
</h3><ul>
<li>
<p>网线传来电信号，网卡将其转换为二进制数据。</p>
</li>
<li>
<p><strong>DMA (Direct Memory Access):</strong> 网卡不经过 CPU，直接利用 DMA 技术，把数据包写入到 <strong>内核内存</strong> 中的一块公用区域（通常叫 <strong>Ring Buffer</strong>）。</p>
</li>
<li>
<p><em>此时，数据在内核，但还不知道属于哪个 Socket。</em></p>
</li>
</ul>
<h3 id="2-链路层--网络层内核协议栈介入">2. 链路层 &amp; 网络层：内核协议栈介入
</h3><ul>
<li>
<p>网卡给 CPU 发送<strong>中断 (Interrupt)</strong>。</p>
</li>
<li>
<p>CPU 停下手中的活，运行网卡驱动程序。</p>
</li>
<li>
<p>驱动程序把数据包包装成内核的数据结构（Linux 下叫 <code>sk_buff</code>）。</p>
</li>
<li>
<p>操作系统检查 IP 头：是发给本机的吗？是的。</p>
</li>
</ul>
<h3 id="3-传输层分发给-socket-demultiplexing">3. 传输层：分发给 Socket (Demultiplexing)
</h3><ul>
<li>
<p>操作系统检查 TCP 头：<strong>目标端口是 6379</strong>。</p>
</li>
<li>
<p>内核查找：“哪个 Socket 正在监听 6379 端口？” -&gt; 找到了 Redis 的那个 Socket。</p>
</li>
<li>
<p><strong>关键动作：</strong> 内核把这个数据包（<code>sk_buff</code>）挂到该 <strong>Socket 的接收缓冲区 (Recv Buffer)</strong> 队列的尾部。</p>
</li>
<li>
<p><em>此时，数据依然在内核内存中，但已经归属到了特定的 Socket 名下。</em></p>
</li>
</ul>
<h3 id="4-应用层数据搬运-copy-to-user">4. 应用层：数据搬运 (Copy to User)
</h3><ul>
<li>
<p>Redis 主线程（或 I/O 线程）调用系统函数 <code>read(socket_fd)</code>。</p>
</li>
<li>
<p><strong>CPU 发生上下文切换：</strong> 从用户态切入内核态。</p>
</li>
<li>
<p><strong>内存拷贝：</strong> CPU 把数据从 <strong>内核内存（Socket 的接收缓冲区）</strong> 复制到 <strong>用户内存（Redis 定义的 buffer）</strong>。</p>
</li>
<li>
<p>Redis 终于拿到了数据，开始解析处理 <code>set name ...</code>。</p>
</li>
</ul>
<h2 id="那-redis-60-的-io-线程到底解决了什么">那 Redis 6.0 的 I/O 线程到底解决了什么？
</h2><p>既然都要经过内核拷贝，那用主线程调 <code>write</code> 和用 I/O 线程调 <code>write</code> 有什么区别？</p>
<p><strong>区别在于“谁在等”和“谁在分担开销”。</strong></p>
<h3 id="场景如果你只有主线程redis--60">场景：如果你只有主线程（Redis &lt; 6.0）
</h3><ul>
<li>
<p>主线程：“我要处理 10,000 个客户端的 <code>get</code> 请求。”</p>
</li>
<li>
<p>对于每一个请求，主线程都要亲自调用 <code>write</code>。</p>
</li>
<li>
<p>每次 <code>write</code>，主线程都要经历：<strong>用户态-&gt;内核态切换 (耗时) + CPU 搬运数据 (耗时) + 内核态-&gt;用户态切换 (耗时)</strong>。</p>
</li>
<li>
<p><strong>结果：</strong> 主线程大量时间花在和内核打交道、等待搬运上，导致它处理命令（KV 读写）的时间变少了。</p>
</li>
</ul>
<h3 id="场景你有-io-线程redis-60">场景：你有 I/O 线程（Redis 6.0+）
</h3><ul>
<li>
<p>主线程：“我要处理 10,000 个请求。算出结果后，我不亲自发了。”</p>
</li>
<li>
<p>主线程把结果扔给 4 个 <strong>I/O 线程</strong>，说：“你们去调 <code>write</code> 发给客户。”</p>
</li>
<li>
<p>主线程<strong>立刻</strong>转头去处理下一个命令的计算（KV 读写）。</p>
</li>
<li>
<p><strong>I/O 线程们</strong> 并行地去调用 <code>write</code>，去承担上下文切换和 CPU 搬运数据的开销。</p>
</li>
<li>
<p><strong>结果：</strong> 主线程被解放了，只专注于纯内存计算，吞吐量大增。</p>
</li>
</ul>
<h2 id="内核线程内核级线程用户级线程">内核线程，内核级线程，用户级线程
</h2><h3 id="用户级线程是怎么骗过内核的mn-模型">用户级线程是怎么“骗”过内核的？（M:N 模型）
</h3><p>用户级线程通过一个**中间层（Runtime/Scheduler）**来实现。</p>
<ul>
<li>
<p><strong>M 个用户级线程</strong>（比如 1000 个 Goroutine）。</p>
</li>
<li>
<p><strong>N 个内核级线程</strong>（通常等于 CPU 核数，比如 8 个）。</p>
</li>
<li>
<p><strong>映射关系：</strong></p>
<ul>
<li>
<p>这 8 个内核线程是“干活的苦力”。</p>
</li>
<li>
<p>这 1000 个协程是“待办的任务”。</p>
</li>
<li>
<p>Go 语言的运行时（Runtime）负责把这 1000 个任务，源源不断地塞给这 8 个苦力去做。</p>
</li>
<li>
<p>如果一个任务（协程）卡在 I/O 上了，Runtime 把它拿开，换一个新任务给苦力，<strong>苦力（内核线程）永远不休息，也永远不阻塞</strong>。</p>
</li>
</ul>
</li>
</ul>
<p>我们可以把计算机系统看作一家<strong>大型工厂</strong>（操作系统）：</p>
<ol>
<li>
<p><strong>内核线程 (Kernel Thread):</strong> 工厂的<strong>内部设施维护人员</strong>（只在核心区工作，不生产对外产品）。</p>
</li>
<li>
<p><strong>内核级线程 (Kernel-Level Thread, KLT):</strong> 工厂正式聘用的<strong>流水线工人</strong>（有工牌，受人事部直接管理）。</p>
</li>
<li>
<p><strong>用户级线程 (User-Level Thread, ULT):</strong> 包工头带来的<strong>临时工/外包团队</strong>（人事部不知道他们的存在，只知道包工头）。</p>
</li>
</ol>
<h3 id="一-详细拆解三者的定义与区别">一、 详细拆解：三者的定义与区别
</h3><h4 id="1-内核线程-kernel-thread--kthread">1. 内核线程 (Kernel Thread / kthread)
</h4><p>这是最底层的存在，它们完全运行在<strong>内核空间（Ring 0）</strong>。</p>
<ul>
<li>
<p><strong>定义：</strong> 它是操作系统内核用来执行后台任务的线程。它<strong>没有</strong>用户地址空间（不映射用户内存），只能访问内核代码和数据。</p>
</li>
<li>
<p><strong>谁创建/管理：</strong> 操作系统内核。</p>
</li>
<li>
<p><strong>能干啥：</strong></p>
<ul>
<li>
<p>将内存中的脏页刷写到磁盘（如 Linux 的 <code>kflush</code> 或 <code>pdflush</code>）。</p>
</li>
<li>
<p>处理软中断和网络包（如 <code>ksoftirqd</code>）。</p>
</li>
<li>
<p>执行磁盘 I/O 调度。</p>
</li>
</ul>
</li>
<li>
<p><strong>特点：</strong> 也就是我们常说的“纯内核线程”。你在 Linux 用 <code>ps -ef</code> 看到的那些名字带中括号 <code>[kthreadd]</code>、<code>[migration]</code> 的进程，就是它们。</p>
</li>
<li>
<p><strong>与用户程序的关系：</strong> <strong>完全没关系</strong>。它们不运行你的 Java 或 Redis 代码，它们只服务于 OS 本身。</p>
</li>
</ul>
<h4 id="2-内核级线程-kernel-level-thread-klt">2. 内核级线程 (Kernel-Level Thread, KLT)
</h4><p><strong>这是我们日常开发中最常接触的概念（虽然你可能没意识到）。</strong> 在 Linux 中，它们通常被称为 <strong>轻量级进程 (LWP, Light Weight Process)</strong>。</p>
<ul>
<li>
<p><strong>定义：</strong> 这是一个由内核管理、但用于执行用户态代码的执行实体。它是**“用户进程”在内核眼里的分身**。</p>
</li>
<li>
<p><strong>谁创建/管理：</strong> 操作系统内核调度器（如 CFS）。</p>
</li>
<li>
<p><strong>能干啥：</strong> 执行你的 <code>main()</code> 函数，执行 Redis 的主逻辑，执行 Java 的线程。</p>
</li>
<li>
<p><strong>特点：</strong></p>
<ul>
<li>
<p><strong>拥有双重身份：</strong> 既有内核栈（陷入内核时用），也有用户栈（运行程序时用）。</p>
</li>
<li>
<p><strong>可被独立调度：</strong> 操作系统知道它的存在，可以将它分配给任意 CPU 核心。</p>
</li>
<li>
<p><strong>高开销：</strong> 创建、销毁、切换都需要系统调用，涉及内核态/用户态切换，成本较高（微秒级）。</p>
</li>
</ul>
</li>
<li>
<p><strong>代表：</strong> Java 的 <code>java.lang.Thread</code> (在 Linux 上)，C++ 的 <code>std::thread</code>，Redis 的主线程和 I/O 线程。</p>
</li>
</ul>
<h4 id="3-用户级线程-user-level-thread-ult">3. 用户级线程 (User-Level Thread, ULT)
</h4><p>也叫协程、纤程、Green Thread。</p>
<ul>
<li>
<p><strong>定义：</strong> 完全在<strong>用户空间</strong>实现的线程机制。内核完全不知道它们的存在，内核只看到承载它们的那个 KLT。</p>
</li>
<li>
<p><strong>谁创建/管理：</strong> 编程语言的运行时（Runtime）或库（如 Go Runtime, JVM）。</p>
</li>
<li>
<p><strong>能干啥：</strong> 处理高并发逻辑，阻塞式写法的异步执行。</p>
</li>
<li>
<p><strong>特点：</strong></p>
<ul>
<li>
<p><strong>极轻量：</strong> 切换只涉及寄存器保存，无需陷入内核，纳秒级。</p>
</li>
<li>
<p><strong>不可独立调度：</strong> 操作系统无法直接把一个 ULT 分配给 CPU，必须依附于一个 KLT 才能运行。</p>
</li>
</ul>
</li>
<li>
<p><strong>代表：</strong> Go 的 Goroutine, Python 的 Gevent, Java 21 的 Virtual Thread。</p>
</li>
</ul>
<h3 id="二-它们之间的映射模型-the-mapping-models">二、 它们之间的映射模型 (The Mapping Models)
</h3><p>弄清楚关系的关键，在于理解<strong>用户级线程 (ULT)</strong> 和 <strong>内核级线程 (KLT)</strong> 是如何搭配工作的。这主要有三种模型：</p>
<h4 id="1-多对一模型-m--1--上古时代的产物">1. 多对一模型 (M : 1) —— 上古时代的产物
</h4><ul>
<li>
<p><strong>描述：</strong> 多个用户级线程（M）跑在 1 个内核级线程（1）上。</p>
</li>
<li>
<p><strong>例子：</strong> 老版本的 Python 异步库，某些老旧的 JVM 实现（Green Threads）。</p>
</li>
<li>
<p><strong>缺点：</strong> <strong>没有并行能力</strong>。因为底层只有一个 KLT，所以一次只能用 1 个 CPU 核。如果其中一个 ULT 阻塞了（比如发起系统调用），底层的 KLT 就阻塞了，其他所有 M 个 ULT 全都卡死。</p>
</li>
</ul>
<h4 id="2-一对一模型-1--1--现代主流-redis-nginx-java">2. 一对一模型 (1 : 1) —— 现代主流 (Redis, Nginx, Java)
</h4><ul>
<li>
<p><strong>描述：</strong> 1 个用户级线程（逻辑上的线程）直接对应 1 个内核级线程。</p>
</li>
<li>
<p><strong>机制：</strong> 当你在 Java 里 <code>new Thread()</code>，操作系统就在底层真的创建一个 KLT（LWP）。</p>
</li>
<li>
<p><strong>优点：</strong> 真正的并行。一个线程阻塞，不影响其他线程。实现简单，直接依赖 OS 调度。</p>
</li>
<li>
<p><strong>缺点：</strong> 线程太贵，开不了一百万个。</p>
</li>
<li>
<p><strong>现状：</strong> <strong>Redis 的主线程和 I/O 线程，Java 目前默认的线程模型，都是 1:1。</strong> 所谓的“用户线程”此时只是 KLT 的一个句柄。</p>
</li>
</ul>
<h4 id="3-多对多模型-m--n--高并发的未来-gojava21-virtual-threads">3. 多对多模型 (M : N) —— 高并发的未来 (Go,Java21 Virtual Threads)
</h4><ul>
<li>
<p><strong>描述：</strong> M 个用户级线程（协程）动态映射到 N 个内核级线程上。</p>
</li>
<li>
<p><strong>机制：</strong></p>
<ul>
<li>
<p>Runtime 维护一个线程池（N 个 KLT）。</p>
</li>
<li>
<p>Runtime 维护一个任务队列（M 个 ULT）。</p>
</li>
<li>
<p>Runtime 负责把 ULT 喂给 KLT 执行。如果一个 ULT 阻塞了，Runtime 把它拿下来，换另一个 ULT 上去。</p>
</li>
</ul>
</li>
<li>
<p><strong>优点：</strong> 既有 ULT 的轻量（可以开百万个），又有 KLT 的并行（利用多核 CPU）。</p>
</li>
<li>
<p><strong>现状：</strong> Go 语言之所以火，就是因为它的调度器（G-M-P 模型）把这个做到了极致。</p>
</li>
</ul>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251123135651_394_16.jpg"
	width="1706"
	height="1279"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251123135651_394_16_hu_fc5e194ce345a3a1.jpg 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20251123135651_394_16_hu_aa473b130ca732d9.jpg 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="133"
		data-flex-basis="320px"
	
></p>
<hr>
<h3 id="三-总结与对比表">三、 总结与对比表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>内核线程 (Kernel Thread)</strong></th>
          <th><strong>内核级线程 (KLT / LWP)</strong></th>
          <th><strong>用户级线程 (ULT / Coroutine)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>可见性</strong></td>
          <td>仅内核可见</td>
          <td>内核可见，用户可见</td>
          <td>仅用户程序可见 (内核不可见)</td>
      </tr>
      <tr>
          <td><strong>内存空间</strong></td>
          <td>仅内核空间</td>
          <td>用户空间 + 内核空间</td>
          <td>仅用户空间</td>
      </tr>
      <tr>
          <td><strong>调度者</strong></td>
          <td>OS 调度器</td>
          <td>OS 调度器</td>
          <td>语言运行时 (Runtime)</td>
      </tr>
      <tr>
          <td><strong>切换开销</strong></td>
          <td>小 (无需切换地址空间)</td>
          <td>中 (需切入内核态)</td>
          <td>极小 (纯用户态操作)</td>
      </tr>
      <tr>
          <td><strong>并行性</strong></td>
          <td>利用多核</td>
          <td>利用多核</td>
          <td>依赖于底层的 KLT</td>
      </tr>
      <tr>
          <td><strong>阻塞影响</strong></td>
          <td>-</td>
          <td>线程阻塞，释放 CPU 给别人</td>
          <td>协程阻塞，Runtime 切换其他协程</td>
      </tr>
      <tr>
          <td><strong>典型例子</strong></td>
          <td><code>ksoftirqd</code>, <code>kworker</code></td>
          <td><code>java.lang.Thread</code>, Redis 线程</td>
          <td>Go Goroutine, Java Virtual Thread</td>
      </tr>
  </tbody>
</table></div>
<h2 id="一般什么情况下需要陷入内核态">一般什么情况下需要陷入内核态？
</h2><p>简单来说，<strong>“陷入内核态”（Trap into Kernel Mode）</strong> 也就是 CPU 从 <strong>特权级 3 (User Ring 3)</strong> 切换到 <strong>特权级 0 (Kernel Ring 0)</strong> 的过程。</p>
<p>一般情况下，陷入内核态主要有且仅有三种场景：</p>
<hr>
<h3 id="1-系统调用-system-call--主动请求">1. 系统调用 (System Call) —— 主动请求
</h3><p>这是最常见的情况。当你的程序需要做一些<strong>自己权限不够</strong>的事情时，必须主动向操作系统“打报告”。</p>
<p>因为用户程序不能直接操作硬件（硬盘、网卡、声卡）或管理内存，必须通过特定的接口（System Call Interface）请求内核代劳。</p>
<ul>
<li>
<p><strong>硬件 I/O 操作：</strong></p>
<ul>
<li>
<p><strong>读写文件：</strong> <code>read()</code>, <code>write()</code>, <code>open()</code>（Redis 写日志、读数据库）。</p>
</li>
<li>
<p><strong>网络通信：</strong> <code>socket()</code>, <code>connect()</code>, <code>send()</code>, <code>recv()</code>（Redis 处理请求）。</p>
</li>
<li>
<p><strong>屏幕输出：</strong> <code>printf()</code>（底层调用 <code>write</code> 输出到标准输出）。</p>
</li>
</ul>
</li>
<li>
<p><strong>进程控制：</strong></p>
<ul>
<li>
<p><strong>创建进程：</strong> <code>fork()</code>, <code>exec()</code>（Redis 做 RDB 快照时会 fork 子进程）。</p>
</li>
<li>
<p><strong>退出程序：</strong> <code>exit()</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>内存管理：</strong></p>
<ul>
<li><strong>申请内存：</strong> <code>malloc()</code> 在堆内存不够时，底层会调用 <code>brk()</code> 或 <code>mmap()</code> 向内核要内存。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>比喻：</strong> 你要去银行取钱（操作硬件资源），你不能自己冲进金库拿，必须填单子（系统调用），交给柜员（内核），柜员帮你拿出来给你。</p>
</blockquote>
<hr>
<h3 id="2-异常-exception--内部错误或特殊事件">2. 异常 (Exception) —— 内部错误或特殊事件
</h3><p>这是由 CPU 在执行指令时，<strong>内部</strong>检测到的意外情况。程序“闯祸了”或者遇到了“特殊指令”。</p>
<ul>
<li>
<p><strong>缺页异常 (Page Fault)：</strong></p>
<ul>
<li>当你访问一块内存地址，CPU 发现这块数据不在物理内存里（可能被换到了磁盘 swap 分区，或者刚申请还没分配物理页），CPU 会暂停程序，陷入内核。内核负责把数据从磁盘加载到内存，然后恢复程序运行。</li>
</ul>
</li>
<li>
<p><strong>程序错误：</strong></p>
<ul>
<li>
<p><strong>除以零：</strong> 代码里写了 <code>100 / 0</code>。</p>
</li>
<li>
<p><strong>非法内存访问 (Segfault)：</strong> 试图访问不属于你的内存地址（比如空指针解引用）。</p>
</li>
<li>
<p>内核捕获这些错误后，通常会杀死进程（就是你看到的 <code>Segmentation fault</code>）。</p>
</li>
</ul>
</li>
<li>
<p><strong>调试断点：</strong></p>
<ul>
<li>当你用 GDB 调试代码打断点时，实际上是插入了一条特殊指令（如 x86 的 <code>INT 3</code>）。CPU 执行到这里会自动陷入内核，暂停程序，把控制权交给调试器。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>比喻：</strong> 你在家里（用户态）做饭，突然锅炸了（除以零）或者你想进邻居家里（非法内存访问），这时候警察（内核）会立刻破门而入处理状况。</p>
</blockquote>
<hr>
<h3 id="3-硬件中断-hardware-interrupt--被动打断">3. 硬件中断 (Hardware Interrupt) —— 被动打断
</h3><p>这是来自 CPU <strong>外部</strong>的信号。无论你的程序正在干什么，只要硬件中断来了，CPU 必须无条件停下手头的工作，切到内核态去处理中断。</p>
<ul>
<li>
<p><strong>时钟中断 (Clock Interrupt)：</strong></p>
<ul>
<li>
<p><strong>最重要！</strong> 这是多任务操作系统的基石。</p>
</li>
<li>
<p>硬件时钟每隔几毫秒就会发一次中断。内核收到中断后，会看：“Redis，你的时间片用完了，该让给 Nginx 跑一会儿了。”</p>
</li>
<li>
<p>这就是为什么死循环的程序不会把电脑彻底卡死，因为内核会强行通过时钟中断夺回控制权。</p>
</li>
</ul>
</li>
<li>
<p><strong>I/O 完成中断：</strong></p>
<ul>
<li>
<p><strong>网卡：</strong> “新数据包到了！”（内核把数据拷贝到 Socket 缓冲区）。</p>
</li>
<li>
<p><strong>硬盘：</strong> “刚才你要读的数据我已经读完放到内存了！”</p>
</li>
</ul>
</li>
<li>
<p><strong>键盘/鼠标输入：</strong></p>
<ul>
<li>你按下一个键，键盘控制器发送中断，CPU 陷入内核读取按键码。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>比喻：</strong> 你正在家里专心打游戏（用户态运行代码），突然快递员狂按门铃（网卡中断），或者你的闹钟响了（时钟中断），你必须停下游戏去开门或者关闹钟（陷入内核处理）。</p>
</blockquote>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>触发方式</strong></th>
          <th><strong>来源</strong></th>
          <th><strong>例子</strong></th>
          <th><strong>主动/被动</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>系统调用</strong></td>
          <td>程序代码</td>
          <td><code>read()</code>, <code>fork()</code>, <code>sleep()</code></td>
          <td><strong>主动</strong> (程序自己写的)</td>
      </tr>
      <tr>
          <td><strong>异常</strong></td>
          <td>CPU 内部</td>
          <td>缺页、除零、Segfault</td>
          <td><strong>被动</strong> (通常是闯祸了)</td>
      </tr>
      <tr>
          <td><strong>硬件中断</strong></td>
          <td>CPU 外部</td>
          <td>网卡收包、时钟滴答、键盘</td>
          <td><strong>被动</strong> (外部环境强制)</td>
      </tr>
  </tbody>
</table></div>
<h2 id="redis单线程避免上下文切换的开销">Redis单线程避免上下文切换的开销
</h2><h3 id="1-什么是昂贵的上下文切换">1. 什么是“昂贵”的上下文切换？
</h3><p>首先，我们要明确，为什么切换线程很贵？</p>
<p>当 CPU 从 线程 A 切换到 线程 B 时，不仅仅是“换个人干活”这么简单，它涉及两个巨大的成本：</p>
<ol>
<li>
<p><strong>直接成本 (CPU 寄存器重置)：</strong></p>
<ul>
<li>
<p>CPU 需要把线程 A 的“现场”（程序计数器 PC、堆栈指针 SP、通用寄存器等）保存到内存里。</p>
</li>
<li>
<p>然后从内存里把线程 B 的“现场”恢复到寄存器里。</p>
</li>
<li>
<p>这本身需要花费几微秒 ($\mu s$)。</p>
</li>
</ul>
</li>
<li>
<p><strong>间接成本 (Cache 失效 —— 这才是真正的杀手)：</strong></p>
<ul>
<li>
<p>CPU 有 L1/L2/L3 高速缓存。线程 A 跑得正欢的时候，缓存Cache里全是线程 A 需要的数据（热数据）。</p>
</li>
<li>
<p>突然切到线程 B，线程 B 要用的数据不在缓存里（Cache Miss）。</p>
</li>
<li>
<p>CPU 被迫去慢如蜗牛的内存（RAM）里拿数据。</p>
</li>
<li>
<p><strong>这会导致 CPU 的执行效率瞬间暴跌。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-多线程模式的痛点-the-context-switch-storm">2. 多线程模式的痛点 (The &ldquo;Context Switch Storm&rdquo;)
</h3><p>假设 Redis 是传统的多线程模型（比如像早期的 Tomcat 或 MySQL）：</p>
<ul>
<li>
<p><strong>场景：</strong> 来了 1000 个请求。</p>
</li>
<li>
<p><strong>处理：</strong> 系统开启 1000 个线程（或者用线程池）。</p>
</li>
<li>
<p><strong>锁竞争：</strong> 线程 A 要修改 Key &ldquo;user:1&rdquo;，线程 B 也要修改。线程 B 抢不到锁，被迫<strong>挂起 (Block)</strong>。</p>
</li>
<li>
<p><strong>自愿切换 (Voluntary Context Switch)：</strong></p>
<ul>
<li>
<p>因为抢不到锁，或者等待磁盘 I/O，线程 B 主动告诉操作系统：“我干不下去了，把 CPU 让给别人吧。”</p>
</li>
<li>
<p>操作系统进行上下文切换。</p>
</li>
</ul>
</li>
<li>
<p><strong>结果：</strong> 在高并发下，CPU 把大量的时间花在** “保存现场、恢复现场、调度线程、等待锁” **上，真正用来执行 <code>set name gemini</code> 这行代码的时间反而被挤压了。</p>
</li>
</ul>
<h3 id="3-redis-的单线程魔法-the-run-to-completion">3. Redis 的单线程魔法 (The &ldquo;Run-to-Completion&rdquo;)
</h3><p>Redis 的主处理逻辑（Command Execution）是单线程的，这意味着：</p>
<h4 id="a-彻底消灭锁竞争">A. 彻底消灭“锁竞争”
</h4><ul>
<li>
<p>因为只有我一个人（主线程）在动数据，<strong>所以我根本不需要锁（Lock-free）</strong>。</p>
</li>
<li>
<p>没有锁，就不会出现“因为抢不到锁而挂起”的情况。</p>
</li>
<li>
<p>不存在“挂起”，就没有“自愿上下文切换”。</p>
</li>
<li>
<p><strong>结果：</strong> Redis 主线程是一路狂奔的，它处理完一个请求，马上处理下一个，中间没有任何停顿。</p>
</li>
</ul>
<h4 id="b-极致的-cache-亲和性-cache-affinity">B. 极致的 Cache 亲和性 (Cache Affinity)
</h4><ul>
<li>
<p>因为始终是这同一个线程在这一颗 CPU 核心上跑。</p>
</li>
<li>
<p>Redis 的核心数据结构（dict, ziplist, skiplist）和代码指令，会一直停留在 CPU 的 L1/L2 缓存里。</p>
</li>
<li>
<p><strong>Cache Hit 率极高</strong>。</p>
</li>
<li>
<p>这就像一个熟练工人在自己的工位上干活，所有工具都在手边（L1 Cache），闭着眼睛都能拿到。</p>
</li>
</ul>
<h4 id="c-io-多路复用-epoll--避免-io-阻塞">C. I/O 多路复用 (Epoll) —— 避免 I/O 阻塞
</h4><ul>
<li>
<p>你可能会问：<em>“那如果读 Socket 数据的时候，数据还没来怎么办？线程不就阻塞了吗？”</em></p>
</li>
<li>
<p>Redis 使用 <strong>epoll (Linux)</strong>。</p>
</li>
<li>
<p><strong>机制：</strong> Redis 告诉内核：“这一万个 Socket 你帮我盯着，谁有数据来了你告诉我。”</p>
</li>
<li>
<p><strong>非阻塞：</strong> Redis 主线程<strong>永远不会</strong>在某个 Socket 上死等（Block）。它只处理那些“已经准备好数据”的 Socket。</p>
</li>
<li>
<p>所以，Redis 永远不会因为 I/O 等待而发生上下文切换。</p>
</li>
</ul>
<hr>
<h3 id="4-总结对比多线程-vs-单线程">4. 总结对比：多线程 vs 单线程
</h3><p>我们可以用<strong>去银行办事</strong>来比喻：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>模式</strong></th>
          <th><strong>场景比喻</strong></th>
          <th><strong>上下文切换情况</strong></th>
          <th><strong>效率</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>多线程模型</strong></td>
          <td><strong>10 个窗口，10 个柜员。</strong> <br> 所有的柜员都要抢同一个账本（锁）来记账。抢不到的柜员就去喝茶（切换）。柜员之间换班还要交接工作（保存现场）。</td>
          <td><strong>极高</strong> <br> (锁竞争、线程调度)</td>
          <td><strong>低</strong> <br> (大量时间花在抢锁和交接上)</td>
      </tr>
      <tr>
          <td><strong>Redis 单线程</strong></td>
          <td><strong>1 个超级柜员 (Flash)。</strong> <br> 只有他一个人，账本就在手边（Cache）。他动作极快，处理完张三马上处理李四，不用跟任何人抢账本，也不用交接班。</td>
          <td><strong>极低</strong> <br> (几乎为 0，除非时间片用完)</td>
          <td><strong>极高</strong> <br> (CPU 100% 用在干活上)</td>
      </tr>
  </tbody>
</table></div>
<h3 id="5-什么时候-redis-还是会切换">5. 什么时候 Redis 还是会切换？
</h3><p>虽然 Redis 尽力避免切换，但<strong>被动切换 (Involuntary Context Switch)</strong> 是无法避免的，因为操作系统才是老大。</p>
<ol>
<li><strong>时间片用完 (Time Slice):</strong> 操作系统采用了<strong>分时调度</strong>。给 Redis 的 10ms 用完了，不管你活干没干完，OS 必须强行把 CPU 抢走给别的进程（比如 SSH、系统日志）用一下。</li>
</ol>
<p>Redis 单线程避免上下文切换的核心在于：<strong>它通过“非阻塞 I/O”和“单线程串行执行”，消灭了代码层面的“锁”和“等待”，从而让 CPU 始终处于全速运算的高效状态。</strong></p>
<h2 id="redis写数据全生命周期">Redis写数据全生命周期
</h2><p>假设有一个 Java 客户端，发送了一条命令 <code>SET user:1 &quot;Alice&quot;</code>。</p>
<h3 id="第一阶段请求到达与分发-进---io-阶段">第一阶段：请求到达与分发 (进 - I/O 阶段)
</h3><ol>
<li>
<p><strong>客户端发送</strong>：</p>
<ul>
<li>
<p>外部的 Java 客户端（用户级线程）发起 TCP 连接，将命令 <code>SET user:1 &quot;Alice&quot;</code> 转换成 Redis 协议（RESP），通过网线发送出去。</p>
</li>
<li>
<p>数据到达 Redis 服务器的网卡，进入操作系统的<strong>内核 Socket 缓冲区</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>主线程感知 (epoll)</strong>：</p>
<ul>
<li>Redis 的<strong>主线程</strong>正在运行事件循环（Event Loop），通过 <code>epoll_wait</code> 监听到这个 Socket 有数据来了（可读事件）。</li>
</ul>
</li>
<li>
<p><strong>任务分发 (Distribute)</strong>：</p>
<ul>
<li>
<p><strong>关键点</strong>：主线程<strong>不亲自</strong>去读数据。</p>
</li>
<li>
<p>主线程把这个 Socket 连接分配给一组 <strong>I/O 线程（IO Thread Pool）</strong> 中的某一个。</p>
</li>
</ul>
</li>
<li>
<p><strong>I/O 线程并行读取与解析</strong>：</p>
<ul>
<li>
<p><strong>多线程并行</strong>：被选中的 I/O 线程（内核级线程）发起系统调用 <code>read()</code>，从内核缓冲区把数据搬运到用户态。</p>
</li>
<li>
<p><strong>协议解析</strong>：I/O 线程解析数据流，识别出这是一条 <code>SET</code> 命令，参数是 <code>user:1</code> 和 <code>Alice</code>。</p>
</li>
<li>
<p><em>注意：此时主线程会短暂等待，直到所有分配出去的 I/O 任务都完成读取和解析。</em></p>
</li>
</ul>
</li>
</ol>
<h3 id="第二阶段命令执行-做---执行阶段">第二阶段：命令执行 (做 - 执行阶段)
</h3><ol start="5">
<li>
<p><strong>主线程串行执行 (Execute)</strong>：</p>
<ul>
<li>
<p>所有 I/O 线程都解析完后，汇报给主线程。</p>
</li>
<li>
<p><strong>单线程独占</strong>：主线程按照队列顺序，<strong>串行</strong>地拿到解析好的命令。</p>
</li>
<li>
<p><strong>内存操作</strong>：主线程在内存的 <code>HashMap</code> 中找到 <code>user:1</code> 这个槽位，填入 <code>&quot;Alice&quot;</code>。</p>
</li>
<li>
<p><strong>原子性</strong>：因为只有主线程在动这个 Map，所以绝对安全，不需要加锁。</p>
</li>
</ul>
</li>
<li>
<p><strong>生成结果</strong>：</p>
<ul>
<li>
<p>执行成功，主线程生成响应结果 <code>+OK</code>。</p>
</li>
<li>
<p>主线程把这个结果写入到该客户端的<strong>用户态输出缓冲区</strong>中。</p>
</li>
</ul>
</li>
</ol>
<h3 id="第三阶段响应返回-出---io-阶段">第三阶段：响应返回 (出 - I/O 阶段)
</h3><ol start="7">
<li>
<p><strong>任务再次分发</strong>：</p>
<ul>
<li>
<p>主线程依然<strong>不亲自</strong>把数据发回网卡。</p>
</li>
<li>
<p>它再次把“写回数据”的任务分配给 <strong>I/O 线程</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>I/O 线程并行回写</strong>：</p>
<ul>
<li>
<p>I/O 线程并行地调用 <code>write()</code> 系统调用，把缓冲区里的 <code>+OK</code> 发送给内核 Socket 缓冲区。</p>
</li>
<li>
<p>内核负责通过网卡把数据发回给 Java 客户端。</p>
</li>
</ul>
</li>
</ol>
<h3 id="第四阶段持久化-存---后台阶段">第四阶段：持久化 (存 - 后台阶段)
</h3><p><em>这部分是异步发生的，不影响给客户端返回结果的速度。</em></p>
<ol start="9">
<li>
<p><strong>触发持久化</strong>：</p>
<ul>
<li>
<p><strong>AOF</strong>：主线程刚才执行完 <code>SET</code> 后，顺手把这条命令写到了<strong>内核缓冲区</strong>（Page Cache）。</p>
<ul>
<li><strong>后台线程 (BIO)</strong>：稍后（如每秒）醒来，调用 <code>fsync</code> 把内核缓冲区的数据刷到物理磁盘。</li>
</ul>
</li>
<li>
<p><strong>RDB</strong>：如果满足了触发条件（如 1 分钟改了 1 万次）。</p>
<ul>
<li>
<p><strong>主线程</strong>：调用 <code>fork</code> 生成子进程。</p>
</li>
<li>
<p><strong>子进程</strong>：默默地在后台把内存里的 <code>user:1</code> 等所有数据写成 RDB 文件。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="kafka为什么比rocketmq快">Kafka为什么比RocketMQ快
</h2><h3 id="参照物传统-io-standard-io">参照物：传统 I/O (Standard I/O)
</h3><p>假设你要把磁盘上的一个文件通过网卡发给消费者（比如读取日志发送）。
代码通常是：<code>read(file, buffer)</code> -&gt; <code>write(socket, buffer)</code>。</p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154642_575.png"
	width="1672"
	height="1020"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154642_575_hu_2b8c6cb454711c7a.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154642_575_hu_528f1f32484746fa.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="163"
		data-flex-basis="393px"
	
></p>
<p><strong>这中间发生了 4 次拷贝 + 4 次上下文切换：</strong></p>
<ol>
<li>
<p><strong>DMA 拷贝</strong>：磁盘 -&gt; 内核缓冲区（Read Buffer）。</p>
</li>
<li>
<p><strong>CPU 拷贝</strong>：内核缓冲区 -&gt; <strong>用户态缓冲区</strong>（数据进来了）。</p>
</li>
<li>
<p><strong>CPU 拷贝</strong>：用户态缓冲区 -&gt; <strong>内核 Socket 缓冲区</strong>（数据又出去了）。</p>
</li>
<li>
<p><strong>DMA 拷贝</strong>：Socket 缓冲区 -&gt; 网卡。</p>
</li>
</ol>
<p><strong>痛点</strong>：数据在内核和用户态之间反复横跳，CPU 忙着搬运数据，没空干别的。</p>
<h3 id="kafka-的绝技sendfile-数据管道">Kafka 的绝技：<code>sendfile</code> (数据管道)
</h3><p>Kafka 在发送消息给消费者时，调用了 Java 的 <code>FileChannel.transferTo()</code>，底层就是 Linux 的 <code>sendfile</code> 系统调用。</p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_155304_787.png"
	width="1379"
	height="842"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_155304_787_hu_1e2a47705bd5ace6.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_155304_787_hu_b904ea5114a39f66.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="163"
		data-flex-basis="393px"
	
></p>
<h4 id="核心机制">核心机制
</h4><p><code>sendfile</code> 告诉内核：“把这个文件里的数据，直接发给那个 Socket，<strong>不要经过我的手（用户态）</strong>。”</p>
<p><strong>流程（2 次拷贝 + 2 次切换）：</strong></p>
<ol>
<li>
<p><strong>DMA 拷贝</strong>：磁盘 -&gt; <strong>内核缓冲区 (Page Cache)</strong>。</p>
</li>
<li>
<p><strong>CPU/DMA 拷贝</strong>：</p>
<ul>
<li>
<p><em>早期 Linux</em>：内核缓冲区 -&gt; Socket 缓冲区。</p>
</li>
<li>
<p><em>现代 Linux (DMA Gather Copy)</em>：内核缓冲区 -&gt; <strong>直接给网卡</strong>（只把描述符给 Socket，真正做到了 <strong>CPU 0 拷贝</strong>）。</p>
</li>
</ul>
</li>
</ol>
<p>这里的零拷贝指的是零CPU拷贝。</p>
<h3 id="rocketmq-的绝技mmap-内存映射">RocketMQ 的绝技：mmap (内存映射)
</h3><p>RocketMQ 选择了 <code>mmap</code>（Memory Mapped Files），在 Java 中对应 <code>MappedByteBuffer</code>。</p>
<p><img src="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154814_187.png"
	width="1308"
	height="820"
	srcset="/p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154814_187_hu_513a3a0da3a00e9f.png 480w, /p/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/%E5%9C%BA%E6%99%AF/ScreenShot_2025-11-23_154814_187_hu_8a569013266fe261.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="159"
		data-flex-basis="382px"
	
></p>
<h4 id="核心机制-1">核心机制
</h4><p><code>mmap</code> 告诉内核：“把磁盘上的这个文件，<strong>映射</strong>到我的虚拟内存地址里来。”</p>
<p><strong>流程：</strong></p>
<ol>
<li>
<p><strong>建立映射</strong>：用户态的一个虚拟地址指针，直接指向内核的 Page Cache。</p>
</li>
<li>
<p><strong>读写数据</strong>：</p>
<ul>
<li>
<p>RocketMQ 读取这个指针，就像读内存数组一样简单。</p>
</li>
<li>
<p>操作系统负责在后台利用 DMA 把磁盘数据加载到 Page Cache（缺页中断机制）。</p>
</li>
</ul>
</li>
<li>
<p><strong>发送数据</strong>：RocketMQ 读取这块“内存”，然后 write 给 Socket。</p>
<ul>
<li>这里依然需要一次 CPU 拷贝（从映射内存拷贝到 Socket 缓冲区）。</li>
</ul>
</li>
</ol>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>Kafka (sendfile)</strong></th>
          <th><strong>RocketMQ (mmap)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数据路径</strong></td>
          <td>磁盘 -&gt; 内核 -&gt; 网卡</td>
          <td>磁盘 -&gt; 内核 -&gt; 用户态 -&gt; 内核 -&gt; 网卡</td>
      </tr>
      <tr>
          <td><strong>CPU 参与度</strong></td>
          <td><strong>极低</strong> (几乎不参与拷贝)</td>
          <td><strong>中等</strong> (需要一次 CPU 拷贝)</td>
      </tr>
      <tr>
          <td><strong>用户态可见性</strong></td>
          <td><strong>不可见</strong> (黑盒传输)</td>
          <td><strong>可见</strong> (可读、可修改)</td>
      </tr>
      <tr>
          <td><strong>适用场景</strong></td>
          <td><strong>海量数据流式传输</strong> (只管发，不处理)</td>
          <td><strong>复杂业务消息</strong> (需要过滤 Tag、事务回查等)</td>
      </tr>
      <tr>
          <td><strong>Java API</strong></td>
          <td><code>FileChannel.transferTo()</code></td>
          <td><code>MappedByteBuffer</code></td>
      </tr>
      <tr>
          <td><strong>限制</strong></td>
          <td>无法对内容进行逻辑处理</td>
          <td>文件不能太大 (RocketMQ 限制 1GB)</td>
      </tr>
  </tbody>
</table></div>
<p><strong>Kafka</strong> 之所以吞吐量宇宙第一，是因为它<strong>放弃了对消息细节的掌控</strong>，直接用 <code>sendfile</code> 当了一个“甩手掌柜”，把数据直接丢给网卡。</p>
<p><strong>RocketMQ</strong> 之所以功能强大（支持 Tag 过滤、复杂的事务状态），是因为它用了 <code>mmap</code>，<strong>保留了对数据的访问权</strong>，虽然牺牲了一点点传输性能，但换来了业务灵活性。</p>
<p><strong>一句话概括：Kafka 是为了“运货”而生，RocketMQ 是为了“验货”而生。</strong></p>
<p><strong>Page Cache</strong> 是 Linux 内核为了掩盖磁盘龟速而用闲置内存做的“障眼法”。</p>
<h2 id="为什么rpchttp2能比http11快那么多">为什么RPC/HTTP2能比HTTP1.1快那么多
</h2><p>简单来说，HTTP/1.1 像是<strong>单车道</strong>，而 HTTP/2 + RPC 像是<strong>多车道高速公路</strong>，且路上跑的都是<strong>压缩后的跑车</strong>而不是臃肿的大卡车。</p>
<p>以下是具体的技术核心差异：</p>
<hr>
<h3 id="1-多路复用-multiplexing--解决核心痛点">1. 多路复用 (Multiplexing) —— 解决核心痛点
</h3><p>这是 HTTP/2 相比 HTTP/1.1 最大的性能提升点，解决了“<strong>队头阻塞</strong>”（Head-of-Line Blocking）问题。</p>
<ul>
<li>
<p>HTTP/1.1 的问题：</p>
<p>在同一个 TCP 连接中，请求是串行的。浏览器/客户端必须等上一个请求响应回来，才能发下一个。如果第一个请求处理很慢（比如数据库卡了），后面的所有请求都会被堵住。</p>
<ul>
<li><em>补救措施：</em> 浏览器通常会针对同一个域名建立 6 个 TCP 连接来并行传输，但这对服务器资源消耗很大。</li>
</ul>
</li>
<li>
<p>HTTP/2 (RPC) 的方案：</p>
<p>它引入了 流 (Stream) 和 帧 (Frame) 的概念。</p>
<ul>
<li>
<p>所有的请求和响应都共用<strong>同一个 TCP 连接</strong>。</p>
</li>
<li>
<p>不同的请求被拆分成许多小的二进制“帧”，这些帧像洗牌一样混在一起传输，每一帧都有 ID 标识属于哪个请求。</p>
</li>
<li>
<p><strong>结果：</strong> 请求 A 的数据包不需要等请求 B 处理完就能发送。高并发下，吞吐量极高。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-头部压缩-hpack--节省带宽">2. 头部压缩 (HPACK) —— 节省带宽
</h3><p>在微服务架构中，RPC 调用非常频繁，HTTP 头部（Headers）占用的开销比你想象的要大。</p>
<ul>
<li>
<p>HTTP/1.1 的问题：</p>
<p>HTTP 是无状态的，每次请求都会携带完整的 Header（如 User-Agent, Cookie, Accept 等）。这些全是纯文本，往往几百字节甚至上 KB。如果你的请求体（Body）只有几十字节，那传输的有效数据比例极低。</p>
</li>
<li>
<p>HTTP/2 (RPC) 的方案：</p>
<p>使用了 HPACK 算法。</p>
<ul>
<li>
<p>客户端和服务器共同维护一张<strong>动态表</strong>和<strong>静态表</strong>。</p>
</li>
<li>
<p>如果发送过 <code>User-Agent: Chrome</code>，第二次只需要发送一个索引号（比如 <code>1</code>），服务器查表就知道是 <code>User-Agent: Chrome</code>。</p>
</li>
<li>
<p>这使得 Header 的大小几乎可以忽略不计。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-二进制分帧-binary-framing--解析更快">3. 二进制分帧 (Binary Framing) —— 解析更快
</h3><p>计算机处理二进制数据远快于处理文本。</p>
<ul>
<li>
<p>HTTP/1.1 的问题：</p>
<p>是文本协议。解析文本需要处理换行符、空格、大小写等，对于高并发服务器来说，解析 JSON 或 HTTP 报文会消耗大量的 CPU 资源。</p>
</li>
<li>
<p>HTTP/2 (RPC) 的方案：</p>
<p>是二进制协议。数据在传输层就已经被分割为更小的消息和帧，并采用二进制编码。机器解析起来非常高效，出错率低，且更紧凑。</p>
</li>
</ul>
<hr>
<h3 id="4-序列化协议-serialization--rpc-的独门秘籍">4. 序列化协议 (Serialization) —— RPC 的独门秘籍
</h3><p>这一条主要针对 RPC（如 gRPC 使用的 Protocol Buffers）对比传统的 RESTful (HTTP/1.1 + JSON)。</p>
<ul>
<li>
<p>HTTP/1.1 + JSON：</p>
<p>JSON 是基于文本的，冗余度极高。比如 {&ldquo;id&rdquo;: 12345, &ldquo;name&rdquo;: &ldquo;user&rdquo;}，你需要传输字段名 id 和 name。且 JSON 的解析（反序列化）非常耗 CPU。</p>
</li>
<li>
<p>RPC (Protobuf)：</p>
<p>使用 Protocol Buffers (Protobuf) 或 Thrift 等二进制序列化协议。</p>
<ul>
<li>
<p><strong>体积小：</strong> 它是通过 ID 映射字段，不传输字段名，压缩后的体积通常只有 JSON 的 1/3 到 1/10。</p>
</li>
<li>
<p><strong>速度快：</strong> 二进制流直接映射到内存对象，序列化/反序列化速度比 JSON 快 5-10 倍。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-服务端推送-server-push">5. 服务端推送 (Server Push)
</h3><p>虽然在 RPC 场景下用得相对少，但 HTTP/2 允许服务器在客户端请求之前“主动”推送资源，减少了往返延迟（RTT）。</p>
<hr>
<h3 id="总结对比">总结对比
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>HTTP/1.1</strong></th>
          <th><strong>HTTP/2 (及 gRPC)</strong></th>
          <th><strong>优势</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>传输格式</strong></td>
          <td>文本 (Text)</td>
          <td>二进制 (Binary)</td>
          <td>解析更快，体积更小</td>
      </tr>
      <tr>
          <td><strong>连接模型</strong></td>
          <td>串行 (Keep-Alive)</td>
          <td><strong>多路复用 (Multiplexing)</strong></td>
          <td>解决队头阻塞，极大提高并发</td>
      </tr>
      <tr>
          <td><strong>头部开销</strong></td>
          <td>巨大 (纯文本重复发送)</td>
          <td><strong>HPACK 压缩</strong></td>
          <td>节省带宽</td>
      </tr>
      <tr>
          <td><strong>负载内容</strong></td>
          <td>通常是 JSON (大、慢)</td>
          <td>通常是 Protobuf (小、快)</td>
          <td>序列化性能提升明显</td>
      </tr>
      <tr>
          <td><strong>TCP 连接数</strong></td>
          <td>多个 (通常 6 个)</td>
          <td><strong>只需 1 个</strong></td>
          <td>降低服务器握手和资源开销</td>
      </tr>
  </tbody>
</table></div>
<h2 id="heavykeeper和lrulfu">HeavyKeeper和LRU，LFU
</h2><p>可以将它们的关系理解为：<strong>LRU 和 LFU 是“怎么扔垃圾”，而 HeavyKeeper 是“怎么用极小的代价找出谁是大佬”。</strong></p>
<p>以下是详细的对比和原理解析：</p>
<hr>
<h3 id="1-lru-least-recently-used---最近最少使用">1. LRU (Least Recently Used) - 最近最少使用
</h3><p><strong>核心逻辑：</strong> “如果数据最近被访问过，那么它将来被访问的几率也很大。”</p>
<ul>
<li>
<p><strong>关注点：</strong> <strong>时间（Recency）</strong>。</p>
</li>
<li>
<p><strong>工作原理：</strong></p>
<ul>
<li>
<p>新数据或刚被访问的数据放到队头。</p>
</li>
<li>
<p>缓存满时，直接淘汰队尾的数据（最久没被摸过的）。</p>
</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>实现简单（HashMap + 双向链表）。</p>
</li>
<li>
<p>适应<strong>突发性流量</strong>（Burst Traffic），因为热点往往是临近的。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>缓存污染（Cache Pollution）：</strong> 如果进行一次全表扫描（读取大量数据但只用一次），会把原本的热点数据全部挤出缓存，导致缓存命中率急剧下降。</li>
</ul>
</li>
</ul>
<h3 id="2-lfu-least-frequently-used---最不经常使用">2. LFU (Least Frequently Used) - 最不经常使用
</h3><p><strong>核心逻辑：</strong> “如果数据过去被访问多次，那么它将来被访问的几率也很大。”</p>
<ul>
<li>
<p><strong>关注点：</strong> <strong>频率（Frequency）</strong>。</p>
</li>
<li>
<p><strong>工作原理：</strong></p>
<ul>
<li>
<p>为每个数据维护一个计数器。</p>
</li>
<li>
<p>缓存满时，淘汰计数器数值最小的数据。</p>
</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>
<p>抗扫描能力强。偶尔的一次性批量读取不会挤掉长期积累的热点数据。</p>
</li>
<li>
<p>对于<strong>长期稳定</strong>的热点数据，命中率极高。</p>
</li>
</ul>
</li>
<li>
<p><strong>缺点：</strong></p>
<ul>
<li>
<p><strong>实现复杂且内存开销大：</strong> 需要维护所有数据的计数器，且排序复杂度较高。</p>
</li>
<li>
<p><strong>旧数据滞留（Dusty Cache）：</strong> 一个以前很热但现在没用的数据（比如上个月的爆款商品），因为计数器很高，会一直霸占缓存，如果不引入衰减机制，很难被淘汰。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-heavykeeper---专门抓大象的守门员">3. HeavyKeeper - 专门抓“大象”的守门员
</h3><p><strong>核心逻辑：</strong> “我不追求 100% 精确，但我用极小的内存就能告诉你谁是真正的热点（Top-K）。”</p>
<ul>
<li>
<p><strong>关注点：</strong> <strong>极低内存下的频率预估</strong>。</p>
</li>
<li>
<p><strong>本质：</strong> 它不是一个完整的缓存系统，而是一个<strong>算法结构</strong>（通常基于 Count-Min Sketch 的改进）。它常被用于 Redis 的热点发现工具或现代缓存系统（如 Caffeine 库）的频率过滤器中。</p>
</li>
<li>
<p><strong>工作原理（指纹衰减）：</strong></p>
<ul>
<li>
<p>它使用类似哈希表的结构，但存储的是指纹（Fingerprint）和计数。</p>
</li>
<li>
<p><strong>关键创新：</strong> 传统的 Sketch 算法在哈希冲突时会错误地增加计数（导致高估）。HeavyKeeper 引入了<strong>衰减机制</strong>——当新元素进入并发生哈希冲突时，如果指纹不匹配，它会以一定概率减少（Decay）原有的计数器。</p>
</li>
<li>
<p><strong>结果：</strong> “小鼠流”（低频数据）的计数会被不断衰减消灭，“大象流”（高频数据）因为访问足够多，能抵抗衰减并幸存下来。</p>
</li>
</ul>
</li>
<li>
<p><strong>优点：</strong></p>
<ul>
<li>
<p><strong>内存占用极小：</strong> 相比 LFU 记录所有 key 的完整计数，HeavyKeeper 只需要很少的 bucket 就能大概率找准热点。</p>
</li>
<li>
<p><strong>误差可控：</strong> 专门为 Top-K 场景设计，对高频数据极其准确。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结对比表">总结对比表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>LRU (时间)</strong></th>
          <th><strong>LFU (频率)</strong></th>
          <th><strong>HeavyKeeper (概率频率)</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>全称</strong></td>
          <td>Least Recently Used</td>
          <td>Least Frequently Used</td>
          <td>HeavyKeeper</td>
      </tr>
      <tr>
          <td><strong>核心维度</strong></td>
          <td><strong>最近访问时间</strong></td>
          <td><strong>访问总次数</strong></td>
          <td><strong>访问总次数 (概率性)</strong></td>
      </tr>
      <tr>
          <td><strong>主要用途</strong></td>
          <td>缓存淘汰策略</td>
          <td>缓存淘汰策略</td>
          <td><strong>热点检测 (Top-K)</strong> / 辅助 LFU</td>
      </tr>
      <tr>
          <td><strong>抗扫描能力</strong></td>
          <td>弱 (容易被冲刷)</td>
          <td>强</td>
          <td>强</td>
      </tr>
      <tr>
          <td><strong>空间开销</strong></td>
          <td>中 (存 Key + 链表指针)</td>
          <td>大 (存 Key + 计数器)</td>
          <td><strong>极小</strong> (哈希桶 + 指纹)</td>
      </tr>
      <tr>
          <td><strong>实现复杂度</strong></td>
          <td>低 ($O(1)$)</td>
          <td>高 (需堆或多级链表)</td>
          <td>中 (哈希 + 概率逻辑)</td>
      </tr>
      <tr>
          <td><strong>精准度</strong></td>
          <td>精确</td>
          <td>精确</td>
          <td><strong>有误差</strong> (但对热点准确)</td>
      </tr>
      <tr>
          <td><strong>典型应用</strong></td>
          <td>MySQL Buffer Pool (改进版), 操作系统页置换</td>
          <td>传统缓存系统</td>
          <td><strong>Redis 热 key 发现</strong>, 网络流量分析</td>
      </tr>
  </tbody>
</table></div>
<h3 id="lru代码实现">LRU代码实现
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span><span class="lnt">98
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kn">package</span><span class="w"> </span><span class="nn">com.lucius.interviewproject.LRU</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kn">import</span><span class="w"> </span><span class="nn">java.util.HashMap</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LRUCache</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 定义双向链表节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">class</span> <span class="nc">DLinkedNode</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">DLinkedNode</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">public</span><span class="w"> </span><span class="nf">DLinkedNode</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">_key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">_value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_key</span><span class="p">;</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_value</span><span class="p">;}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 核心数据结构</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cache</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w"> </span><span class="c1">// 伪头部和伪尾部节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">LRUCache</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 使用伪头部和伪尾部节点，避免处理复杂的 null 边界情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">tail</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 如果 key 存在，先通过哈希表定位，然后移动到链表头部</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="na">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">put</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cache</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">key</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果 key 不存在，创建一个新节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">newNode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 添加进哈希表</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">cache</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">newNode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 添加至双向链表的头部</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addToHead</span><span class="p">(</span><span class="n">newNode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">size</span><span class="o">++</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果超出容量，删除双向链表的尾部节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">removeTail</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// 删除哈希表中对应的项</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">cache</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">tail</span><span class="p">.</span><span class="na">key</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">size</span><span class="o">--</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 如果 key 存在，更新 value，并移动到头部</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">node</span><span class="p">.</span><span class="na">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">moveToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// --- 以下是辅助的链表操作方法 ---</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 将节点移动到头部 (也就是最近使用的位置)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">moveToHead</span><span class="p">(</span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">removeNode</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">addToHead</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 将节点插入到伪头部之后</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">addToHead</span><span class="p">(</span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">head</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 删除节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">removeNode</span><span class="p">(</span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="na">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="p">.</span><span class="na">next</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. 删除尾部节点（淘汰最久未使用的）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="nf">removeTail</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">DLinkedNode</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">.</span><span class="na">prev</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">removeNode</span><span class="p">(</span><span class="n">res</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="redis的大key的问题怎么解决">Redis的大key的问题怎么解决
</h2><p>由于 Redis 是<strong>单线程模型</strong>，处理一个巨大的 Key（无论是读取、写入还是删除）都会占用主线程，导致后续请求排队等待，造成 &ldquo;卡顿&rdquo;。</p>
<p>以下是系统化的解决思路，分为 <strong>发现</strong>、<strong>删除</strong> 和 <strong>治理（预防）</strong> 三个阶段。</p>
<hr>
<h3 id="一-什么是-big-key标准定义">一、 什么是 Big Key？（标准定义）
</h3><p>通常根据 Value 的大小或元素数量来判定：</p>
<ul>
<li>
<p><strong>String 类型：</strong> Value &gt; 10KB（严格标准）或 1MB（宽松标准）。</p>
</li>
<li>
<p><strong>集合类型（Hash, List, Set, ZSet）：</strong> 元素个数 &gt; 5000 或 10000 个。</p>
</li>
</ul>
<hr>
<h3 id="二-如何发现-big-key">二、 如何发现 Big Key？
</h3><p>在治理之前，首先要定位它们。</p>
<ol>
<li>
<p><strong><code>redis-cli --bigkeys</code> 命令：</strong></p>
<ul>
<li>
<p>Redis 自带的工具，会扫描整个 Key 空间。</p>
</li>
<li>
<p><em>缺点：</em> 它是阻塞式的扫描（虽然用了 SCAN），在数据量巨大时可能会轻微影响性能，且只能返回每种类型最大的那个 Key，信息不全。</p>
</li>
</ul>
</li>
<li>
<p><strong><code>MEMORY USAGE key</code> 命令：</strong></p>
<ul>
<li>如果你怀疑某个 Key 是大 Key，可以用这个命令查询其实际内存占用。</li>
</ul>
</li>
<li>
<p><strong>RDB 文件分析（推荐）：</strong></p>
<ul>
<li>
<p>使用工具（如 <code>rdb-tools</code> 或 <code>redis-rdb-tools</code>）离线分析 RDB 备份文件。</p>
</li>
<li>
<p><em>优点：</em> <strong>完全不影响线上 Redis 性能</strong>，生成的报告非常详细（包含 Key 名称、大小、类型）。</p>
</li>
</ul>
</li>
<li>
<p><strong>监控告警：</strong></p>
<ul>
<li>
<p>如果在云服务商（如阿里云、AWS）上，通常控制台会有 &ldquo;大 Key 分析&rdquo; 功能。</p>
</li>
<li>
<p>监控网络带宽，如果网络流出流量瞬间飙升，通常是有客户端读取了大 Key。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三-如何安全地删除-big-key">三、 如何安全地删除 Big Key？
</h3><p>绝对禁止直接使用 DEL 命令删除大 Key！</p>
<p>DEL 是同步阻塞操作，删除一个几百 MB 的 Key 可能会阻塞 Redis 几秒钟，导致故障转移或请求超时。</p>
<h4 id="1-redis-40-及以上版本推荐">1. Redis 4.0 及以上版本（推荐）
</h4><p>使用 <strong><code>UNLINK</code></strong> 命令代替 <code>DEL</code>。</p>
<ul>
<li><strong>原理：</strong> <code>UNLINK</code> 只是将 Key 从元数据中解绑（逻辑删除），真正的内存回收操作会由后台线程（Lazy Free）异步执行，<strong>不会阻塞主线程</strong>。</li>
</ul>
<h4 id="2-redis-40-以下版本手动渐进式删除">2. Redis 4.0 以下版本（手动渐进式删除）
</h4><p>如果版本较老，必须手动分批删除，避免阻塞：</p>
<ul>
<li>
<p><strong>Hash:</strong> 使用 <code>HSCAN</code> 每次扫描一部分字段，然后用 <code>HDEL</code> 删除。</p>
</li>
<li>
<p><strong>List:</strong> 使用 <code>LPOP</code>/<code>RPOP</code> 或 <code>LTRIM</code> 分批删除。</p>
</li>
<li>
<p><strong>Set:</strong> 使用 <code>SSCAN</code> 扫描，<code>SREM</code> 删除。</p>
</li>
<li>
<p><strong>ZSet:</strong> 使用 <code>ZREMRANGEBYRANK</code> 分批删除。</p>
</li>
</ul>
<hr>
<h3 id="四-如何彻底解决设计与预防">四、 如何彻底解决（设计与预防）？
</h3><p>删除只是治标，只有修改业务设计才能治本。</p>
<h4 id="1-拆分split">1. 拆分（Split）
</h4><p>将一个大 Key 拆分为多个小 Key。</p>
<ul>
<li>
<p><strong>场景：</strong> 一个 Hash 存储了 100 万个用户对象。</p>
</li>
<li>
<p><strong>方案：</strong> 使用 Hash 取模设计。例如定义 <code>hash_0</code> 到 <code>hash_99</code> 共100个 Bucket。</p>
<ul>
<li>
<p>存取时：<code>id % 100</code> 决定存入哪个 Key。</p>
</li>
<li>
<p>这样每个 Key 的大小就只有原来的 1/100。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-压缩compression">2. 压缩（Compression）
</h4><p>对于 String 类型的长文本（如 JSON、XML），使用压缩算法。</p>
<ul>
<li><strong>方案：</strong> 写入 Redis 前使用 Gzip、Snappy 或 Protobuf 进行压缩/序列化。通常能减少 50%-80% 的体积。</li>
</ul>
<h4 id="3-剪裁与清洗pruning">3. 剪裁与清洗（Pruning）
</h4><p>不要把 Redis 当数据库用，只存 &ldquo;热点数据&rdquo;。</p>
<ul>
<li>
<p><strong>场景：</strong> 一个 List 存了用户的历史浏览记录，长达几万条。</p>
</li>
<li>
<p><strong>方案：</strong> 业务上只需要展示最近 100 条。在写入时维持定长队列（<code>LTRIM</code>），或者定期清理过期数据。</p>
</li>
</ul>
<h4 id="4-设置过期时间ttl">4. 设置过期时间（TTL）
</h4><ul>
<li>防止 &ldquo;僵尸&rdquo; 大 Key 长期占用内存。给 Key 设置合理的 TTL，让其自动过期删除（注意：Redis 的自动过期在 4.0 之前删除大 Key 也可能阻塞，4.0+ 配置 <code>lazyfree-lazy-expire yes</code> 可解）。</li>
</ul>
<h4 id="5-存储转移offloading">5. 存储转移（Offloading）
</h4><ul>
<li>
<p>如果数据本身就是很大（例如图片二进制、长文章），且必须完整读取，那么它<strong>不适合</strong>存入 Redis。</p>
</li>
<li>
<p><strong>方案：</strong> 存入 S3、MongoDB 或 CDN，Redis 只存该数据的 URL 或索引 ID。</p>
</li>
</ul>
<hr>
<h3 id="总结对照表">总结对照表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>策略</strong></th>
          <th><strong>适用场景</strong></th>
          <th><strong>关键手段</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>发现</strong></td>
          <td>线上排查 / 离线分析</td>
          <td><code>redis-cli --bigkeys</code>, RDB Tools</td>
      </tr>
      <tr>
          <td><strong>应急处理</strong></td>
          <td>此时此刻必须删除</td>
          <td><strong><code>UNLINK</code></strong> (异步删除)</td>
      </tr>
      <tr>
          <td><strong>架构优化</strong></td>
          <td>集合元素过多</td>
          <td><strong>拆分</strong> (Sharding/Bucketing)</td>
      </tr>
      <tr>
          <td><strong>架构优化</strong></td>
          <td>文本 Value 过大</td>
          <td><strong>压缩</strong> (Gzip/Snappy)</td>
      </tr>
      <tr>
          <td><strong>架构优化</strong></td>
          <td>无效数据堆积</td>
          <td><strong>定期清理</strong> (LTRIM) / 设置 TTL</td>
      </tr>
  </tbody>
</table></div>
<h2 id="redis是怎么找到key存储在哪个节点上">Redis是怎么找到key存储在哪个节点上？
</h2><p>Redis 在集群模式（Redis Cluster）下，并不是直接把 Key 存到节点上的，而是引入了一个中间层：<strong>哈希槽 (Hash Slot)</strong>。</p>
<p>简单来说，Redis 集群<strong>预分好了一万多个坑位（Slot）</strong>，所有的 Key 都要先算一下自己该去哪个坑，而具体的节点（Node）只是负责管理这些坑位。</p>
<p>以下是具体的寻址过程，分为 <strong>理论计算</strong> 和 <strong>客户端交互</strong> 两个层面。</p>
<hr>
<h3 id="一-核心算法crc16--取模">一、 核心算法：CRC16 + 取模
</h3><p>Redis Cluster 固定的将数据空间划分为 <strong>16384</strong> 个哈希槽（编号 0 ~ 16383）。</p>
<p>当你要存储一个 Key（比如 <code>set name lucius</code>）时，Redis 会通过以下两步计算出这个 Key 属于哪个槽：</p>
<ol>
<li>
<p><strong>计算哈希值</strong>：使用 <strong>CRC16</strong> 算法对 Key 进行计算，得到一个整数。</p>
</li>
<li>
<p><strong>取模运算</strong>：将得到的整数对 16384 取模。</p>
</li>
</ol>
<p>公式：</p>
$$
Slot = CRC16(key) \pmod{16384}
$$<p>计算出 Slot 编号（比如 5000）后，Redis 只需要查看<strong>当前集群配置中，编号 5000 的槽是由哪个节点负责的</strong>，就能确定数据在哪个节点。</p>
<hr>
<h3 id="二-生动比喻快递分拣中心">二、 生动比喻：快递分拣中心
</h3><p>为了方便理解，我们可以把 Redis Cluster 想象成一个<strong>巨大的物流分拣系统</strong>：</p>
<ol>
<li>
<p><strong>货物 (Key)</strong>：你要存的数据。</p>
</li>
<li>
<p><strong>快递筐 (Hash Slot)</strong>：系统里一共有 <strong>16384 个固定的筐子</strong>，编号 0-16383。</p>
</li>
<li>
<p><strong>货车 (Node)</strong>：实际负责运货的物理服务器（比如有 3 台服务器 A、B、C）。</p>
</li>
</ol>
<p><strong>流程是这样的：</strong></p>
<ul>
<li>
<p><strong>分配规则</strong>：</p>
<ul>
<li>
<p>货车 A 负责运送 0 ~ 5500 号筐子。</p>
</li>
<li>
<p>货车 B 负责运送 5501 ~ 11000 号筐子。</p>
</li>
<li>
<p>货车 C 负责运送 11001 ~ 16383 号筐子。</p>
</li>
</ul>
</li>
<li>
<p><strong>存货过程</strong>：</p>
<ul>
<li>
<p>来了一个包裹 <code>name</code>。</p>
</li>
<li>
<p>系统算一下（CRC16），发现它应该进 <strong>5000 号筐子</strong>。</p>
</li>
<li>
<p>查表发现 5000 号筐子归 <strong>货车 A</strong> 管。</p>
</li>
<li>
<p>于是包裹被丢进货车 A。</p>
</li>
</ul>
</li>
</ul>
<p>为什么要这么设计？</p>
<p>如果因为业务繁忙，你要加一辆货车 D，你不需要把所有包裹重新拆包计算一遍。你只需要把 货车 A 上的一部分筐子（比如 0~1000号）搬到 货车 D 上即可。</p>
<p>这就是 Redis Cluster 扩容方便的原因：数据迁移的单位是“槽”，而不是单个 Key。</p>
<hr>
<h3 id="三-客户端是怎么知道去哪个节点的">三、 客户端是怎么知道去哪个节点的？
</h3><p>虽然服务器知道槽位映射关系，但**客户端（比如你的 Java 代码）**是怎么知道的呢？</p>
<p>通常有两种情况：</p>
<h4 id="1-笨客户端每次都问或问错了-moved-重定向错误">1. 笨客户端（每次都问，或问错了）—— MOVED 重定向错误
</h4><p>假设客户端不知道 Key <code>name</code> 在哪个节点，它随便连了一个节点（比如节点 B）发送命令：<code>GET name</code>。</p>
<ol>
<li>
<p>节点 B 收到命令，计算 <code>CRC16('name') % 16384</code>，发现属于 Slot 5000。</p>
</li>
<li>
<p>节点 B 查自己的小本本，发现 Slot 5000 归 <strong>节点 A</strong> 管。</p>
</li>
<li>
<p>节点 B 不会帮客户端去取数据（因为那是代理做的事），而是直接返回一个错误：</p>
<p>MOVED 5000 192.168.1.100:6379</p>
<p>(翻译：哥们你找错人了，这个 Key 归 5000 号槽管，那个槽在 IP 为 &hellip; 的节点上，你自己去找它吧。)</p>
</li>
<li>
<p>客户端收到报错，根据新地址，重新去连接节点 A。</p>
</li>
</ol>
<h4 id="2-聪明客户端smart-client如-jedis-lettuce-本地缓存">2. 聪明客户端（Smart Client，如 Jedis, Lettuce）—— 本地缓存
</h4><p>为了性能，现在的客户端（如 Java 的 Jedis、Lettuce）在启动时，会先连接集群，把 <strong>Slot -&gt; Node 的映射表</strong> 下载下来缓存在本地内存里。</p>
<ol>
<li>
<p>你要 <code>GET name</code>。</p>
</li>
<li>
<p>Java 客户端在本地算一下：Slot = 5000。</p>
</li>
<li>
<p>查本地缓存：Slot 5000 -&gt; 节点 A。</p>
</li>
<li>
<p>直接连接节点 A 发送请求。</p>
<p>这避免了额外的网络跳转，效率最高。</p>
</li>
</ol>
<hr>
<h3 id="四-特殊情况hash-tag强制特定-key-去特定节点">四、 特殊情况：Hash Tag（强制特定 Key 去特定节点）
</h3><p>面试高频考点：</p>
<p>由于 CRC16 算法是随机的，user:1001 和 order:1001 很大概率会被分到不同的节点上。</p>
<p>这就导致一个问题：如果你想在一个事务（Multi/Exec）里同时操作这两个 Key，或者用 Lua 脚本同时处理它们，会报错！ 因为 Redis 要求事务或脚本涉及的所有 Key 必须在同一个节点上。</p>
<p>解决方案：Hash Tag {}</p>
<p>你可以在 Key 中使用花括号 {}。Redis 计算 Hash 时，如果发现 Key 里有 {}，就只计算 {} 内部字符串的 Hash 值。</p>
<ul>
<li>
<p>Key 1: <code>user:{1001}</code> -&gt; 计算 <code>CRC16(&quot;1001&quot;)</code></p>
</li>
<li>
<p>Key 2: <code>order:{1001}</code> -&gt; 计算 <code>CRC16(&quot;1001&quot;)</code></p>
</li>
</ul>
<p>因为 <code>{}</code> 里的内容一样，算出来的 Slot 肯定一样，它们就一定会落到同一个节点上。</p>
<p>没有 Hash Tag 之前，Redis 的分拣员（CRC16 算法）是非常<strong>老实</strong>的，它会把 Key 的每一个字符都算进去。</p>
<h3 id="1-没有-hash-tag老实模式">1. <strong>没有 Hash Tag（老实模式）</strong>
</h3><p>分拣员看到什么就算什么，<strong>全名参与计算</strong>。</p>
<ul>
<li>
<p><strong>Key A</strong>: <code>user:1001</code></p>
<ul>
<li>
<p><strong>算法输入</strong>：<code>&quot;user:1001&quot;</code> (9 个字符)</p>
</li>
<li>
<p><strong>结果</strong>：哈希值 X $\rightarrow$ 对应 <strong>Slot 500</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Key B</strong>: <code>order:1001</code></p>
<ul>
<li>
<p><strong>算法输入</strong>：<code>&quot;order:1001&quot;</code> (10 个字符)</p>
</li>
<li>
<p><strong>结果</strong>：哈希值 Y $\rightarrow$ 对应 <strong>Slot 8000</strong></p>
</li>
</ul>
</li>
</ul>
<p>因为 <code>&quot;user:1001&quot;</code> 和 <code>&quot;order:1001&quot;</code> 是完全不同的两个字符串，算出来的结果自然千差万别，所以它们被分到了不同的节点。</p>
<hr>
<h3 id="2-有-hash-tag偷懒模式">2. <strong>有 Hash Tag（偷懒模式）</strong>
</h3><p>分拣员一旦看到 <code>{}</code>，就<strong>只算花括号里面的内容</strong>，<strong>外面的前缀后缀全当看不见</strong>。</p>
<ul>
<li>
<p><strong>Key A</strong>: <code>user:{1001}</code></p>
<ul>
<li>
<p><strong>算法输入</strong>：<code>&quot;1001&quot;</code> (只算这 4 个数字)</p>
</li>
<li>
<p><strong>结果</strong>：哈希值 Z $\rightarrow$ 对应 <strong>Slot 300</strong></p>
</li>
</ul>
</li>
<li>
<p><strong>Key B</strong>: <code>order:{1001}</code></p>
<ul>
<li>
<p><strong>算法输入</strong>：<code>&quot;1001&quot;</code> (还是只算这 4 个数字)</p>
</li>
<li>
<p><strong>结果</strong>：哈希值 Z $\rightarrow$ 对应 <strong>Slot 300</strong></p>
</li>
</ul>
</li>
</ul>
<p>因为<strong>输入完全一样</strong>（都是 <code>&quot;1001&quot;</code>），所以<strong>算出来的 Slot 编号绝对一样</strong>，这两个 Key 就必定会去同一个节点“团聚”。</p>
<h3 id="小贴士hash-tag使用风险">小贴士（Hash Tag使用风险）
</h3><p>虽然 Hash Tag 很好用，但<strong>千万不要滥用</strong>。</p>
<p>如果你把几百万个 Key 都加上同一个 Hash Tag（比如 <code>user:{beijing}</code>），那么这几百万个 Key 算出来的 Slot 全都一样，它们会全部挤到<strong>同一台机器</strong>上。</p>
<p><strong>后果</strong>：
这就导致了<strong>数据倾斜（Data Skew）</strong>—— 集群里的一台机器忙死（内存爆满、CPU 飙升），而其他机器闲死。</p>
<h2 id="mysql三层b树能存储多少数据">MySQL三层B+树能存储多少数据?
</h2><p>但在通常的估算标准下（主键为 BigInt，单行数据约 1KB），<strong>三层 B+ 树大约能存储 2000 万（2000w）条数据</strong>。</p>
<h3 id="1-核心预设条件">1. 核心预设条件
</h3><p>MySQL 的 InnoDB 存储引擎有以下几个默认属性，这是计算的基础：</p>
<ul>
<li>
<p><strong>页大小 (Page Size)</strong>：默认是 <strong>16KB</strong> ($16384$ 字节)。</p>
</li>
<li>
<p><strong>指针大小</strong>：InnoDB 页指针为 <strong>6 字节</strong>。</p>
</li>
<li>
<p><strong>主键类型</strong>：通常假设为 <code>BigInt</code> (<strong>8 字节</strong>)。如果用 <code>Int</code> (<strong>4 字节</strong>)，存的更多。</p>
</li>
</ul>
<h3 id="2-b-树结构拆解">2. B+ 树结构拆解
</h3><p>B+ 树分为<strong>非叶子节点</strong>（存索引和指针）和<strong>叶子节点</strong>（存真实数据）。</p>
<h4 id="第一步计算非叶子节点能存多少索引">第一步：计算非叶子节点能存多少索引？
</h4><p>非叶子节点不存数据，只存“主键 + 指针”。</p>
<ul>
<li>
<p><strong>单个索引项大小</strong> = 主键大小 (8B) + 指针大小 (6B) = <strong>14 字节</strong>。</p>
</li>
<li>
<p><strong>单页可存索引数</strong> = 页大小 / 索引项大小 = $16384 / 14 \approx 1170$ 个。</p>
</li>
</ul>
<p>这意味着，一个非叶子节点可以指向 <strong>1170</strong> 个下级节点。</p>
<h4 id="第二步计算叶子节点能存多少数据">第二步：计算叶子节点能存多少数据？
</h4><p>叶子节点存储真实的行数据。这里变量最大的就是“一行数据的大小”。</p>
<ul>
<li>
<p><strong>假设 1</strong>：一行数据大小为 <strong>1KB</strong>（比较常见的预设）。</p>
</li>
<li>
<p><strong>单页可存行数</strong> = $16384 / 1024 = 16$ 条。</p>
</li>
</ul>
<h3 id="3-三层-b-树容量计算">3. 三层 B+ 树容量计算
</h3><p>结构如下：</p>
<ol>
<li>
<p><strong>根节点（第1层）</strong>：非叶子节点，指向 1170 个第2层节点。</p>
</li>
<li>
<p><strong>分支节点（第2层）</strong>：非叶子节点，每个节点指向 1170 个叶子节点。总共有 $1170 \times 1170$ 个叶子节点。</p>
</li>
<li>
<p><strong>叶子节点（第3层）</strong>：存数据。</p>
</li>
</ol>
<p>计算公式：</p>
<p>$\text{总记录数} = (\text{根节点指针数}) \times (\text{第二层指针数}) \times (\text{叶子节点单页行数})$</p>
<p>代入数值（行数据 1KB）：</p>
<p>$1170 \times 1170 \times 16 \approx \mathbf{21,902,400}$</p>
<blockquote>
<p><strong>结论 1：</strong> 如果一行数据是 1KB，三层能存约 <strong>2190 万</strong> 条数据。</p>
</blockquote>
<hr>
<h3 id="4-如果数据行很小怎么办">4. 如果数据行很小怎么办？
</h3><p>有些表可能只有几个字段，一行数据可能只有 <strong>100 字节</strong>。如果不算页分裂等损耗：</p>
<ul>
<li>
<p><strong>单页可存行数</strong> = $16384 / 100 \approx 160$ 条。</p>
</li>
<li>
<p><strong>总容量</strong> = $1170 \times 1170 \times 160 \approx \mathbf{2.19 亿}$。</p>
</li>
</ul>
<blockquote>
<p><strong>结论 2：</strong> 数据行越小，三层 B+ 树能存的数据就越多，甚至能过亿。</p>
</blockquote>
<hr>
<h3 id="5-现实中的误差fill-factor">5. 现实中的误差（Fill Factor）
</h3><p>上面的计算是理论最大值（所有页都填满 100%）。但在实际运行中：</p>
<ol>
<li>
<p><strong>页头页尾开销</strong>：每个页有 Header、Directory Slot 等元数据，大约占用几十到几百字节，不能全用来存数据。</p>
</li>
<li>
<p><strong>页填充率</strong>：InnoDB 不会把页填得满满当当，为了减少页分裂，通常填充率在 <strong>1/2 到 15/16</strong> 之间。如果频繁随机插入，页碎片化会导致填充率下降。</p>
</li>
</ol>
<p>如果按照 <strong>50%-75%</strong> 的利用率折算，通常认为三层树的舒适区确实就在 <strong>2000万</strong> 左右。一旦超过这个数量级，B+ 树可能分裂出第四层，导致磁盘 I/O 增加，查询性能轻微下降。</p>
<h2 id="事务的四大特性acid">事务的四大特性（ACID）
</h2><p>为了保证上述逻辑的严密性，数据库理论规定事务必须满足 ACID 四个特性，这经常在面试中被问到：</p>
<ol>
<li>
<p><strong>A - 原子性 (Atomicity)</strong>：</p>
<ul>
<li>
<p><strong>核心</strong>：要么全做，要么全不做。</p>
</li>
<li>
<p><em>实现靠 Undo Log（回滚日志）。</em></p>
</li>
</ul>
</li>
<li>
<p><strong>C - 一致性 (Consistency)</strong>：</p>
<ul>
<li><strong>核心</strong>：事务前后，数据必须符合逻辑（比如转账前后，两人的钱加起来总数不变）。</li>
</ul>
</li>
<li>
<p><strong>I - 隔离性 (Isolation)</strong>：</p>
<ul>
<li>
<p><strong>核心</strong>：多个事务并发执行时，互不干扰（这就是我们之前讨论的 RR、RC 隔离级别）。</p>
</li>
<li>
<p><em>实现靠 锁 + MVCC。</em></p>
</li>
</ul>
</li>
<li>
<p><strong>D - 持久性 (Durability)</strong>：</p>
<ul>
<li>
<p><strong>核心</strong>：事务一旦提交，数据就是永久的，哪怕下一秒服务器爆炸，重启后数据依然在。</p>
</li>
<li>
<p><em>实现靠 Redo Log（重做日志）。</em></p>
</li>
</ul>
</li>
</ol>
<h2 id="mysql的事务隔离级别">MySQL的事务隔离级别
</h2><h3 id="并发事务的三大问题">并发事务的三大问题
</h3><ol>
<li>
<p><strong>脏读 (Dirty Read)</strong>：事务 A 读到了事务 B <strong>未提交</strong>的数据。如果 B 回滚，A 读到的就是脏数据。</p>
</li>
<li>
<p><strong>不可重复读 (Non-repeatable Read)</strong>：事务 A 在同一个事务中两次读取同一行数据，结果不一样。这是因为在两次读取之间，事务 B <strong>修改或删除</strong>了该数据并提交了。</p>
</li>
<li>
<p><strong>幻读 (Phantom Read)</strong>：事务 A 在同一个事务中两次查询同一个范围，第二次发现多了一些数据。这是因为在两次查询之间，事务 B <strong>插入</strong>了新数据并提交了。</p>
</li>
</ol>
<h3 id="四种隔离级别详解">四种隔离级别详解
</h3><p>按照隔离程度从低到高排序：</p>
<h4 id="1-读未提交-read-uncommitted">1. 读未提交 (Read Uncommitted)
</h4><ul>
<li>
<p><strong>描述</strong>：这是最低的隔离级别。一个事务可以读取到另一个事务<strong>未提交</strong>的修改。</p>
</li>
<li>
<p><strong>现象</strong>：相当于“裸奔”，没有任何隔离。</p>
</li>
<li>
<p><strong>存在问题</strong>：脏读、不可重复读、幻读都会发生。</p>
</li>
<li>
<p><strong>应用场景</strong>：实际开发中极少使用。</p>
</li>
</ul>
<h4 id="2-读已提交-read-committed---rc">2. 读已提交 (Read Committed - RC)
</h4><ul>
<li>
<p><strong>描述</strong>：一个事务只能读取到已经<strong>提交</strong>的数据。</p>
</li>
<li>
<p><strong>实现原理</strong>：<strong>MVCC（多版本并发控制）</strong>。每次执行 <code>SELECT</code> 语句时，都会重新生成一个 Read View（一致性视图）。</p>
</li>
<li>
<p><strong>存在问题</strong>：解决了“脏读”，但可能发生“不可重复读”（因为每次 Select 都生成新视图，如果中间有人提交修改，你就能看到）。</p>
</li>
<li>
<p><strong>备注</strong>：这是大多数主流数据库（如 Oracle, PostgreSQL, SQL Server）的默认隔离级别，但不是 MySQL 的默认值。</p>
</li>
</ul>
<h4 id="3-可重复读-repeatable-read---rr--mysql-默认">3. 可重复读 (Repeatable Read - RR) —— <strong>MySQL 默认</strong>
</h4><ul>
<li>
<p><strong>描述</strong>：确保在同一个事务中，多次读取同样的数据结果是一样的。</p>
</li>
<li>
<p><strong>实现原理</strong>：<strong>MVCC</strong>。与 RC 不同的是，RR 级别下，Read View 是在<strong>事务启动后的第一次查询</strong>时生成的，之后一直复用这个视图。</p>
</li>
<li>
<p><strong>存在问题</strong>：解决了“脏读”和“不可重复读”。</p>
</li>
<li>
<p><strong>关于幻读</strong>：在标准 SQL 定义中，RR 是无法解决幻读的。但是，<strong>MySQL 的 InnoDB 引擎通过 MVCC + Next-Key Lock 技术，在 RR 级别下很大程度上避免了幻读</strong>（正如我上一个回答所解释的）。</p>
</li>
</ul>
<h4 id="4-串行化-serializable">4. 串行化 (Serializable)
</h4><ul>
<li>
<p><strong>描述</strong>：最高的隔离级别。它强制事务串行执行，通过强制对读取的数据行加锁（共享锁），避免了并发冲突。</p>
</li>
<li>
<p><strong>存在问题</strong>：解决了所有问题（脏读、不可重复读、幻读）。</p>
</li>
<li>
<p><strong>代价</strong>：并发性能极差，容易导致大量的超时和锁竞争。</p>
</li>
<li>
<p><strong>应用场景</strong>：只有在对数据一致性要求极高且并发量很小的场景下才会使用。</p>
</li>
</ul>
<hr>
<h3 id="隔离级别对比总结表">隔离级别对比总结表
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>隔离级别</strong></th>
          <th><strong>脏读</strong></th>
          <th><strong>不可重复读</strong></th>
          <th><strong>幻读</strong></th>
          <th><strong>性能</strong></th>
          <th><strong>备注</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Read Uncommitted</strong></td>
          <td>✅ 可能</td>
          <td>✅ 可能</td>
          <td>✅ 可能</td>
          <td>极高</td>
          <td>极少使用</td>
      </tr>
      <tr>
          <td><strong>Read Committed</strong> (RC)</td>
          <td>❌ 无</td>
          <td>✅ 可能</td>
          <td>✅ 可能</td>
          <td>高</td>
          <td>Oracle/PG 默认</td>
      </tr>
      <tr>
          <td><strong>Repeatable Read</strong> (RR)</td>
          <td>❌ 无</td>
          <td>❌ 无</td>
          <td>❌ (大部分解决)</td>
          <td>中</td>
          <td><strong>MySQL 默认</strong></td>
      </tr>
      <tr>
          <td><strong>Serializable</strong></td>
          <td>❌ 无</td>
          <td>❌ 无</td>
          <td>❌ 无</td>
          <td>低</td>
          <td>强制排队，性能差</td>
      </tr>
  </tbody>
</table></div>
<h2 id="为什么可重复读的情况下不能避免幻读">为什么可重复读的情况下不能避免幻读
</h2><p><strong>数据在被修改（Update/Delete）的时候，必须基于“最新”的版本进行，而不能基于“历史”版本。</strong></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>时间点</strong></th>
          <th><strong>事务 A</strong></th>
          <th><strong>事务 B</strong></th>
          <th><strong>现象/旁白</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>1</td>
          <td><code>BEGIN;</code> <br> <code>SELECT * FROM users WHERE id = 5;</code> <br> <strong>结果：Empty (空)</strong></td>
          <td></td>
          <td>事务 A 确认 id=5 还没人用。</td>
      </tr>
      <tr>
          <td>2</td>
          <td></td>
          <td><code>BEGIN;</code> <br> <code>INSERT INTO users (id, name) VALUES (5, '小明');</code> <br> <code>COMMIT;</code></td>
          <td>事务 B 抢先插入了 id=5 并提交。</td>
      </tr>
      <tr>
          <td>3</td>
          <td><code>SELECT * FROM users WHERE id = 5;</code> <br> <strong>结果：Empty (空)</strong></td>
          <td></td>
          <td><strong>MVCC 生效</strong>。事务 A 依然看不到小明。一切看似正常。</td>
      </tr>
      <tr>
          <td>4</td>
          <td><code>UPDATE users SET name = '被修改' WHERE id = 5;</code> <br> <strong>结果：Query OK, 1 row affected</strong></td>
          <td></td>
          <td><strong>关键点来了！</strong> <br> Update 是“当前读”，它能看到最新的提交。它不仅修改成功了，还把这条记录的“版本号”改成了事务 A 自己的。</td>
      </tr>
      <tr>
          <td>5</td>
          <td><code>SELECT * FROM users WHERE id = 5;</code> <br> <strong>结果：id=5, name=&lsquo;被修改&rsquo;</strong></td>
          <td></td>
          <td><strong>【幻读发生】</strong><br> 事务 A 吓死了：“我刚才查还没有 id=5，怎么我一更新，它就突然冒出来，还被我改了？”</td>
      </tr>
  </tbody>
</table></div>
<p>注意，在第二步的时候，事务2已经插入并且提交了，这个时候数据库的内容发生了变化，后续步骤4进行update的时候就得根据最新的数据进行update，然后更新成功，并且，</p>
<p>假设：</p>
<ul>
<li>
<p><strong>事务 A</strong> 的 ID = <strong>100</strong>。</p>
</li>
<li>
<p><strong>事务 B</strong> 的 ID = <strong>200</strong>。</p>
</li>
</ul>
<h3 id="幻读示例自己修改或插入的数据trx_id会变为自己的可见">幻读示例（自己修改或插入的数据，trx_id会变为自己的，可见）
</h3><h4 id="阶段-1事务-a-开启生成-readview">阶段 1：事务 A 开启，生成 ReadView
</h4><ul>
<li>
<p>事务 A 执行第一条 SELECT。</p>
</li>
<li>
<p>生成 ReadView，记录当前活跃事务。此时系统里只有 A。</p>
</li>
<li>
<p><strong>ReadView 只要生成了，在 RR 级别下就永远不会变了。</strong></p>
</li>
</ul>
<h4 id="阶段-2事务-b-插入并提交">阶段 2：事务 B 插入并提交
</h4><ul>
<li>
<p>事务 B 插入 <code>id=5</code>。</p>
</li>
<li>
<p>这行数据现在的状态是：<code>{id: 5, name: '小明', trx_id: 200}</code>。</p>
</li>
<li>
<p>事务 B 提交。</p>
</li>
</ul>
<h4 id="阶段-3事务-a-第一次查询-id5">阶段 3：事务 A 第一次查询 <code>id=5</code>
</h4><ul>
<li>
<p>事务 A 拿着 ReadView 来看这行数据。</p>
</li>
<li>
<p>发现数据的 <code>trx_id</code> 是 <strong>200</strong>。</p>
</li>
<li>
<p>ReadView 判断：200 是在我（100）开启之后才进来的“将来的人”。</p>
</li>
<li>
<p><strong>结论</strong>：不可见。</p>
</li>
</ul>
<h4 id="阶段-4事务-a-执行-update关键转折点">阶段 4：事务 A 执行 UPDATE（关键转折点！）
</h4><ul>
<li>
<p><strong>动作</strong>：<code>UPDATE users SET name = '被修改' WHERE id = 5;</code></p>
</li>
<li>
<p><strong>当前读</strong>：正如之前所说，UPDATE 也是一种读，但它是“当前读”。它不看 ReadView，直接看物理磁盘。它看到了 <code>trx_id=200</code> 的数据（因为 B 已经提交，物理上存在）。</p>
</li>
<li>
<p><strong>修改数据</strong>：事务 A 把数据改了。</p>
</li>
<li>
<p><strong>打标签</strong>：这是最重要的一步！<strong>事务 A 把这行数据的 <code>trx_id</code> 更新成了自己的 ID（100）。</strong></p>
</li>
<li>
<p>现在的行数据变成了：<code>{id: 5, name: '被修改', trx_id: 100}</code>。</p>
</li>
</ul>
<h4 id="阶段-5事务-a-第二次查询-id5">阶段 5：事务 A 第二次查询 <code>id=5</code>
</h4><ul>
<li>
<p>事务 A 再次执行 SELECT。</p>
</li>
<li>
<p><strong>ReadView 变了吗？</strong> 没有，还是那个旧的 ReadView。</p>
</li>
<li>
<p><strong>数据变了吗？</strong> 变了。</p>
</li>
<li>
<p>事务 A 再次检查可见性：</p>
<ul>
<li>
<p>这行数据的 <code>trx_id</code> 是多少？ -&gt; <strong>100</strong>。</p>
</li>
<li>
<p>当前事务 A 的 ID 是多少？ -&gt; <strong>100</strong>。</p>
</li>
<li>
<p><strong>触发规则 1</strong>：<code>trx_id</code> 等于我自己。</p>
</li>
<li>
<p><strong>结论</strong>：<strong>可见！</strong></p>
</li>
</ul>
</li>
</ul>
<p>你之所以能看到，是因为你通过 <code>UPDATE</code> 操作，把这行数据的所有权**“抢”**过来了。</p>
<ul>
<li>
<p><strong>修改前</strong>：这行数据属于事务 B（<code>trx_id=200</code>），对你是“未来数据”，不可见。</p>
</li>
<li>
<p><strong>修改后</strong>：这行数据属于事务 A（<code>trx_id=100</code>），对你是“自家数据”，<strong>无条件可见</strong>。</p>
</li>
</ul>
<h2 id="readview-到底存了什么">ReadView 到底存了什么？
</h2><p>当你第一次执行 <code>SELECT * FROM user</code> 时，生成的 ReadView 是一张<strong>黑名单</strong>，长这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;m_ids&#34;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="mi">102</span><span class="p">],</span>   <span class="c1">// 当前全数据库里，所有还没提交的事务 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;min_trx_id&#34;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>          <span class="c1">// 最小活跃 ID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="nt">&#34;max_trx_id&#34;</span><span class="p">:</span> <span class="mi">103</span>           <span class="c1">// 下一个要分配的 ID（水位线）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>请注意：</strong> 这个列表里完全没有提 <code>user</code> 表或 <code>student</code> 表的名字。它只规定了<strong>谁是老数据（可见），谁是活跃数据（不可见）</strong>。</p>
<p>这个规则对<strong>全库所有表</strong>通用。</p>
<h3 id="mvcc简单的流程">MVCC简单的流程
</h3><p>事务在第一次select的时候会去检查当前活跃事务，然后会查看下一个要分配的事务id，然后记录下来，后面查询的时候会先去查询当前行数据的trx_id，查看数据的trx_id如果小于当前事务的id就应该<strong>直接使用这条数据</strong>，如果大于自己的事务id，就去查undo log，顺着undolog版本链找到真正自己能看到的数据，然后修改查询得到的数据。</p>
<h2 id="mysql的锁">MySQL的锁
</h2><h3 id="共享锁">共享锁
</h3><p>在sql语句末尾加上for share代表共享锁，所有事务都可以读，但是不能修改，直至事务提交</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">uploaded_file</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1981221658045493248</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">share</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="排他锁">排他锁
</h3><p>在sql语句末尾加上for update代表排他锁，其他事务不能修改，也不能读。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">uploaded_file</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1981221658045493248</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">update</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="表锁">表锁
</h3><ul>
<li>
<p><strong>定义</strong>：最基本的锁策略，开销最小。它会锁定整张表。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p><strong>无死锁</strong>：因为一次性获取所有需要的锁。</p>
</li>
<li>
<p><strong>并发度低</strong>：一个用户在写，其他用户都不能读写。</p>
</li>
</ul>
</li>
<li>
<p><strong>适用场景</strong>：主要由 MyISAM 引擎使用；InnoDB 在特定情况下（如没有索引或手动指定 <code>LOCK TABLES</code>）也会用到，但通常尽量避免。</p>
</li>
</ul>
<h3 id="意向锁">意向锁
</h3><ul>
<li>
<p><strong>痛点</strong>：假设事务 A 锁住了表中的<strong>某一行</strong>（行锁），此时事务 B 想申请<strong>整个表</strong>的写锁（表锁）。事务 B 怎么知道表里有没有人正在改数据？它必须遍历每一行去检查，效率极低。</p>
</li>
<li>
<p><strong>定义</strong>：<strong>意向锁是表级锁</strong>。</p>
<ul>
<li>
<p>当事务 A 想要给某一行加锁时，必须先给表加一个“意向锁”。</p>
</li>
<li>
<p>这就像在写字楼门口挂个牌子：“楼里有人（意向锁）”。</p>
</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：事务 B 看到门口有“意向锁”的牌子，就知道表里有人在忙，直接等待，不用进去逐个房间（行）检查了。它主要用于<strong>快速判断表锁和行锁的冲突</strong>。</p>
</li>
</ul>
<h3 id="行锁">行锁
</h3><ul>
<li>
<p><strong>定义</strong>：InnoDB 的核心特性。只锁定被操作的那一行数据。</p>
</li>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p><strong>并发度高</strong>：多个人可以同时修改同一张表的不同行。</p>
</li>
<li>
<p><strong>开销大</strong>：需要加锁、解锁，且容易发生<strong>死锁</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>关键点</strong>：<strong>InnoDB 的行锁是加在索引上的</strong>。如果你查询时没有用到索引，InnoDB 会退化为锁定整张表（虽然实现机制上是把所有行都锁了），导致并发性能大跌。</p>
</li>
</ul>
<h3 id="间隙锁">间隙锁
</h3><ul>
<li>
<p><strong>含义</strong>：只锁住两个记录之间的**“缝隙”**，<strong>不包含</strong>记录本身。</p>
</li>
<li>
<p><strong>锁住范围</strong>：<code>(10, 20)</code> —— 指的是大于 10 且小于 20 的范围。</p>
</li>
<li>
<p><strong>作用</strong>：<strong>纯粹是为了防止插入</strong>。别人不能在这个范围内 <code>INSERT</code> 任何数据（比如插 15）。但他如果要修改 <code>id=20</code> 这行数据，Gap Lock 是不管的。</p>
</li>
</ul>
<h3 id="next-key-lock">Next-Key Lock
</h3><p>假设数据库表中只有三行数据：<code>id = 10, 20, 30</code>。</p>
<ul>
<li>
<p><strong>含义</strong>：锁住一段间隙 <strong>+</strong> 锁住间隙右边的那个记录。</p>
</li>
<li>
<p><strong>锁住范围</strong>：<code>(10, 20]</code> —— <strong>左开右闭区间</strong>。</p>
</li>
<li>
<p><strong>组成</strong>：即锁住了 <code>(10, 20)</code> 这个缝隙，也锁住了 <code>20</code> 这个记录。</p>
</li>
<li>
<p><strong>作用</strong>：既不准你在缝隙里插数据（防幻读），也不准你修改右边那个记录。</p>
</li>
</ul>
<p>$Next\text{-}Key \ Lock = Gap \ Lock + Record \ Lock$</p>
<h3 id="mdl锁">MDL锁
</h3><ul>
<li>
<p><strong>定义</strong>：它不是用来锁数据的，而是用来锁**表结构（Schema）**的。</p>
</li>
<li>
<p><strong>触发机制</strong>（系统自动控制，用户无需显式调用）：</p>
<ul>
<li>
<p><strong>MDL 读锁</strong>：当你对表进行增删改查（DML）时，自动加 MDL 读锁。</p>
</li>
<li>
<p><strong>MDL 写锁</strong>：当你对表结构进行修改（DDL，如 <code>ALTER TABLE</code>）时，自动加 MDL 写锁。</p>
</li>
</ul>
</li>
<li>
<p><strong>互斥关系</strong>：</p>
<ul>
<li>
<p>读锁和读锁不互斥（大家可以一起查数据）。</p>
</li>
<li>
<p><strong>读写互斥、写写互斥</strong>。这意味着，如果有长事务正在查询数据（持有 MDL 读锁），你此时想给表加个字段（申请 MDL 写锁），会被阻塞。</p>
</li>
</ul>
</li>
<li>
<p><strong>危险场景（MDL 风暴）</strong>：</p>
<ol>
<li>
<p>Session A 开启事务查数据（持有 MDL 读）。</p>
</li>
<li>
<p>Session B 想加字段（申请 MDL 写，被阻塞）。</p>
</li>
<li>
<p><strong>Session C 及其后的所有查询</strong>（申请 MDL 读），因为写锁优先级通常高于读锁，或者写锁在排队，导致后续所有查询全部堵塞。</p>
</li>
</ol>
</li>
<li>
<p><em>结果</em>：数据库线程瞬间爆满，导致宕机。</p>
</li>
</ul>
<h2 id="索引下推是什么">索引下推是什么？
</h2><h3 id="mysql-处理-sql-语句时主要分为两层">MySQL 处理 SQL 语句时，主要分为两层：
</h3><ol>
<li>
<p><strong>Server 层（服务器层）：</strong> 负责解析 SQL、优化器生成执行计划、调用存储引擎接口、并处理最终的数据过滤（<code>WHERE</code> 条件判断）。</p>
</li>
<li>
<p><strong>Storage Engine 层（存储引擎层，如 InnoDB）：</strong> 负责真正的数据存储、提取，通过索引在磁盘上找数据。</p>
</li>
</ol>
<p><strong>“下推”的意思是：</strong> 把原本只能在 Server 层做的事情，<strong>推给</strong> 存储引擎层去做。</p>
<h3 id="场景复盘">场景复盘
</h3><p>我们使用你的例子：</p>
<ul>
<li>
<p><strong>表结构：</strong> <code>user</code> 表，有列 <code>id</code> (主键), <code>name</code>, <code>age</code>, <code>address</code> 等。</p>
</li>
<li>
<p><strong>索引：</strong> 联合索引 <code>idx_name_age (name, age)</code>。</p>
</li>
<li>
<p><strong>SQL：</strong></p>
<p>SQL</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SELECT * FROM user WHERE name LIKE &#39;王%&#39; AND age = 20;
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>(注意：这里是 <code>SELECT *</code>，意味着必须回表拿到 <code>address</code> 等其他字段，不能仅靠覆盖索引)</em></p>
</li>
</ul>
<h4 id="为什么这个场景特殊">为什么这个场景特殊？
</h4><p>根据<strong>最左前缀原则</strong>：</p>
<ol>
<li>
<p><code>name LIKE '王%'</code> 是范围查询。索引能帮我们快速定位到所有姓“王”的人的<strong>起始位置</strong>。</p>
</li>
<li>
<p>但是，一旦使用了范围查询（Range），索引<strong>后续的列</strong>（这里是 <code>age</code>）就无法用于<strong>定位</strong>（Seek）了。</p>
<ul>
<li>
<p>索引里的数据排序是：先按 name 排，name 相同才按 age 排。</p>
</li>
<li>
<p>对于 <code>王五</code> 和 <code>王六</code>，他们的 age 是无序的（相对于整个“王%”区间），所以引擎必须扫描所有姓王的数据。</p>
</li>
</ul>
</li>
</ol>
<p>虽然无法用来<strong>定位</strong>，但 <code>age</code> 的值<strong>确实存在于索引树的叶子节点中</strong>。ICP 的核心就在于是否利用了这个已有的数据。</p>
<h3 id="详细对比无-icp-vs-有-icp">详细对比：无 ICP vs 有 ICP
</h3><p>假设数据库里有 4 条记录，索引结构 <code>(name, age)</code> 如下：</p>
<ol>
<li>
<p>(<code>王五</code>, 10) —— 主键 ID: 1</p>
</li>
<li>
<p>(<code>王六</code>, 20) —— 主键 ID: 2 &lt;&ndash; <strong>目标数据</strong></p>
</li>
<li>
<p>(<code>王七</code>, 30) —— 主键 ID: 3</p>
</li>
<li>
<p>(<code>张三</code>, 20) —— 主键 ID: 4</p>
</li>
</ol>
<h4 id="-阶段一没有-icp-mysql-56-之前">❌ 阶段一：没有 ICP (MySQL 5.6 之前)
</h4><p>在没有 ICP 的时候，存储引擎认为自己的任务就是<strong>找所有 <code>name</code> 以“王”开头的数据</strong>。它会忽略 <code>age = 20</code> 这个条件，因为按老规矩，范围查询后的列“失效”了。</p>
<p><strong>执行流程：</strong></p>
<ol>
<li>
<p><strong>Server 层</strong>告诉 <strong>InnoDB</strong>：“给我找所有 <code>name LIKE '王%'</code> 的记录。”</p>
</li>
<li>
<p><strong>InnoDB</strong> 在索引树上找到第一条 <code>(王五, 10)</code>。</p>
<ul>
<li>
<p>InnoDB 此时<strong>无视</strong> <code>age=10</code> 不等于 20 这个事实。</p>
</li>
<li>
<p>InnoDB 拿着 ID: 1 去聚簇索引<strong>回表</strong>，取出整行数据。</p>
</li>
<li>
<p>InnoDB 把整行数据返回给 <strong>Server 层</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>Server 层</strong>拿到数据，进行 <code>WHERE</code> 判断：<code>age</code> 是 20 吗？</p>
<ul>
<li>发现是 10，<strong>丢弃</strong>。</li>
</ul>
</li>
<li>
<p><strong>InnoDB</strong> 继续找下一条 <code>(王六, 20)</code>。</p>
<ul>
<li>回表，取整行，返回给 Server。</li>
</ul>
</li>
<li>
<p><strong>Server 层</strong> 判断：<code>age</code> 是 20 吗？</p>
<ul>
<li>是，<strong>保留</strong>。</li>
</ul>
</li>
<li>
<p><strong>InnoDB</strong> 继续找下一条 <code>(王七, 30)</code>。</p>
<ul>
<li>回表，取整行，返回给 Server。</li>
</ul>
</li>
<li>
<p><strong>Server 层</strong> 判断：<code>age</code> 是 20 吗？</p>
<ul>
<li>不是，<strong>丢弃</strong>。</li>
</ul>
</li>
</ol>
<p><strong>结果：</strong> 进行了 <strong>3 次回表</strong>，Server 层做了 3 次判断，最后只得到了 1 条数据。<strong>做了很多无用功（多回了 2 次表）。</strong></p>
<hr>
<h4 id="-阶段二开启-icp-mysql-56-及以后">✅ 阶段二：开启 ICP (MySQL 5.6 及以后)
</h4><p>MySQL 意识到：<em>“嘿，InnoDB 兄弟，虽然你正在扫描索引，但我需要的 <code>age</code> 其实就在你手里的索引节点上。你能不能顺便帮我看一眼？如果 <code>age</code> 不对，你就别回表了，直接看下一个。”</em></p>
<p>这就是 <strong>Index Condition Pushdown</strong>：把 <code>age = 20</code> 这个条件<strong>下推</strong>到存储引擎层。</p>
<p><strong>执行流程：</strong></p>
<ol>
<li>
<p><strong>Server 层</strong>告诉 <strong>InnoDB</strong>：“给我找 <code>name LIKE '王%'</code> 的记录，<strong>同时，如果 <code>age</code> 不等于 20，你就别给我了</strong>。”</p>
</li>
<li>
<p><strong>InnoDB</strong> 在索引树上找到第一条 <code>(王五, 10)</code>。</p>
<ul>
<li>
<p>InnoDB <strong>直接检查索引上的值</strong>：<code>age</code> 是 10。</p>
</li>
<li>
<p>不符合 <code>age = 20</code>。</p>
</li>
<li>
<p><strong>InnoDB 直接跳过</strong>（不回表，不返回给 Server）。</p>
</li>
</ul>
</li>
<li>
<p><strong>InnoDB</strong> 继续找下一条 <code>(王六, 20)</code>。</p>
<ul>
<li>
<p>检查索引：<code>age</code> 是 20。</p>
</li>
<li>
<p>符合！</p>
</li>
<li>
<p>InnoDB 拿着 ID: 2 <strong>回表</strong>，取出整行数据，返回给 Server。</p>
</li>
</ul>
</li>
<li>
<p><strong>Server 层</strong> 再次确认（兜底），保留数据。</p>
</li>
<li>
<p><strong>InnoDB</strong> 继续找下一条 <code>(王七, 30)</code>。</p>
<ul>
<li>
<p>检查索引：<code>age</code> 是 30。</p>
</li>
<li>
<p>不符合，<strong>直接跳过</strong>。</p>
</li>
</ul>
</li>
</ol>
<p><strong>结果：</strong> 只进行了 <strong>1 次回表</strong>。I/O 操作大幅减少，性能提升。</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>特性</strong></th>
          <th><strong>判断 age=20 的位置</strong></th>
          <th><strong>处理 (王五, 10)</strong></th>
          <th><strong>处理 (王六, 20)</strong></th>
          <th><strong>处理 (王七, 30)</strong></th>
          <th><strong>总回表次数</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>无 ICP</strong></td>
          <td><strong>Server 层</strong> (回表之后)</td>
          <td>回表 -&gt; 丢弃</td>
          <td>回表 -&gt; 保留</td>
          <td>回表 -&gt; 丢弃</td>
          <td>3 次 (慢)</td>
      </tr>
      <tr>
          <td><strong>有 ICP</strong></td>
          <td><strong>存储引擎层</strong> (回表之前)</td>
          <td><strong>索引层直接丢弃</strong></td>
          <td>回表 -&gt; 保留</td>
          <td><strong>索引层直接丢弃</strong></td>
          <td><strong>1 次</strong> (快)</td>
      </tr>
  </tbody>
</table></div>
<h3 id="怎么看有没有用到-icp">怎么看有没有用到 ICP？
</h3><p>你可以使用 <code>EXPLAIN</code> 命令查看执行计划。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;王%&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>如果输出的 <strong>Extra</strong> 列中包含：<code>Using index condition</code></p>
</li>
<li>
<p>这就说明 <strong>ICP 生效了</strong>。</p>
</li>
</ul>
<p><em>(注：如果 Extra 是 <code>Using where</code>，说明在 Server 层过滤；如果是 <code>Using index</code>，说明是覆盖索引，不需要回表，性能更好)</em></p>
<h3 id="正常的联合索引完美匹配">正常的联合索引（完美匹配）
</h3><p>假设索引还是 <code>(name, age)</code>。 <strong>SQL:</strong> <code>SELECT * FROM user WHERE name = '王五' AND age = 20;</code></p>
<p>在这种情况下，都是<strong>等值查询</strong>，符合最左前缀原则。</p>
<ul>
<li>
<p><strong>怎么执行？</strong> InnoDB 里的 B+ 树是严格排序的：先按 <code>name</code> 排，<code>name</code> 此时固定是 &lsquo;王五&rsquo;，那么里面的数据就是严格按 <code>age</code> 排序的。
InnoDB 不需要“先找王五，再遍历过滤 age”，而是直接根据 B+ 树的算法，<strong>一次性跳（Seek）</strong> 到 <code>(王五, 20)</code> 这个节点的位置。</p>
</li>
<li>
<p><strong>谁在做？</strong> <strong>存储引擎 (InnoDB)</strong>。它利用 B+ 树结构直接定位数据。</p>
</li>
<li>
<p><strong>Server 层在干嘛？</strong> Server 层只是给 InnoDB 下达了一个指令：“把 <code>name='王五' AND age=20</code> 的数据给我。”
InnoDB 说：“好的，我通过索引直接定位到了，这是数据。”
Server 层拿到数据，甚至不需要再判断一次（但在代码实现逻辑上可能会做双重确认），直接发给客户端。</p>
</li>
</ul>
<hr>
<h3 id="索引下推-icp范围查询导致断档">索引下推 ICP（范围查询导致断档）
</h3><p>这是我们刚才聊的场景。 <strong>SQL:</strong> <code>SELECT * FROM user WHERE name LIKE '王%' AND age = 20;</code></p>
<ul>
<li>
<p><strong>怎么执行？</strong> 因为 <code>name</code> 是范围，B+ 树只能帮你定位到“姓王的开始了”和“姓王的结束了”。在这个范围内，<code>age</code> 是乱序的（相对全局而言）。
InnoDB <strong>不能</strong>直接跳到 <code>age=20</code> 的位置，只能从“王”的第一个数据开始<strong>扫描</strong>。</p>
</li>
<li>
<p><strong>ICP 的作用：</strong> 在扫描过程中，InnoDB 顺便看一眼索引里的 <code>age</code>。如果不符合，就不回表了。</p>
</li>
<li>
<p><strong>谁在做？</strong> 还是 <strong>存储引擎 (InnoDB)</strong>。但是这次它不是“直接定位”，而是“扫描 + 顺便过滤”。</p>
</li>
</ul>
<h3 id="server层处理无法下推的条件">Server层处理“无法下推”的条件
</h3><p>这是 Server 层更重要的工作。如果 SQL 中包含<strong>不在索引里</strong>的字段条件，InnoDB 是无能为力的，必须由 Server 层来做。</p>
<p>举个例子：</p>
<ul>
<li>
<p><strong>索引：</strong> <code>(name, age)</code></p>
</li>
<li>
<p><strong>SQL：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;王%&#39;</span><span class="w">    </span><span class="c1">-- 索引前缀（用于范围扫描）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w">          </span><span class="c1">-- 索引下推（ICP 在 InnoDB 过滤）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;北京&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 索引里没有（Server 层过滤）
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>详情见下方流程</p>
<h2 id="索引下推查询的全流程">索引下推查询的全流程
</h2><h3 id="场景设定">场景设定
</h3><ul>
<li>
<p><strong>表结构：</strong> <code>user (id, name, age, address)</code></p>
</li>
<li>
<p><strong>索引：</strong> <code>idx_name_age (name, age)</code> —— 联合二级索引</p>
</li>
<li>
<p><strong>SQL 语句：</strong></p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;王%&#39;</span><span class="w">    </span><span class="c1">-- 索引范围查询 (Range)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="w">          </span><span class="c1">-- 索引下推过滤 (ICP)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;北京&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">-- 普通条件 (Server 层过滤)
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<hr>
<h3 id="2-详细执行流程-pipeline">2. 详细执行流程 (Pipeline)
</h3><p>这个流程就像一个<strong>漏斗</strong>，每经过一层，数据就变少一点，性能就越高。</p>
<h4 id="第一步server-层准备阶段">第一步：Server 层（准备阶段）
</h4><ol>
<li>
<p><strong>解析与优化：</strong> MySQL 优化器分析 SQL，发现可以使用 <code>idx_name_age</code> 索引。</p>
</li>
<li>
<p><strong>生成计划：</strong> 虽然 <code>name</code> 是范围查询导致 <code>age</code> 无法用于<strong>定位</strong>，但优化器决定开启 <strong>ICP</strong>。</p>
<ul>
<li><em>标志：</em> EXPLAIN 中的 Extra 显示 <code>Using index condition</code>。</li>
</ul>
</li>
<li>
<p><strong>下发指令：</strong> Server 层告诉 InnoDB：“去 <code>idx_name_age</code> 索引里找 <code>name</code> 以 &lsquo;王&rsquo; 开头的数据。<strong>同时，把 <code>age = 20</code> 这个条件带上，如果不满足就别给我了。</strong>”</p>
</li>
</ol>
<h4 id="第二步innodb-存储引擎层icp-核心阶段">第二步：InnoDB 存储引擎层（ICP 核心阶段）
</h4><ol start="4">
<li>
<p><strong>定位游标：</strong> InnoDB 在二级索引 B+ 树上，找到第一个 <code>name</code> 匹配 <code>'王%'</code> 的叶子节点记录（假设是 <code>王五, 10岁, ID:1</code>）。</p>
</li>
<li>
<p><strong>索引内过滤 (ICP Check)：</strong></p>
<ul>
<li>
<p>InnoDB <strong>不急着回表</strong>。</p>
</li>
<li>
<p>它先看手头索引元组里的 <code>age</code>。</p>
</li>
<li>
<p><strong>情况 A（不匹配）：</strong> 发现 <code>age</code> 是 10（不等于 20）。</p>
<ul>
<li><strong>动作：</strong> 直接忽略该条记录，指针移向下一条。<strong>（省下一次回表 I/O）</strong></li>
</ul>
</li>
<li>
<p><strong>情况 B（匹配）：</strong> 指针移向下一条（假设是 <code>王六, 20岁, ID:2</code>）。</p>
<ul>
<li>检查 <code>age</code> 是 20。符合条件！准备回表。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第三步innodb-存储引擎层回表阶段">第三步：InnoDB 存储引擎层（回表阶段）
</h4><ol start="6">
<li>
<p><strong>读取主键：</strong> 拿到符合 ICP 条件的记录的主键 <code>ID:2</code>。</p>
</li>
<li>
<p><strong>回表 (Table Lookup)：</strong> 拿着 <code>ID:2</code> 去**聚簇索引（主键索引）**树里查找。</p>
</li>
<li>
<p><strong>提取行数据：</strong> 从聚簇索引叶子节点里读取<strong>完整的行数据</strong>（包含 <code>name, age, address</code> 等所有列）。</p>
</li>
<li>
<p><strong>返回数据：</strong> 把这行完整数据返回给 Server 层。</p>
</li>
</ol>
<h4 id="第四步server-层最终兜底阶段">第四步：Server 层（最终兜底阶段）
</h4><ol start="10">
<li>
<p><strong>接收数据：</strong> Server 层拿到 <code>王六</code> 的完整行数据。</p>
</li>
<li>
<p><strong>二次确认 (Double Check)：</strong> 尽管 InnoDB 过滤过，Server 层依然会校验 <code>name LIKE '王%'</code> 和 <code>age = 20</code>（流程规范）。</p>
</li>
<li>
<p><strong>补充过滤：</strong> Server 层检查 SQL 中剩下的、没法下推的条件 —— <code>address = '北京'</code>。</p>
<ul>
<li>
<p>如果 <code>王六</code> 的 address 是 &lsquo;上海&rsquo; -&gt; <strong>丢弃</strong>。</p>
</li>
<li>
<p>如果 <code>王六</code> 的 address 是 &lsquo;北京&rsquo; -&gt; <strong>放入结果集</strong>。</p>
</li>
</ul>
</li>
<li>
<p><strong>发送结果：</strong> 将最终通过的记录发送给客户端。</p>
</li>
</ol>
<hr>
<h3 id="3-流程总结图解">3. 流程总结图解
</h3><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>步骤</strong></th>
          <th><strong>所在层级</strong></th>
          <th><strong>处理内容</strong></th>
          <th><strong>数据状态 (示例)</strong></th>
          <th><strong>关键作用</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>1</strong></td>
          <td><strong>Server</strong></td>
          <td>生成执行计划</td>
          <td>指令：<code>Scan idx, Filter age=20</code></td>
          <td>开启 ICP</td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td><strong>InnoDB</strong></td>
          <td><strong>扫描二级索引</strong></td>
          <td><code>(王五, 10)</code> -&gt; ❌ <strong>直接丢弃</strong><br><code>(王六, 20)</code> -&gt; ✅ <strong>保留</strong></td>
          <td><strong>ICP 核心：减少回表</strong></td>
      </tr>
      <tr>
          <td><strong>3</strong></td>
          <td><strong>InnoDB</strong></td>
          <td><strong>回表 (聚簇索引)</strong></td>
          <td>拿 ID:2 去找完整行数据</td>
          <td>最耗时的 I/O 操作</td>
      </tr>
      <tr>
          <td><strong>4</strong></td>
          <td><strong>Server</strong></td>
          <td><strong>最终过滤</strong></td>
          <td>检查 <code>address='北京'</code></td>
          <td>处理非索引列逻辑</td>
      </tr>
  </tbody>
</table></div>
<h2 id="priorityqueue的相关api">PriorityQueue的相关API
</h2><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>操作</strong></th>
          <th><strong>复杂度 (Time Complexity)</strong></th>
          <th><strong>备注</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>offer() / add()</code></td>
          <td>$O(\log N)$</td>
          <td>插入操作，需要维护堆的属性。</td>
      </tr>
      <tr>
          <td><code>poll() / remove()</code></td>
          <td>$O(\log N)$</td>
          <td>移除最小/最大元素，需要重新堆化。</td>
      </tr>
      <tr>
          <td><code>peek() / element()</code></td>
          <td>$O(1)$</td>
          <td>仅查看堆顶元素。</td>
      </tr>
      <tr>
          <td><code>remove(Object o)</code></td>
          <td>$O(N)$</td>
          <td>移除任意元素，需要线性搜索。</td>
      </tr>
  </tbody>
</table></div>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th><strong>方法</strong></th>
          <th><strong>签名</strong></th>
          <th><strong>描述</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>int size()</code></td>
          <td><code>public int size()</code></td>
          <td>返回队列中元素的数量。</td>
      </tr>
      <tr>
          <td><code>void clear()</code></td>
          <td><code>public void clear()</code></td>
          <td>移除队列中的所有元素。</td>
      </tr>
      <tr>
          <td><code>boolean isEmpty()</code></td>
          <td><code>public boolean isEmpty()</code></td>
          <td>如果队列不包含任何元素，则返回 <code>true</code>。</td>
      </tr>
      <tr>
          <td><code>Comparator&lt;? super E&gt; comparator()</code></td>
          <td><code>public Comparator&lt;? super E&gt; comparator()</code></td>
          <td>返回用于对此队列中元素进行排序的比较器，或者返回 <code>null</code>（如果使用自然顺序）。</td>
      </tr>
      <tr>
          <td><code>Object[] toArray()</code></td>
          <td><code>public Object[] toArray()</code></td>
          <td>返回包含队列中所有元素的数组。<strong>注意：返回的数组不保证是排序的。</strong></td>
      </tr>
  </tbody>
</table></div>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="">
    <a href="/p/redis%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E6%88%98/">
        
        

        <div class="article-details">
            <h2 class="article-title">Redis学习与实战</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/redis%E9%AB%98%E7%BA%A7%E7%AF%87/">
        
        

        <div class="article-details">
            <h2 class="article-title">Redis高级篇</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/javaweb%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/">
        
        

        <div class="article-details">
            <h2 class="article-title">JavaWeb部分笔记</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 LuciusWan
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
