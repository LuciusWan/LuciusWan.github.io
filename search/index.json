[{"content":"Redis学习与实战 缓存穿透 缓存穿透是指客户端请求的数据,Redis和Mysql里面都没有,缓存永远不会生效,如果客户端一直请求相同的id,请求就会一直到达数据库,给数据库上压力了.\n解决方案1:缓存空对象 缓存空对象:如果客户端请求找不到的数据,就把找不到的数据缓存到Redis里,并且设置过期时间,在一定时间内,客户端的空对象请求不会经过Mysql\n缺点:有额外内存消耗,如果管理端新增对象和空对象id相同,可能造成缓存与数据库内容不一致\n解决缓存穿透的业务逻辑: 对应的java逻辑代码: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public Result getByIdRedis(Long id) { String shop= stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY+id); //查询到对应的value,并且这个value不是\u0026#34;\u0026#34;,则店铺存在,直接返回 if(shop!=null\u0026amp;\u0026amp;!\u0026#34;\u0026#34;.equals(shop)){ Shop shopRedis= JSONUtil.toBean(shop,Shop.class); return Result.ok(shopRedis); } //店铺value不等于null,但是为\u0026#34;\u0026#34;，说明缓存和数据库中都没有,直接返回不存在信息 if(shop!=null){ return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } Shop shop1= getById(id); //数据没查到,说明这个店铺id不存在,这次缓存穿透了,但是可以把空信息写入redis if(shop1==null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,\u0026#34;\u0026#34;,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } String json= JSON.toJSONString(shop1); //查询到店铺,返回店铺信息,并且把信息写入Redis if(shop1!=null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,json,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return Result.ok(shop1); } return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } 解决方案2:布隆过滤 缓存穿透后,穿透的信息进入布隆过滤器,如果再进行查询,先查询布隆过滤器,如果这个id是穿透信息,就直接拒绝查询\n其他解决方案: 做好热点参数的限流\n加强用户权限校验\n缓存雪崩 缓存雪崩是指大量数据同时到期,或者Redis服务直接宕机,大量请求涌入Mysql)\n简单解决办法 把数据存储进Redis的时候直接随机过期时间存储\njava代码如下（其实就是生成随机数) 1 2 3 4 5 private Long cacheAvalanche(){ Random random=new Random(); Long number=random.nextInt(11)+20L; return number; } 其他高级解决方案: Redis集群,分布式部署\n给缓存业务添加降级限流策略,如果redis集体驾崩,就直接拒绝大量请求,防止MySQL数据库压力过大\n给业务添加多级缓存\n缓存击穿 一个热点数据过期,大量线程同时访问,每个线程都选择查询完Redis后查询数据库,导致数据库压力剧增\n解决方案1:互斥锁 使用Redis的setnx作为互斥条件,所有线程同时设置一个键值对,只有一个线程可以设置成功,并且操作数据库,写入缓存,写完后释放锁资源\n1 2 3 4 5 6 7 8 9 10 11 12 13 //设置锁和释放锁的方法 private Boolean setLock(String key){ Boolean flag= stringRedisTemplate.opsForValue().setIfAbsent(key,\u0026#34;1\u0026#34;,10,TimeUnit.SECONDS); if(flag==null){ return false; }else if(flag){ return true; } return false; } private void unLock(String key){ stringRedisTemplate.delete(key); } 互斥锁解决缓存穿透的代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override public Result getByIdRedis(Long id) throws InterruptedException { String shop= stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY+id); //查询到对应的value,并且这个value不是\u0026#34;\u0026#34;,则店铺存在,直接返回 if(shop!=null\u0026amp;\u0026amp;!\u0026#34;\u0026#34;.equals(shop)){ Shop shopRedis= JSONUtil.toBean(shop,Shop.class); return Result.ok(shopRedis); } //店铺value不等于null,但是为\u0026#34;\u0026#34;，说明缓存和数据库中都没有,直接返回不存在信息 if(shop!=null){ return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } //所有线程同时去抢夺互斥锁资源,只会有一个线程抢到 if(setLock(RedisConstants.LOCK_SHOP_KEY+id)){ Shop shop1= getById(id); //数据没查到,说明这个店铺id不存在,这次缓存穿透了,但是可以把空信息写入redis if(shop1==null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,\u0026#34;\u0026#34;,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } String json= JSON.toJSONString(shop1); //查询到店铺,返回店铺信息,并且把信息写入Redis if(shop1!=null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,json,RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); return Result.ok(shop1); } //所有工作做完后释放锁资源 unLock(RedisConstants.LOCK_SHOP_KEY+id); //其他线程休眠对应的时间后重新尝试获取资源(递归) }else { Thread.sleep(50); getByIdRedis(id); } return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } 其中为防止获得锁的线程挂了不会释放锁资源,给锁设置过期时间\n解决方案2:逻辑过期时间 在Redis中存储数据时,多存储一条过期时间,如果过期的话,最快发现的线程会主动申请互斥锁,并且查询数据库,查完后设置过期时间并且写回redis,同时返回给客户端,其他的线程请求完锁后,请求不到就直接返回过期的数据,这种方式可以防止死锁的发生,但是牺牲了一部分redis空间 java代码如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 @Override public Result redisLogicExpireTime(Long id){ String shop= stringRedisTemplate.opsForValue().get(RedisConstants.CACHE_SHOP_KEY+id); logger.info(shop); //查询到对应的value,并且这个value不是\u0026#34;\u0026#34;,则店铺存在,直接返回 if(shop!=null\u0026amp;\u0026amp;!\u0026#34;\u0026#34;.equals(shop)){ RedisData redisData=JSONUtil.toBean(shop,RedisData.class); //判断是否过期 if(redisData.getExpireTime().isAfter(LocalDateTime.now())){ Shop shopRedis= redisData.getData(); System.out.println(shopRedis); logger.info(\u0026#34;查询redis直接输出\u0026#34;); return Result.ok(shopRedis); } } //店铺value不等于null,但是为\u0026#34;\u0026#34;，说明缓存和数据库中都没有,直接返回不存在信息 if(shop!=null\u0026amp;\u0026amp;shop.equals(\u0026#34;\u0026#34;)){ return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } //所有线程同时去抢夺互斥锁资源,只会有一个线程抢到 if(setLock(RedisConstants.LOCK_SHOP_KEY+id)){ Shop shop1= getById(id); //数据没查到,说明这个店铺id不存在,这次缓存穿透了,但是可以把空信息写入redis if(shop1==null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,\u0026#34;\u0026#34;,cacheAvalanche(), TimeUnit.MINUTES); return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } RedisData redisData=new RedisData(); redisData.setData(shop1); redisData.setExpireTime(LocalDateTime.now().plusMinutes(cacheAvalanche())); String json= JSON.toJSONString(redisData); //查询到店铺,返回店铺信息,并且把信息写入Redis if(shop1!=null){ stringRedisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY+id,json,cacheAvalanche(), TimeUnit.MINUTES); return Result.ok(shop1); } //所有工作做完后释放锁资源 unLock(RedisConstants.LOCK_SHOP_KEY+id); //其他线程直接返回过期的数据 }else { RedisData redisData=new RedisData(); redisData.setData(JSONUtil.toBean(shop,Shop.class)); Shop redis=redisData.getData(); return Result.ok(redis); } return Result.fail(\u0026#34;店铺信息不存在\u0026#34;); } 订单秒杀问题 限量限时商品可能会在短时间内面临大量请求,可能会出现超卖的情况\n如果第一次遇到1的时候没来得及写到数据库里,后面的线程查询的时候遇到的还是1,就可以继续执行扣减的操作,导致超卖的情况发生\nJMeter测试结果 200次线程请求直接超卖了9个商品\n解决方案1:乐观锁 • 假设：乐观锁假设冲突发生的概率很小，允许多个事务同时操作数据，但在提交时检查是否有其他事务修改了数据。\n• 实现：通常通过版本号（version）或时间戳（timestamp）实现。在更新数据时，比较当前版本号与数据库中的版本号，如果一致则更新并增加版本号；如果不一致，则说明数据已被其他事务修改，需要重新获取数据并重试。\n• 适用场景：适用于读多写少的场景，或者数据竞争不激烈的情况下。\nJava实现 1 2 3 4 5 6 7 8 Boolean success=seckillVoucherServiceImpl.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId) .eq(\u0026#34;stock\u0026#34;, seckillVoucher.getStock()) .update(); if(!success){ return Result.fail(\u0026#34;库存不足\u0026#34;); } 在写入数据库之前,先查询数据库目前的值和之前查询到的是否一样,是否在写入之前被修改了,如果被修改了就不能写入\nJMeter测试结果 可以发现成功率低的可怜,200次请求只抢到了21张票,原因就是每次写入都要查询到之前是否已经写过,请求频率太高,导致不写入的概率也更高,写入越多的情况越不能用乐观锁\n解决方案2:悲观锁 • 假设：悲观锁假设会发生冲突，即多个事务会同时修改同一数据，因此它在操作开始时就锁定数据，防止其他事务修改。\n• 实现：通常通过数据库的锁机制实现，如行锁、表锁等。\n• 适用场景：适用于写操作频繁的场景，或者数据竞争非常激烈的情况下。\n只要在每次写入更新结果之前先查看一下剩余的量是不是大于0就可以了\nJava代码 1 2 3 4 5 6 7 8 Boolean success=seckillVoucherServiceImpl.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;,voucherId) .gt(\u0026#34;stock\u0026#34;, 0) .update(); if(!success){ return Result.fail(\u0026#34;库存不足\u0026#34;); } JMeter测试结果 200次请求,只卖出100张,异常比例正确\n单人订单问题 有些商品给购买者限量,比如买火车票或者限定周边,如果一个黄牛用脚本在短时间大量请求,则有可能会多卖\n简单解决\n1 2 3 4 List\u0026lt;VoucherOrder\u0026gt; list=voucherOrderMapper.selectByUserId(voucherId,UserHolder.getUser().getId()); if(!list.isEmpty()){ return Result.fail(\u0026#34;该用户已下过单\u0026#34;); } JMeter测试结果显示,200个请求同时下单,一共能购买10张票\n解决方案:共享锁 在 Java 中， synchronized是一个关键字，用于控制对共享资源的访问，确保在同一时刻只有一个线程可以访问特定的代码块或方法。这是实现线程同步的一种方式，主要用于解决多线程环境下的并发问题。\n我们可以把订单秒杀的代码先抽离出来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Transactional(rollbackFor = Exception.class) public Result createVoucherOrder(Long voucherId) { //开始的话看库存够不够,够就库存减一,并且创建订单 List\u0026lt;VoucherOrder\u0026gt; list=voucherOrderMapper.selectByUserId(voucherId,UserHolder.getUser().getId()); if(!list.isEmpty()){ return Result.fail(\u0026#34;该用户已下过单\u0026#34;); } Boolean success=seckillVoucherServiceImpl.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherId) .gt(\u0026#34;stock\u0026#34;, 0) .update(); if(!success){ return Result.fail(\u0026#34;库存不足\u0026#34;); } Long id= UserHolder.getUser().getId(); VoucherOrder voucherOrder=new VoucherOrder(); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(id); voucherOrder.setCreateTime(LocalDateTime.now()); voucherOrder.setUpdateTime(LocalDateTime.now()); voucherOrder.setPayTime(LocalDateTime.now()); voucherOrder.setStatus(1); voucherOrder.setId(redisId.nextId(\u0026#34;order\u0026#34;)); voucherOrderMapper.insert(voucherOrder); return Result.ok(voucherOrder.getVoucherId() + \u0026#34;下单成功\u0026#34;); } 如果是对整个函数加锁,也就是在public后面,那么不是同一个用户也会被锁给拦截,性能不高\n或者可以给锁限定userId,如果同一id就被拦截,串行进行\n1 2 Long userId =UserHolder.getUser().getId(); synchronized (userId.toString().intern()) 这里intern的作用是,toString会导致产生新的字符串对象,字符串对象虽然值是相同的,但是哈希值不一样,被锁认为是不同的对象,这时用intern可以从字符串池里找相同的串,哈希值相同\n锁应当在事务结束之后再释放才行,否则又会产生冲突,事务还没结束,有个线程又进来了,会引发异常,因此应当把锁放到整个方法外面\n1 2 3 4 Long userId =UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { return createVoucherOrder(voucherId); } JMeter测试结果 200次买票,只买到1次,解决了单人买票的问题\n上述写法依然有问题\nJava魅力时刻 1 2 3 4 Long userId =UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { return createVoucherOrder(voucherId); } 注意到这里的return createVoucherOrder(voucherId);是目标对象引用的函数，相当于\nreturn this.createVoucherOrder(voucherId);但是只有代理对象才有事务管理的功能,代理对象就是加上@Controller,@Service,@Mapper,@Component,@Bean的对象,这个对象协助目标对象完成工作.\n要想在这个对象里面调用代理对象可以通过如下办法\n1 2 3 4 5 Long userId =UserHolder.getUser().getId(); synchronized (userId.toString().intern()) { IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); } AopContext.currentProxy()获取本类的代理对象,然后从Object转成本类的对象,然后调用对应的方法,要在接口里面重新声明这个方法\n同时要引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.22.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在springboot启动类上加注解\n1 @EnableAspectJAutoProxy(exposeProxy = true) 允许SpringIOC容器暴露代理对象,这样我们才能正常获取代理对象\nRedis实现分布式锁 如果现在同时开两个进程,服务器集群部署,由nginx实现负载均衡,实现轮询发送请求,先给8081端口发送,再给8082端口,导致进程内的锁无法和另一个进程的锁联动\n这时可以使用伟大的Redis制作分布式锁来解决这个问题!\n分布式锁的设计 这个锁应当起到互斥作用,很多个线程同时发送过来,只能有一个线程获取锁资源,因此得用setnx.\n在此线程结束运行的时候应当及时释放锁资源,防止服务器资源浪费,及时del key\n如果一个服务器在发送完这个请求后就宕机了,不会执行这个释放锁资源的代码,那么锁资源就不会被释放,导致其他服务器资源浪费.这时候就要给锁设置过期时间,到时间自动释放锁资源\n如果在还没执行expire time的时候服务器就宕机了,那么锁资源一样不会被释放,这时候就得这么写获取锁的语句\n1 set lock thread1 nx ex 10 保持了原子性,让互斥和过期时间一起设置\n同时采用非阻塞的锁,防止很多线程一直等待锁资源释放,尝试一次,如果没获取锁资源就return false,成功就return true\nJava代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.hmdp.utils; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements ILock { private StringRedisTemplate stringRedisTemplate; private static final String LOCK_PREFIX = \u0026#34;lock:\u0026#34;; private String lockName; public SimpleRedisLock(String lockName,StringRedisTemplate stringRedisTemplate) { this.lockName = lockName; this.stringRedisTemplate = stringRedisTemplate; } @Override public Boolean tryLock(Long timeoutSec) { Long threadId = Thread.currentThread().getId(); Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(LOCK_PREFIX+lockName,threadId+\u0026#34;\u0026#34;,timeoutSec, TimeUnit.SECONDS); //这样写的话,是true就返回true,如果是false或者null都返回false return Boolean.TRUE.equals(result); } @Override public void unlock() { stringRedisTemplate.delete(LOCK_PREFIX+lockName); } } 将分布式锁加入业务逻辑 1 2 3 4 5 6 7 8 9 10 11 12 Long userId =UserHolder.getUser().getId(); SimpleRedisLock lock=new SimpleRedisLock(\u0026#34;order:\u0026#34;+userId,stringRedisTemplate); Boolean isLock=lock.tryLock(1200L); if(!isLock){ return Result.fail(\u0026#34;一人只能买一张票\u0026#34;); } try{ IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy(); return proxy.createVoucherOrder(voucherId); }finally { lock.unlock(); } 分布式锁误删问题: 由于业务阻塞,导致线程1获取锁后没有及时释放锁资源,锁自动释放,线程2请求锁成功,开始执行业务逻辑\n这时候线程1完成业务,执行释放锁的指令,导致业务2的锁被意外删除,以此类推,锁会被意外删除.\n改进办法很简单,只要每次执行删除锁之前先查询锁的线程是否是自己的,是自己的就可以删,不是自己的就跳过.\nJava代码改进 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package com.hmdp.utils; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.UUID; import java.util.concurrent.TimeUnit; public class SimpleRedisLock implements ILock { private StringRedisTemplate stringRedisTemplate; private static final String LOCK_PREFIX = \u0026#34;lock:\u0026#34;; private static final String ID_PREFIX = UUID.randomUUID().toString(); private String lockName; public SimpleRedisLock(String lockName,StringRedisTemplate stringRedisTemplate) { this.lockName = lockName; this.stringRedisTemplate = stringRedisTemplate; } @Override public Boolean tryLock(Long timeoutSec) { String threadId =ID_PREFIX+ Thread.currentThread().getId(); Boolean result = stringRedisTemplate.opsForValue().setIfAbsent(LOCK_PREFIX+lockName,threadId,timeoutSec, TimeUnit.SECONDS); //这样写的话,是true就返回true,如果是false或者null都返回false return Boolean.TRUE.equals(result); } @Override public void unlock() { String UnlockName= stringRedisTemplate.opsForValue().get(LOCK_PREFIX+lockName); String threadId =ID_PREFIX+ Thread.currentThread().getId(); if(threadId.equals(UnlockName)){ stringRedisTemplate.delete(LOCK_PREFIX+lockName); } } } 对程序打断点调试,获取锁后拦截,当我修改这里的ThreadId并且重新放行后,这里的新锁并没有被删掉,解决了误删的问题.\nLua脚本 当我们使用最新的分布式锁的时候,如果在执行finally语句里面的代码时,遭遇JVM进行垃圾回收,这时候会遇到无法战胜的业务阻塞,,代码还是没有做到原子性.如果已经验证完这个线程对应这个锁后突然垃圾回收,那么就会导致del锁这个操作会很危险.\n这时候可以把整个unlock操作用Lua脚本完成\n在Redis客户端使用lua脚本 无参脚本 1 eval \u0026#34;return redis.call(\u0026#39;set\u0026#39;,\u0026#39;name\u0026#39;,\u0026#39;jack\u0026#39;)\u0026#34; 0 语句的意思是使用脚本,脚本是一个字符串,就是引号里面的,脚本相当于set name jack 0代表没有参数\n有参脚本 1 eval \u0026#34;return redis.call(\u0026#39;set\u0026#39;,KEYS[1],ARGV[1])\u0026#34; 1 dinglz sb 用KEYS[1]和ARGV[1]作为占位符,后面有一对参数\n使用lua脚本解决删除锁问题 1 2 3 4 5 6 7 8 --查询锁的id local id=redis.call(\u0026#39;get\u0026#39;,KEYS[1]) if(ARGV[1]==id) then --释放锁 return redis.call(\u0026#39;del\u0026#39;,KEYS[1]) end --不是自己的锁,不用释放锁 return 0 Java代码调用Lua脚本 把lua脚本创建在这个目录下,等下方便读取 重写unlock方法 1 2 3 4 5 6 7 8 9 @Override public void unlock() { List list = new ArrayList(); list.add(LOCK_PREFIX+lockName); stringRedisTemplate.execute( UNLOCK_SCRIPT, list, ID_PREFIX+ Thread.currentThread().getId()); } 向redis传输指令,显示脚本,然后是参数,KEYS[1]参数要用集合封装,第二个参数是线程id也就是ARGV[1]\n同时要配置好脚本\n1 2 3 4 5 6 private static DefaultRedisScript\u0026lt;Long\u0026gt; UNLOCK_SCRIPT; static { UNLOCK_SCRIPT = new DefaultRedisScript\u0026lt;\u0026gt;(); UNLOCK_SCRIPT.setLocation(new ClassPathResource(\u0026#34;unLock.lua\u0026#34;)); UNLOCK_SCRIPT.setResultType(Long.class); } 设置文件位置,然后设置返回格式,返回值为0表示删除锁失败,1表示删除锁成功\nRedisson Redisson是一个封装好的分布式锁工具,这里面的锁是已经写好的,并且比前文介绍的锁多一些功能和奇效\n引入依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.redisson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;redisson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.16.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置Redisson 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.hmdp.config; import org.redisson.Redisson; import org.redisson.api.RedissonClient; import org.redisson.config.Config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RedissonConfig { @Bean public RedissonClient redisson() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://Yourip:Yourport\u0026#34;).setPassword(\u0026#34;Yourpassword\u0026#34;); return Redisson.create(config); } } @Configuration注解 这里顺带提一嘴Springboot框架面试高频考点,@Configuration是什么,和@Component有啥区别. @Configuration是配置类要添加的注解,它的构成是\n1 2 3 4 5 6 7 8 9 10 11 12 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration { @AliasFor( annotation = Component.class ) String value() default \u0026#34;\u0026#34;; boolean proxyBeanMethods() default true; } 这里面也有@Component,但是它比前者多实现单例模式\n如果你在创建Bean对象的时候一次性创建多个,Spring容器并不会去对象池去找是否有已经创建过的对象,而是直接再创建,这样无法保证单例性\n而如果用@Configuration就可以只创建一次Bean对象\n使用Redisson制作分布式锁 1 2 3 //SimpleRedisLock lock=new SimpleRedisLock(\u0026#34;order:\u0026#34;+userId,stringRedisTemplate); Boolean isLock1=redissonClient.getLock(\u0026#34;order\u0026#34;+userId).tryLock(1L, TimeUnit.SECONDS); //Boolean isLock=lock.tryLock(1200L); 中间那一行代码就等价于之前写的SimpleRedisLock\nRedisson解决不可重入 不可重入导致死锁 如果一个线程请求锁资源,然后又请求了一次锁资源,第二次请求会失败,因为已经有线程获取过锁,并且就是自身,这导致了这个线程请求不到锁,也释放不了锁,导致了死锁.\n解决方案 于是Redisson改变了锁的结构,让锁的数据结构变为Hash,key存储锁的名称,field存储线程名称,value存储该锁被同一个线程调用了几次,每次调用会给value自增,如果释放锁资源就value自减一次,如果value==0,那么就删除这个锁资源.\nRedisson解决不可重试 不可重试导致大量请求失败 正常线程如果获取锁失败就直接返回false了,或者说一直循环递归等待下去,导致了大量请求无法返回客户需要的内容\n解决方案 1 Boolean isLock1=redissonClient.getLock(\u0026#34;order\u0026#34;+userId).tryLock(1L, TimeUnit.SECONDS); 注意到我们之前在设置tryLock的时候设置了尝试时间1L,单位是秒.这个意思是我可以总共等待1秒,如果这1秒内获取到锁资源,就返回true,如果没请求到就返回false,当然这个1L可以改为任何数值.\nRedisson的tryLock原码 1 2 3 4 5 6 7 long time = unit.toMillis(waitTime); long current = System.currentTimeMillis(); long threadId = Thread.currentThread().getId(); Long ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId); if (ttl == null) { return true; } ttl是剩余等待时间,后面的tryAcquire是看是否获取锁成功,如果获取锁成功就返回null,如果获取成功就返回剩余等待时间.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 else { current = System.currentTimeMillis(); RFuture\u0026lt;RedissonLockEntry\u0026gt; subscribeFuture = this.subscribe(threadId); if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) { if (!subscribeFuture.cancel(false)) { subscribeFuture.onComplete((res, e) -\u0026gt; { if (e == null) { this.unsubscribe(subscribeFuture, threadId); } }); } this.acquireFailed(waitTime, unit, threadId); return false; } else { boolean var16; try { time -= System.currentTimeMillis() - current; if (time \u0026lt;= 0L) { this.acquireFailed(waitTime, unit, threadId); boolean var20 = false; return var20; } do { long currentTime = System.currentTimeMillis(); ttl = this.tryAcquire(waitTime, leaseTime, unit, threadId); if (ttl == null) { var16 = true; return var16; } time -= System.currentTimeMillis() - currentTime; if (time \u0026lt;= 0L) { this.acquireFailed(waitTime, unit, threadId); var16 = false; return var16; } currentTime = System.currentTimeMillis(); if (ttl \u0026gt;= 0L \u0026amp;\u0026amp; ttl \u0026lt; time) { ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS); } else { ((RedissonLockEntry)subscribeFuture.getNow()).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS); } time -= System.currentTimeMillis() - currentTime; } while(time \u0026gt; 0L); this.acquireFailed(waitTime, unit, threadId); var16 = false; } finally { this.unsubscribe(subscribeFuture, threadId); } return var16; } } 主要看else中的原码,如果获取锁失败,并且要进入等待,RFuture subscribeFuture = this.subscribe(threadId）指的是这个线程订阅了请求的锁的信息,如果锁被释放了,这个线程就会收到信息,这正是观察者模式.但是这个等待并不是无限制的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 RFuture\u0026lt;RedissonLockEntry\u0026gt; subscribeFuture = this.subscribe(threadId); if (!subscribeFuture.await(time, TimeUnit.MILLISECONDS)) { if (!subscribeFuture.cancel(false)) { subscribeFuture.onComplete((res, e) -\u0026gt; { if (e == null) { this.unsubscribe(subscribeFuture, threadId); } }); } this.acquireFailed(waitTime, unit, threadId); return false; } 如果时间到达上限了,直接返回false,并且取消订阅.\n如果时间没到上限,就再尝试获取锁,没获取到就继续订阅,因为很多线程同时请求过来,得按顺序获取锁.直到获取到锁或者直接到时间才结束这个循环.\nRedis本地集群部署 只要改一下端口号就能实现本地的Redis集群\n在config文件下修改端口号\n用记事本或者vscode打开都可以,然后按下Ctrl+F搜索6379,下面的端口号改成没设置过的端口号,但也不要跟其他进程冲突了,我这里改为了6381\n然后分别启动Redis就实现Redis集群了\nRedisson实现分布式联锁 1 2 3 4 RLock lock1=redisson6379.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock2=redisson6380.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock3=redisson6381.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock=redisson6380.getMultiLock(lock1,lock2,lock3); 使用随机一个redisson客户端来调用它的.getMultiLock方法就可以制作出联锁\n联锁就可以在Redis集群的情况下,所有Redis共有一把锁,以免出现重复申请锁资源的情况\ngetMultiLock会尝试同时获取所有指定的锁，只有当所有锁都成功获取时，才算加锁成功。如果任何一个锁获取失败，它会回滚已经获取的锁，确保加锁操作的原子性。\n通过将多个锁的获取和释放封装在一起，getMultiLock简化了在复杂业务场景下的并发控制逻辑，减少了开发人员在处理多个锁时的错误风险。\n其中redisson.getMultilock使用任意一个对象都可以的原因是,这里是统一新创建\n1 2 3 public RLock getMultiLock(RLock... locks) { return new RedissonMultiLock(locks); } 通过这样制作联锁,可以让每一个Redis都有lock\n异步秒杀问题 将超卖和判重用Redis解决 把卖票过程比喻成厨子做饭,如果饭店只有一个人,那么他自己得招待顾客,还得自己下厨,但是这时候多来了个服务员,服务员负责招待顾客下单,厨子只是来做菜,卖票过程就是用Redis作为先手,把订单都收到手了,交给后端再交给数据库来异步处理这些订单.\nJMeter测试数据时,随着时间请求量会增长,因此可能会面对短时间超高并发,并且现有的代码还有很多查询MySQL的操作,比如:\n查询优惠券剩余数量,查询stock\n顾客是否已经买过一张票,查询是否有这个订单\n于是我们可以通过改变订单流程来解决\n在商家添加优惠券信息的时候就把优惠券的信息和数量同步到Redis\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Override @Transactional public void addSeckillVoucher(Voucher voucher) { // 保存优惠券 save(voucher); // 保存秒杀信息 SeckillVoucher seckillVoucher = new SeckillVoucher(); seckillVoucher.setVoucherId(voucher.getId()); seckillVoucher.setStock(voucher.getStock()); seckillVoucher.setBeginTime(voucher.getBeginTime()); seckillVoucher.setEndTime(voucher.getEndTime()); seckillVoucherService.save(seckillVoucher); stringRedisTemplate.opsForValue().set(\u0026#34;Inventory\u0026#34;+voucher.getId()+\u0026#34;:stock\u0026#34;,voucher.getStock().toString()); } 然后在请求到达后端时,先查询Redis,判断优惠券数量是否够,这个用户是否下过单了\nlua脚本 由于一次性操作Redis次数过多,直接使用多条java语句没有原子性,因此要用lua脚本 1 2 3 4 5 6 7 8 9 10 local stock=redis.call(\u0026#39;get\u0026#39;,KEYS[1]) if(tonumber(stock)\u0026lt;1) then return 1 end local success = redis.call(\u0026#39;SADD\u0026#39;, KEYS[2], ARGV[1]) if(success==0) then return 2 end redis.call(\u0026#39;decr\u0026#39;,KEYS[1]) return 0 由于KEYS传过来时必须得是String类型,而只有number才能比较大小,因此先转化为数字,如果票没了就返回1.\nRedis的set集合 Redis的set集合在插入的时候,要判重,如果重复就不能插入,返回0,如果插入成功就返回1,故可以作为锁.\n多人秒杀的存储效果是这样的\n然后就可以写代码调用脚本了\n1 2 3 4 5 6 7 8 9 10 11 //前期判断 List\u0026lt;String\u0026gt; KEYS = new ArrayList\u0026lt;\u0026gt;(); //List\u0026lt;String\u0026gt; ARGS = new ArrayList\u0026lt;\u0026gt;(); KEYS.add(\u0026#34;Inventory\u0026#34;+voucherId+\u0026#34;:stock\u0026#34;); KEYS.add(\u0026#34;Inventory\u0026#34;+voucherId+\u0026#34;:set\u0026#34;); Long result = stringRedisTemplate.execute(TICKET_SNATCHING_SCRIPT, KEYS, UserHolder.getUser().getId()+\u0026#34;\u0026#34;); if(result==1){ return Result.fail(\u0026#34;没票了\u0026#34;); }else if (result==2){ return Result.fail(\u0026#34;一个人不能抢多张票\u0026#34;); } 后端接受到可以下单的信息后制作订单\n1 2 3 4 5 6 7 8 9 Long id= UserHolder.getUser().getId(); VoucherOrder voucherOrder=new VoucherOrder(); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(id); voucherOrder.setCreateTime(LocalDateTime.now()); voucherOrder.setUpdateTime(LocalDateTime.now()); voucherOrder.setPayTime(LocalDateTime.now()); voucherOrder.setStatus(1); voucherOrder.setId(redisId.nextId(\u0026#34;order\u0026#34;)); 然后把订单数据交给阻塞队列来异步执行,这里要用java自带的阻塞队列,然后多创建一个线程来解决这些下单问题\n1 2 3 4 5 6 7 8 9 //创建阻塞队列 private BlockingQueue\u0026lt;VoucherOrder\u0026gt; queue=new ArrayBlockingQueue\u0026lt;VoucherOrder\u0026gt;(1024*1024); //创建线程池 private static final ExecutorService SECKILL_ORDER_EXECUTOR= Executors.newSingleThreadExecutor( ); //在启动类初始化完就马上把 @PostConstruct private void init(){ SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); } @PostConstruct private void init(){ SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler()); }着重讲一下\n@PostConstruct 注解：\n当类的实例被创建后，Spring容器会自动调用这个方法。\n通常用于执行一些初始化操作，比如启动线程、加载配置等。\nSECKILL_ORDER_EXECUTOR：\n它的作用是管理线程的生命周期，避免频繁创建和销毁线程的开销。 submit(new VoucherOrderHandler())：\nsubmit方法将一个任务提交到线程池中执行。\nVoucherOrderHandler实现了Runnable接口的类\n这里创建了一个VoucherOrderHandler实例，并将其提交到线程池中，线程池会选择一个空闲线程来执行这个任务。\n这是线程池的任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //给线程池分配任务 private class VoucherOrderHandler implements Runnable{ @Override public void run() { while(true){ try{ VoucherOrder voucherOrder=queue.take(); voucherHandler(voucherOrder); }catch (Exception e){ System.out.println(\u0026#34;订单处理异常\u0026#34;+e.getMessage()); } } } } 在队列中有元素的时候,子线程取出voucherOrder对象,然后解决下单问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private void voucherHandler(VoucherOrder voucherOrder) throws InterruptedException { Long userId=voucherOrder.getUserId(); //SimpleRedisLock lock=new SimpleRedisLock(\u0026#34;order:\u0026#34;+userId,stringRedisTemplate); RLock lock1=redisson6379.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock2=redisson6380.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock3=redisson6381.getLock(\u0026#34;lock:order:\u0026#34;+userId); RLock lock=redisson6380.getMultiLock(lock1,lock2,lock3); Boolean isLock1=lock.tryLock(1L, TimeUnit.SECONDS); //Boolean isLock=lock.tryLock(1200L); if(!isLock1){ return ; } try{ proxy.createVoucherOrder(voucherOrder); }finally { System.out.println(\u0026#34;id为\u0026#34;+userId+\u0026#34;的顾客买到票了\u0026#34;); lock.unlock(); } } 注意到这是个子线程的任务,子线程的任务无法获得代理对象,也就是SpringBoot的IOC容器管理的对象,但是我们需要事务回滚,所以还是得用代理对象,所以只能把代理对象作为私有变量,然后在类的方法中对这个私有代理对象进行赋值\n1 2 3 4 5 6 7 8 private IVoucherOrderService proxy; @Override public Result order(Long voucherId) { ... //获取代理对象 proxy=(IVoucherOrderService) AopContext.currentProxy(); ... } 然后改进createVoucherOrde方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Transactional(rollbackFor = Exception.class) public void createVoucherOrder(VoucherOrder voucherOrder) { //开始的话看库存够不够,够就库存减一,并且创建订单 List\u0026lt;VoucherOrder\u0026gt; list=voucherOrderMapper.selectByUserId(voucherOrder.getVoucherId(),voucherOrder.getUserId()); if(!list.isEmpty()){ return ; } Boolean success=seckillVoucherServiceImpl.update() .setSql(\u0026#34;stock=stock-1\u0026#34;) .eq(\u0026#34;voucher_id\u0026#34;, voucherOrder.getVoucherId()) .gt(\u0026#34;stock\u0026#34;, 0) .update(); if(!success){ return ; } voucherOrderMapper.insert(voucherOrder); } 至此,异步下单已经初步完成了.\nJMeter测试 由于要实现多人秒杀,所以就得用多个账户登录来抢票,但是找不到1000个真人来测试,总不能一个一个敲登录来获取token吧,所以可以写一个自动登录1000个账户的测试类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.hmdp; import com.hmdp.utils.RedisConstants; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.StringRedisTemplate; import java.util.HashMap; import java.util.Map; import java.util.UUID; import java.util.concurrent.TimeUnit; @SpringBootTest public class TokenTest { private static final Integer NUMBER_OF_TOKEN = 1000; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test() { for (Integer i = 1; i \u0026lt; NUMBER_OF_TOKEN+1; i++) { Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;nickName\u0026#34;, \u0026#34;\u0026#34;); map.put(\u0026#34;icon\u0026#34;, \u0026#34;\u0026#34;); map.put(\u0026#34;id\u0026#34;, i.toString()); String token= UUID.randomUUID().toString(); stringRedisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY+token,map); System.out.println(token); stringRedisTemplate.expire(token, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); } } } 在 Redis里存一份即可,然后把所有的token输出出来,后面拿来给JMeter,这样绕过了拦截器\n把tokens存到txt文件中\n在JMeter里面这样设置一下\n注意那个路径就是txt文件存储位置\n然后改一下登录状态头\n然后就可以开始测试了!\n测试结果:\n1000人抢200张票,只有20%成功率,80%的异常率,测试成功\nRedis实现消息队列 认识消息队列 消息队列（Message Queue，简称MQ）是一种在软件架构中用于实现应用程序之间异步通信的中间件。它允许一个或多个生产者（消息的发送者）将消息发送到队列中，然后由一个或多个消费者（消息的接收者）从队列中读取消息。消息队列的主要作用是解耦、缓冲、异步通信和负载均衡等,可以用来削峰填谷,减轻服务器和数据库的处理压力。 之前有用到spring的阻塞队列,但是这个阻塞队列效果不是很好,如果中途服务挂机了,或者说停机后JVM会强制删除所有内存数据,那么后续请求就无法完成,并且不保留记录.这时候就需要外部的消息队列了,这里先用Redis实现,后面还可以用实现好的消息队列,kafka,RocketMQ\nRedis要求: redis必须达到5版本及其以上,这里使用的是stream数据结构来制作消息队列\nRedis单消费模式 我们可以使用XADD来向消息队列里面加入元素,用XREAD来读取消息队列的元素\n1 XADD users * k2 v2 第一次redis会去查存储空间里面有没有users这个消息队列如果没有就创建\n这个语句的意思是添加名称为users的消息队列,然后*为自动生成id,k2 v2为一个键值对\n添加成功后会返回一个数据\u0026quot;1743079174227-0\u0026quot;这是一个时间戳,用来唯一标识这个队列\n同样的我们可以用XREAD来读取消息队列中的数据\n1 XREAD count 1 streams users 0 这个语句的意思是读消息,一次读一条,读取消息队列users的消息,并且从0开始读\n1 XREAD count 1 block 0 streams users $ 这个语句的意思是读取users的消息,($)读取最新的消息,然后无限阻塞,直到有消息进入队列就读取一条消息.\n这样看上去一个消息队列建好了,但是有bug,如果存储数据时间较长,存储数据没来得及存储完,又传来了一堆新的消息,$只能读取最新的消息,导致中间有很多消息都漏掉了\nRedis消费者组模式 省流版: 消费者组里面有很多消费者,它们是竞争关系,都来争着处理消息,可以解决消息漏处理的问题\n消息表示指的是最后被处理的消息会被打上标签,就像看书有个书签,看完后下次再看就立马知道在哪了\n消息确认就跟TCP三次握手相似,只是没有最后一段客户端向服务端的确认信息,每次处理完信息都会确认一下,并且有个pending-list,如果没处理这个消息就根据这个list继续处理\n创建消费者组 1 XGROUP CREATE users group1 0 这个语句的意思是在users这个消息队列中创建消费者组,如果没有users这个消息队列就会创建失败,这个消费者组的名称为group1,每次从id=0开始读\n通过消费者组读消息队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 localhost:6379\u0026gt; XREADGROUP group group1 c1 count 1 block 2000 streams users \u0026gt; 1) 1) \u0026#34;users\u0026#34; 2) 1) 1) \u0026#34;1743074094428-0\u0026#34; 2) 1) \u0026#34;k1\u0026#34; 2) \u0026#34;v1\u0026#34; localhost:6379\u0026gt; XREADGROUP group group1 c1 count 1 block 2000 streams users \u0026gt; 1) 1) \u0026#34;users\u0026#34; 2) 1) 1) \u0026#34;1743079174227-0\u0026#34; 2) 1) \u0026#34;k2\u0026#34; 2) \u0026#34;v2\u0026#34; localhost:6379\u0026gt; XREADGROUP group group1 c1 count 1 block 2000 streams users \u0026gt; 1) 1) \u0026#34;users\u0026#34; 2) 1) 1) \u0026#34;1743082841091-0\u0026#34; 2) 1) \u0026#34;k3\u0026#34; 2) \u0026#34;v3\u0026#34; localhost:6379\u0026gt; XREADGROUP group group1 c1 count 1 block 2000 streams users \u0026gt; 1) 1) \u0026#34;users\u0026#34; 2) 1) 1) \u0026#34;1743082847320-0\u0026#34; 2) 1) \u0026#34;k4\u0026#34; 2) \u0026#34;v4\u0026#34; localhost:6379\u0026gt; XREADGROUP group group1 c1 count 1 block 2000 streams users \u0026gt; 1) 1) \u0026#34;users\u0026#34; 2) 1) 1) \u0026#34;1743082852967-0\u0026#34; 2) 1) \u0026#34;k5\u0026#34; 2) \u0026#34;v5\u0026#34; 这个语句的含义是通过消费者组进行读取,group的名称是group1(刚刚创建的),消费者名称叫c1(随便取的名字,没有的话会自动创建),每次消费一条信息,阻塞2秒,消息队列名称为users,选择从最早发过来的未读消息开始读,\u0026gt;换成0可以使因为之前处理消息的时候,服务器炸了,重新处理的时候读取pending-list,直接从未处理完成的消息继续处理\n确认信息方法XACK 1 2 XACK users group1 1743074094428-0 1743079320687-0 1743082841091-0 1743082847320-0 (integer) 4 前面是消息队列名称和消费者组名,后面是消息被消费后发出的时间戳\n通过如下语句查询pending-list\n1 2 3 4 5 6 xpending users group1 1) (integer) 1 2) \u0026#34;1743079174227-0\u0026#34; 3) \u0026#34;1743079174227-0\u0026#34; 4) 1) 1) \u0026#34;c1\u0026#34; 2) \u0026#34;1\u0026#34; 通过Redis实现消息队列替代阻塞队列 其实没必要这么实现(绝对不是因为我这边IDEA无法识别我写的函数才不实现的)\n我们可以直接上正经的消息队列\n通过RabbitMQ替代阻塞队列 RabbitMQ是个消息队列,文档非常完整好懂,可以通过文档学习.要使用RabbitMQ要先下载,这里我在ubuntu虚拟机上下载并使用这个消息队列\n在 Ubuntu 上安装 RabbitMQ 通常需要以下步骤：\n1. 更新系统包列表 在安装任何软件之前，建议先更新系统的包列表，以确保安装的软件是最新的版本。运行以下命令：\n1 sudo apt update 2. 安装 Erlang RabbitMQ 是基于 Erlang 编程语言开发的，因此需要先安装 Erlang。可以使用以下命令安装 Erlang：\n1 sudo apt install erlang 3. 添加 RabbitMQ 的官方仓库 为了获取最新版本的 RabbitMQ，建议添加 RabbitMQ 的官方仓库。运行以下命令：\n1 2 3 sudo apt install apt-transport-https wget -O- https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add - echo \u0026#34;deb https://dl.bintray.com/rabbitmq/debian $(lsb_release -sc) main\u0026#34; | sudo tee /etc/apt/sources.list.d/rabbitmq.list 4. 更新包列表 添加完官方仓库后，需要再次更新包列表：\n1 sudo apt update 5. 安装 RabbitMQ Server 现在可以安装 RabbitMQ 了。运行以下命令：\n1 sudo apt install rabbitmq-server 6. 启动和启用 RabbitMQ 服务 安装完成后，RabbitMQ 服务应该会自动启动。可以通过以下命令检查服务状态：\n1 sudo systemctl status rabbitmq-server 如果服务未启动，可以手动启动并设置开机自启：\n1 2 sudo systemctl start rabbitmq-server sudo systemctl enable rabbitmq-server 7. 配置 RabbitMQ（可选） 如果需要进行额外配置，例如设置用户、权限等，可以使用以下命令：\n添加用户：\n1 sudo rabbitmqctl add_user myuser mypassword 设置用户权限：\n1 2 sudo rabbitmqctl set_user_tags myuser administrator sudo rabbitmqctl set_permissions -p / myuser \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; 启用管理插件（用于访问 Web 管理界面，默认端口为 15672）：\n1 sudo rabbitmq-plugins enable rabbitmq_management 正式使用RabbitMQ 按照以上步骤下载完rabbitmq后,我们可以打开网址馆里rabbitmq\nhttp://虚拟机的ip地址:15672\n注! 如果你用的不是docker下载的rabbitmq,那么你虚拟机的ip地址会改变,下次连不上rabbitmq有可能是因为ip地址变了 rabbitmq管理界面长这样\n你可以在主机上打开,也可以在虚拟机上打开,第一次登录只能在虚拟机上打开,因为有默认账号密码.输入账号:guest,密码:guest.然后进去后可以给自己之前用命令行创建的用户改权限\n点击创建的用户,这样修改权限\n这样你就可以用后端语言操控rabbitmq了!\n然后我们就可以打开心爱的IDEA\n引入maven坐标 先引入几个maven坐标\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--rabbitMQ的maven坐标--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.amqp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.18.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.amqp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-rabbit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.18.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 注意:springboot2.0版本只能用这套maven坐标,要用3.0版本maven坐标的话会出bug\n配置rabbitmq 先写好yaml\n然后这样写配置类,把rabbitmq交给IOC容器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.hmdp.config; import com.hmdp.properties.RabbitMQProperties; import org.springframework.amqp.core.Queue; import org.springframework.amqp.rabbit.connection.CachingConnectionFactory; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { @Autowired private RabbitMQProperties rabbitMQProperties; @Bean public ConnectionFactory connectionFactory() { CachingConnectionFactory connectionFactory = new CachingConnectionFactory(rabbitMQProperties.getHost()); connectionFactory.setUsername(rabbitMQProperties.getUsername()); connectionFactory.setPassword(rabbitMQProperties.getPassword()); connectionFactory.setVirtualHost(rabbitMQProperties.getVirtualHost()); connectionFactory.setPort(rabbitMQProperties.getPort()); return connectionFactory; } @Bean public RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory) { return new RabbitTemplate(connectionFactory); } @Bean public Queue voucherOrderQueue() { return new Queue(\u0026#34;voucher_order_queue\u0026#34;, true); } } 之前我们用的是阻塞队列,单独为消费者new了个线程来处理消息,现在我们可以创建一个消费者类,并且把对象交给IOC容器,让这个消费者持续处理信息\n消费者类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 package com.hmdp.Consumer; import com.hmdp.entity.VoucherOrder; import com.hmdp.service.IVoucherOrderService; import org.redisson.api.RLock; import org.redisson.api.RedissonClient; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import org.springframework.transaction.annotation.Transactional; import javax.annotation.Resource; import java.util.concurrent.TimeUnit; @Component public class VoucherOrderConsumer { @Autowired private IVoucherOrderService voucherOrderService; @Resource private RedissonClient redisson6379; @Resource private RedissonClient redisson6380; @Resource private RedissonClient redisson6381; @Transactional @RabbitListener(queues = \u0026#34;voucher_order_queue\u0026#34;) public void handle(VoucherOrder voucherOrder) throws InterruptedException { //SimpleRedisLock lock=new SimpleRedisLock(\u0026#34;order:\u0026#34;+userId,stringRedisTemplate); RLock lock1=redisson6379.getLock(\u0026#34;lock:order:\u0026#34;+voucherOrder.getUserId()); RLock lock2=redisson6380.getLock(\u0026#34;lock:order:\u0026#34;+voucherOrder.getUserId()); RLock lock3=redisson6381.getLock(\u0026#34;lock:order:\u0026#34;+voucherOrder.getUserId()); RLock lock=redisson6380.getMultiLock(lock1,lock2,lock3); Boolean isLock1=lock.tryLock(1L, TimeUnit.SECONDS); //Boolean isLock=lock.tryLock(1200L); if(!isLock1){ return ; } try{ voucherOrderService.createVoucherOrder(voucherOrder); }finally { System.out.println(\u0026#34;订单处理成功：\u0026#34; + voucherOrder.getId()); lock.unlock(); } } } 然后ServiceImpl类就成为了生产者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Override public Result order(Long voucherId) { //查询优惠券信息 SeckillVoucher seckillVoucher = seckillVoucherMapper.selectById(voucherId); //判断秒杀是否开始 LocalDateTime timeEnd = seckillVoucher.getEndTime(); LocalDateTime timeBegin=seckillVoucher.getBeginTime(); if(timeBegin.isAfter(LocalDateTime.now())){ return Result.fail(\u0026#34;秒杀活动暂未开始\u0026#34;); }else if (timeEnd.isBefore(LocalDateTime.now())){ return Result.fail(\u0026#34;秒杀活动现已结束\u0026#34;); } //前期判断 List\u0026lt;String\u0026gt; KEYS = new ArrayList\u0026lt;\u0026gt;(); //List\u0026lt;String\u0026gt; ARGS = new ArrayList\u0026lt;\u0026gt;(); KEYS.add(\u0026#34;Inventory\u0026#34;+voucherId+\u0026#34;:stock\u0026#34;); KEYS.add(\u0026#34;Inventory\u0026#34;+voucherId+\u0026#34;:set\u0026#34;); Long id=redisId.nextId(\u0026#34;order\u0026#34;); Long result = stringRedisTemplate.execute(TICKET_SNATCHING_SCRIPT, KEYS, UserHolder.getUser().getId()+\u0026#34;\u0026#34;); if(result==1){ return Result.fail(\u0026#34;没票了\u0026#34;); }else if (result==2){ return Result.fail(\u0026#34;一个人不能抢多张票\u0026#34;); } Long userId= UserHolder.getUser().getId(); VoucherOrder voucherOrder=new VoucherOrder(); voucherOrder.setVoucherId(voucherId); voucherOrder.setUserId(userId); voucherOrder.setCreateTime(LocalDateTime.now()); voucherOrder.setUpdateTime(LocalDateTime.now()); voucherOrder.setPayTime(LocalDateTime.now()); voucherOrder.setStatus(1); voucherOrder.setId(id); // 使用 RabbitMQ 发送消息 rabbitTemplate.convertAndSend(\u0026#34;voucher_order_queue\u0026#34;, voucherOrder); //queue.add(voucherOrder); //获取代理对象 proxy=(IVoucherOrderService) AopContext.currentProxy(); return Result.ok(\u0026#34;下单成功\u0026#34;+id); } 这样我们就使用了rabbitmq作为消息队列完成了异步秒杀.这只是rabbitmq的一点实力,后面我可能会专开一个坑来学rabbitmq\n测试类更新 简单更新了一下测试类 把token一键写入.txt文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Test public void test1() { // 指定文件路径 String filePath = \u0026#34;C:\\\\Users\\\\86180\\\\Desktop\\\\Test\\\\秒杀订单TOKEN数据.txt\u0026#34;; File file = new File(filePath); // 如果文件不存在则创建文件夹和文件 if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } // 如果文件存在，先清空文件内容 try (BufferedWriter writer = new BufferedWriter(new FileWriter(file))) { writer.write(\u0026#34;\u0026#34;); // 清空文件内容 } catch (IOException e) { e.printStackTrace(); } // 写入新的 token 数据 try (BufferedWriter writer = new BufferedWriter(new FileWriter(file, true))) { for (Integer i = 1; i \u0026lt; NUMBER_OF_TOKEN + 1; i++) { Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;nickName\u0026#34;, \u0026#34;\u0026#34;); map.put(\u0026#34;icon\u0026#34;, \u0026#34;\u0026#34;); map.put(\u0026#34;id\u0026#34;, i.toString()); String token = UUID.randomUUID().toString(); stringRedisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY + token, map); stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY + token, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES); // 将 token 写入文件 writer.write(token); writer.newLine(); // 换行 } } catch (IOException e) { e.printStackTrace(); } } 一键刷新测试数据,让我们和JMETER再抢一千次优惠券吧!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package com.hmdp; import com.hmdp.mapper.SeckillVoucherMapper; import com.hmdp.service.impl.VoucherOrderServiceImpl; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.StringRedisTemplate; @SpringBootTest public class RefreshData { private static final Long VOUCHER_ID=16L; private static final Long STOCK=1000L; @Autowired private VoucherOrderServiceImpl voucherOrderService; @Autowired private SeckillVoucherMapper seckillVoucherMapper; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void test() { //删除所有订单 voucherOrderService.deleteByVoucherId(VOUCHER_ID); //将剩余票数刷新为指定数值 seckillVoucherMapper.updateByVoucherId(VOUCHER_ID,STOCK); //同步修改redis的剩余票数 stringRedisTemplate.opsForValue().set(\u0026#34;Inventory\u0026#34;+VOUCHER_ID+\u0026#34;:stock\u0026#34;,STOCK+\u0026#34;\u0026#34;); //删除redis的set stringRedisTemplate.delete(\u0026#34;Inventory\u0026#34;+VOUCHER_ID+\u0026#34;:set\u0026#34;); } } 点赞功能 问题分析 点赞要求我们第一次点上去是点赞数+1,再点一次是点赞数-1,这完全可以交给数据库去解决,然后就是点赞前五名的人要展示在页面上,这时候可以用到redis的ZSET,排序集合\n业务逻辑: 点赞后,java代码查看是否点赞过,没点赞就点赞数+1,同时记录这个人点赞的时间戳,作为ZSET的排序依据,越早点赞的人越靠前,所有人都加入这个集合,点过赞再点就取消之前点赞,并且从这个集合中remove.查看点赞前五的代码就只用根据时间戳选择前五个用户就好,下面是代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Override //更新点赞 public void updateLike(Long id) { Long userId= UserHolder.getUser().getId(); //获取时间戳 long timestamp = System.currentTimeMillis(); //向ZSET中插入,看是否点过赞了 Boolean success = stringRedisTemplate.opsForZSet().add(RedisConstants.BLOG_LIKED_KEY + id, userId.toString(), timestamp); if(!Boolean.TRUE.equals(success)){ //点过了赞就无法插入,就取消点赞,点赞数减一,从点赞集合中移除用户 boolean success1 =update().setSql(\u0026#34;liked = liked - 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); if(success1) { stringRedisTemplate.opsForZSet().remove(RedisConstants.BLOG_LIKED_KEY + id, userId.toString()); } }else{ //没点过赞就可以插入,点赞数量加一 update().setSql(\u0026#34;liked = liked + 1\u0026#34;).eq(\u0026#34;id\u0026#34;, id).update(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Override public Result selectLike(Long id) { //从ZSET中取最早点赞的5个人 Set\u0026lt;String\u0026gt; ids = stringRedisTemplate.opsForZSet().range(RedisConstants.BLOG_LIKED_KEY + id, 0, 4); if(ids==null||ids.size()==0){ return Result.ok(); } //获取点赞人的Id,然后查表,查到人后返回icon和username List\u0026lt;Long\u0026gt; list=new ArrayList\u0026lt;\u0026gt;(); for (String userId : ids) { list.add(Long.parseLong(userId)); } String strId= StrUtil.join(\u0026#34;,\u0026#34;,ids); List\u0026lt;User\u0026gt; users = userService.query() .in(\u0026#34;id\u0026#34;, ids) .last(\u0026#34;order by field(id,\u0026#34;+strId+\u0026#34;)\u0026#34;) .list(); List\u0026lt;UserDTO\u0026gt; userDTOS = new ArrayList\u0026lt;\u0026gt;(); for (User user : users) { UserDTO userDTO = new UserDTO(); //只返回icon,userId和userName,其实userName都可以不传 BeanUtils.copyProperties(user, userDTO); userDTOS.add(userDTO); } return Result.ok(userDTOS); } 关注与互关 关注 关注很好办,只用在数据库的follow表中插入一条数据,谁关注了谁,业务逻辑非常EZ\n查看互关 现在有用户A,B,C.A关注了C,B也关注了C,这时候我们如果是A,我们盒B的账号的时候就能发现,我们共同关注了C,实现这个功能需要两个关注列表取交集,这就可以用到Redis的SET集合了\n在关注好友的时候同时创建集合,集合名就是被关注用户的ID,集合内容就是关注者的ID\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Result followServer(Long bloggerId, Boolean isFollow) { Long userId= UserHolder.getUser().getId(); if(isFollow){ Follow follow=new Follow(); follow.setUserId(userId); follow.setFollowUserId(bloggerId); follow.setCreateTime(LocalDateTime.now()); followMapper.insert(follow); stringRedisTemplate.opsForSet().add(RedisConstants.FOLLOW+userId.toString(),bloggerId+\u0026#34;\u0026#34;); logger.info(\u0026#34;id为\u0026#34;+userId+\u0026#34;的用户关注了id为\u0026#34;+bloggerId+\u0026#34;的用户\u0026#34;); }else if(!isFollow){ followMapper.deleteByUserId(userId,bloggerId); logger.info(\u0026#34;id为\u0026#34;+userId+\u0026#34;取消关注了id为\u0026#34;+bloggerId+\u0026#34;的用户\u0026#34;); stringRedisTemplate.opsForSet().remove(RedisConstants.FOLLOW+userId.toString(),bloggerId+\u0026#34;\u0026#34;); } return Result.ok(); } 然后我们写查询共同关注者的时候就可以用set的\n下面是redis里实现set的取交集\n1 2 3 4 5 6 7 8 127.0.0.1:6379\u0026gt; SADD key1 a b c d (integer) 4 127.0.0.1:6379\u0026gt; SADD key2 c d e f (integer) 4 127.0.0.1:6379\u0026gt; SADD key3 a c e (integer) 3 127.0.0.1:6379\u0026gt; SINTER key1 key2 key3 1) \u0026#34;c\u0026#34; 在java代码中我们可以这么写,用java中的Set集合接收共同关注者的id\n1 Set\u0026lt;String\u0026gt; intersect = stringRedisTemplate.opsForSet().intersect(RedisConstants.FOLLOW + userId.toString() , RedisConstants.FOLLOW+id.toString()); 然后共同关注就做好了\nfeed流\u0026amp;滚动分页查询 Feed流是一种常见的信息展示方式\nfeed流定义 Feed流是一种基于用户社交关系或兴趣偏好的信息分发机制。它通过动态地向用户推送个性化的内容，让用户在浏览过程中能够快速获取到自己感兴趣的信息。\n核心特点 个性化推荐：Feed流会根据用户的浏览历史、兴趣标签、社交关系等多维度数据，为每个用户量身定制内容。例如，抖音会根据用户点赞、关注、评论等行为，推荐相关的短视频；微博会根据用户的关注列表和兴趣偏好，推送微博动态。\n动态更新：内容会实时更新，用户每次刷新页面或打开应用时，都能看到最新的信息。这种动态性让用户能够及时获取到新鲜的内容，增强了用户的粘性和活跃度。\n分析B站的推送机制 当你特别关注了一个up主,那个up主每次发视频就会私信发送给你,这叫推模式,直接推送给个人\n如果你直接去查看up主的主页,你就能看到他所有的内容,这种叫拉模式,拉取up主的所有内容\n上述两种模式,推模式不适合大V,如果不特别关注就推送,那么网络资源消耗过大.\n这次我要用Redis实现推模式,写一个feed流\n设计思路 我们要实现推流,就要在博主发送blog的时候把信息发到关注他的粉丝账号上,我们先查数据库,找到粉丝id,然后选取Redis数据结构来存储推流信息.\nList和SortedSet都可以来记录有序集合,但是要实现分页滚动查询,还是用ZSET好 我们可以这样写保存blog的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Override public Result saveBlog(Blog blog) { // 获取登录用户 UserDTO user = UserHolder.getUser(); blog.setUserId(user.getId()); // 保存探店博文 boolean saveSuccess = blogService.save(blog); if(!saveSuccess){ return Result.fail(\u0026#34;发布笔记失败\u0026#34;); } List\u0026lt;Long\u0026gt; idList=userMapper.selectByFollower(user.getId()); if(idList!=null\u0026amp;\u0026amp;!idList.isEmpty()){ for(Long id:idList){ stringRedisTemplate.opsForZSet().add(RedisConstants.FEED_KEY + id, blog.getId().toString(), System.currentTimeMillis()); } } // 返回id return Result.ok(blog.getId()); } 存储结果是这样的\n我们以时间戳作为分数,越靠前的blog时间戳大,到时候用户最先看到的就是最新消息\n滚动分页查询 用户每次查询2条记录,记录按照时间戳来排序,第一次查询的最大时间戳为当前时间,要找到最新的消息,后面再查就是上一次查到的最小的时间戳,然后偏移量加一,因为要查询后面两条,偏移量是通过之前重复时间戳数量计算出来的,当很多人同时建立blog时,时间戳可能会一样,这时候就得去重,加上偏移量\n附Java代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @Override public Result queryBlogByUserId(Long time, Long offset) { Long userId=UserHolder.getUser().getId(); Set\u0026lt;ZSetOperations.TypedTuple\u0026lt;String\u0026gt;\u0026gt; typedTuples; if(offset==0){ typedTuples= stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(RedisConstants.FEED_KEY + userId, 0, System.currentTimeMillis(), offset, 2); }else{ typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(RedisConstants.FEED_KEY + userId, 0, time, offset, 2); } if(typedTuples==null|| typedTuples.isEmpty()){ return Result.fail(\u0026#34;没有文章可以看了捏\u0026#34;); } List\u0026lt;Blog\u0026gt; blogs = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Long\u0026gt; score=new ArrayList\u0026lt;\u0026gt;(); for (ZSetOperations.TypedTuple\u0026lt;String\u0026gt; object : typedTuples) { score.add(Objects.requireNonNull(object.getScore()).longValue()); Blog blog = blogMapper.selectById(Long.parseLong(Objects.requireNonNull(object.getValue()))); blogs.add(blog); } int count=1; Long lastScore=score.get(0); for (int i = 1; i \u0026lt; score.size(); i++) { if(score.get(i)!=lastScore){ count=1; lastScore=score.get(i); }else{ count++; } } ScrollResult scrollResult = new ScrollResult(); scrollResult.setList(blogs); scrollResult.setMinTime(score.get(score.size()-1)); scrollResult.setOffset(count); return Result.ok(scrollResult); } 注意reverseRangeByScoreWithScores函数参数顺序,集合名称,分数最小值,分数最大值,偏移量,查询信息数,这个函数可以同时返回score和value\n最后的效果: ","date":"2025-03-16T20:30:40+08:00","permalink":"https://LuciusWan.github.io/p/redis%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E6%88%98/","title":"Redis学习与实战"},{"content":"Docker初体验 Docker 是什么 Docker 是一个应用打包、分发、部署的工具\n你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要，\n而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。\n跟普通虚拟机的对比 特性 普通虚拟机 Docker 跨平台 通常只能在桌面级系统运行，例如 Windows/Mac，无法在不带图形界面的服务器上运行 支持的系统非常多，各类 windows 和 Linux 都支持 性能 性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了 性能好，只虚拟软件所需运行环境，最大化减少没用的配置 自动化 需要手动安装所有东西 一个命令就可以自动部署好所需环境 稳定性 稳定性不高，不同系统差异大 稳定性好，不同系统都一样部署方式 打包、分发、部署 打包：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包\n分发：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装\n部署：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一模一样的运行环境，不管是在 Windows/Mac/Linux。\n下载\u0026amp;安装docker 下面是桌面版链接,点击下载\nhttps://www.docker.com/products/docker-desktop\n推荐下载这个\n下载完后是个exe文件,点开后开始安装\n我们在安装完成后可能会遇到这个报错\n这是因为我们没开启虚拟化,如果你下载过Linux虚拟机应该就不会有这个错误,同时我们还要下载Linux子系统,跟着引导来就好\n解决方法：\n控制面板-\u0026gt;程序-\u0026gt;启用或关闭 windows 功能，开启 Windows 虚拟化和 Linux 子系统（WSL2)\n要确定BIOS支持虚拟化\n添加镜像源 我们如果每次都到docker官方去获取镜像,那么没有魔法就会非常慢,所以我们可以添加镜像源\n可用的国内镜像源如下.可以添加多个镜像源\n镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker-cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://ud6340vz.mirror.aliyuncs.com 七牛云 https://reg-mirror.qiniu.com 网易云 https://hub-mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com 用docker安装软件 我们可以下载个redis玩玩\n下载Redis镜像 打开命令提示符（CMD）或PowerShell，然后使用以下命令从Docker Hub下载官方的Redis镜像：\n1 docker pull redis 这将下载最新版本的Redis镜像。你也可以指定版本号来下载特定版本的Redis镜像，例如：\n1 docker pull redis:latest 运行Redis容器 下载完成后，你可以使用以下命令来启动一个Redis容器：\n1 docker run --name my-redis -d -p 6379:6379 redis 这里的参数解释如下：\n--name my-redis：为容器指定一个名称，这里是my-redis。 -d：表示以分离模式运行容器,在后台运行。 -p 6379:6379：将容器的6379端口映射到宿主机的6379端口，这样你就可以通过宿主机的6379端口访问Redis服务。 验证Redis服务 为了验证Redis服务是否正常运行，你可以使用以下命令连接到Redis容器：\n1 docker exec -it my-redis redis-cli 这将打开一个Redis命令行接口。你可以在这里输入Redis命令来测试服务，例如：\n1 ping 如果服务正常运行，你应该看到输出PONG。\n我们可以在docker的终端上打开redis并使用 停止和删除容器 当你完成测试并想要停止Redis容器时，可以使用以下命令：\n1 docker stop my-redis 要删除容器，可以使用：\n1 docker rm my-redis 如果你想要强制删除正在运行的容器，可以添加-f参数：\n1 docker rm -f my-redis 配置Redis密码（可选） 如果你需要为Redis设置密码，可以在运行容器时通过环境变量REDIS_PASSWORD来设置。例如：\n1 docker run --name my-redis -d -p 6379:6379 -e REDIS_PASSWORD=mypassword redis redis-server --requirepass mypassword 这将设置Redis的密码为mypassword。之后，你需要使用这个密码来连接到Redis服务。\n制作自己的镜像 我们可以把自己的项目打包成一个镜像,让这个镜像在别的电脑上不配环境就能跑起来\n下面是springboot项目的制作镜像案例\n在制作镜像的时候,我们要先写一个dockerfile,这个dockerfile怎么写可以直接问AI\nSpringBoot的dockerfile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 使用官方的 OpenJDK 作为基础镜像,写清楚你的jdk版本 FROM openjdk:17-jdk-alpine # 设置工作目录 WORKDIR /app # 将构建好的 JAR 文件复制到镜像中 COPY target/你的jar包的名字.jar /app/app.jar # 暴露应用运行的端口（例如 Spring Boot 默认的 8080 端口） EXPOSE 8083 # 设置容器启动时运行的命令 ENTRYPOINT [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;app.jar\u0026#34;] 这个文件就跟src和pom.xml坐一桌(放一块)就行了\n然后我们就可以通过下面的命令来制作这个docker镜像\n1 docker build -t test:v1 . test是镜像的名称,v1是版本号\n然后我们可以在本地跑一下这个镜像\n1 docker run -p 8083:8083 --name test-hello test:v1 \u0026ndash;name test-hello指的是容器的名称是test-hello,后面跟的是要跑的是什么镜像的什么版本\n多容器通信 多容器通信的意义 在Docker中，多容器通信是指多个容器之间能够相互发现并进行数据交换的能力。\n这种通信机制在构建微服务架构和分布式应用时尤为重要，因为它允许不同服务之间高效地协作。\nDocker提供了多种网络模式来实现容器间的通信，包括桥接网络（Bridge）、主机网络（Host）、覆盖网络（Overlay）以及Macvlan网络等。\n在本地,我们通过本地回环的测试网络localhost127.0.0.1来相互通信,前端代码,后端代码,中间件,数据库等都通过127.0.0.1通信,而我们在docker部署多个容器并没有这样一个网络实现容器间通信,这时候就要用这样个网络.\n上面三种网络形式挺麻烦的,我们直接用docker-compose.yml,当容器多了,这种方法的好处就体现出来了. 举个例子 我的这个项目要用到3个redis,还有rabbitmq,下面这个是我的docker-compose.yml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 services: springboot-app: image: test:v1 # 替换为你的 Spring Boot 应用镜像 ports: - \u0026#34;8083:8083\u0026#34; # 假设 Spring Boot 应用运行在 8080 端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq networks: - my-network redis1: image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; # 映射 6379 端口 networks: - my-network redis2: image: redis:latest ports: - \u0026#34;6380:6379\u0026#34; # 映射 6380 端口 networks: - my-network redis3: image: redis:latest ports: - \u0026#34;6381:6379\u0026#34; # 映射 6381 端口 networks: - my-network rabbitmq: image: rabbitmq:3.12-management ports: - \u0026#34;5672:5672\u0026#34; # AMQP协议端口 - \u0026#34;15672:15672\u0026#34; # 管理界面端口 environment: RABBITMQ_DEFAULT_USER: YourUserName RABBITMQ_DEFAULT_PASS: YourPassword #volumes: # - ./rabbitmq/data:/var/lib/rabbitmq networks: - my-network networks: my-network: 我们的这个网络就叫my-network,然后所有的容器都配置在这一个文件中,我们只需要在项目目录里面加上这个yml文件就可以准备启动整个项目了\n在这里打开终端,然后输入如下命令\n1 docker-compose up -d 然后项目就启动了\n这样可以方便快捷的实现容器间的通信互联\n容器的通信路由 我们的容器现在都在一个网络下了,我们要通过域名来访问对应的容器\n比如我这个java代码,这是Redisson的配置代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package com.hmdp.config; import ... @Configuration public class RedissonConfig { @Autowired private RedisProperties redisProperties; @Bean public RedissonClient redisson6379() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://redis1:6379\u0026#34;); return Redisson.create(config); } @Bean public RedissonClient redisson6380() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://redis2:6379\u0026#34;); return Redisson.create(config); } @Bean public RedissonClient redisson6381() { Config config = new Config(); config.useSingleServer().setAddress(\u0026#34;redis://redis3:6379\u0026#34;); return Redisson.create(config); } } ip地址localhost改写为容器的名称,也就是容器的域名\n后面的端口一定要是镜像暴露出来的端口,redis暴露出来的就是6379端口\nrabbitmq的配置也要改\n1 2 3 4 5 6 rabbitmq: host: rabbitmq port: 5672 username: YourUserName password: YourPassword virtual-host: / host要改为容器名称.\nDocker部署MySQL 修改docker-compose.yml 想要在docker上部署MySQL,先要关掉MySQL的本地服务,可以直接在任务管理器里找mysql,然后关闭这个任务即可.\n然后修改docker-compose.yml，加上这个即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 mysql: image: mysql:8.0 ports: - \u0026#34;3306:3306\u0026#34; environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: YourDataBaseName #MYSQL_USER: your_username #MYSQL_PASSWORD: your_password volumes: - ./mysql/data:/var/lib/mysql networks: - my-network 1 2 volumes: - ./mysql/data:/var/lib/mysql 这个语句的意思是挂载目录\n挂载目录 在使用 Docker 部署 MySQL 时，挂载目录（通常使用 Docker 的 volume 功能）主要有以下几个目的：\n1. 数据持久化 背景：Docker 容器是无状态的，当容器被删除或重新启动时，容器内部的数据（如 MySQL 数据库文件）会丢失。\n解决方案：通过挂载宿主机的目录到容器内部，可以将 MySQL 的数据文件存储在宿主机上。这样，即使容器被删除或重新启动，数据仍然可以被保留。\n2 . 方便数据迁移 背景：当需要将数据库从一个环境迁移到另一个环境时，数据的迁移是一个关键步骤。\n解决方案：通过挂载目录，可以直接将宿主机上的数据目录复制到新的宿主机上，然后启动新的 MySQL 容器，从而实现数据的迁移。\n示例：\n1 2 # 将数据目录从旧宿主机复制到新宿主机 scp -r /path/to/mysql-data user@new-host:/path/to/mysql-data 具体就是这个语句让我本地建了个文件夹，实现了持久化存储\n然后我们在终端上登录mysql,使用对应的数据库,然后把表数据填进去就可以再次启动容器了\n实现多端负载均衡 我的这个项目是开了8083和8084端口同时接受前端请求,用nginx实现负载均衡,目前只开放了8083端口,修改docker-compose.yml即可\n修改docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 springboot-app-2: image: hmdp:v1 ports: - \u0026#34;8084:8083\u0026#34; # 映射8084端口到容器的8080端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq - mysql networks: - my-network 加入这个语句即可,启动后就实现了多端口接收数据\n发布Docker镜像 镜像仓库介绍 镜像仓库用来存储我们 build 出来的“安装包”，Docker 官方提供了一个 镜像库，里面包含了大量镜像，基本各种软件所需依赖都有，要什么直接上去搜索。\n我们也可以把自己 build 出来的镜像上传到 docker 提供的镜像库中，方便传播。\n当然你也可以搭建自己的私有镜像库，或者使用国内各种大厂提供的镜像托管服务，例如：阿里云、腾讯云\n上传镜像 首先要 注册一个账号 创建一个镜像库 然后在命令行中登录一下\n注意:这里登录只能是小写字母,之前写的大写字母username也得转为小写\n新建一个tag，名字必须跟你注册账号一样 1 docker tag test:v1 username/test:v1 推上去 1 docker push username/test:v1 然后我们可以随便新建一个文件夹,修改一下docker-compose.yml文件,然后粘过来\n修改docker-compose.yml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 services: springboot-app: image: luciuswan/hmdp:v1 # 替换为你的 Spring Boot 应用镜像 ports: - \u0026#34;8083:8083\u0026#34; # 假设 Spring Boot 应用运行在 8083 端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq - mysql networks: - my-network springboot-app-2: image: luciuswan/hmdp:v1 # 替换为你的 Spring Boot 应用镜像 ports: - \u0026#34;8084:8083\u0026#34; # 映射 8084 端口到容器的 8083 端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq - mysql networks: - my-network redis1: image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; # 映射 6379 端口 networks: - my-network redis2: image: redis:latest ports: - \u0026#34;6380:6379\u0026#34; # 映射 6380 端口 networks: - my-network redis3: image: redis:latest ports: - \u0026#34;6381:6379\u0026#34; # 映射 6381 端口 networks: - my-network rabbitmq: image: rabbitmq:3.12-management ports: - \u0026#34;5672:5672\u0026#34; # AMQP 协议端口 - \u0026#34;15672:15672\u0026#34; # 管理界面端口 environment: RABBITMQ_DEFAULT_USER: LuciusWan RABBITMQ_DEFAULT_PASS: Wwwaxk12345@ networks: - my-network mysql: image: mysql:8.0 ports: - \u0026#34;3306:3306\u0026#34; environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: hmdp volumes: - ./mysql/data:/var/lib/mysql networks: - my-network networks: my-network: driver: bridge 主要是修改这个image\n1 image: luciuswan/hmdp:v1 docker,启动! 然后在这里启动powershell,输入命令即可运行项目\n1 docker-compose -p hmdp up -d 如果直接输入docker-compose -d,会提示你没有容器名称\n正常输入的话,我们的项目就跑起来了\n这时候还跑不了,因为数据没有迁移\nDocker数据迁移 部署的时候每次都得重新建数据库,建表,这样并没有提现到docker的方便部署,我们可以通过docker指令来复制docker中的mysql数据库,然后复制到宿主机,也就是windows本地,然后把这个文件送到别的宿主机\n1. 备份旧容器的数据 在旧容器中，使用mysqldump工具备份数据库。\n步骤： 进入旧MySQL容器：\n1 docker exec -it \u0026lt;旧容器名称或ID\u0026gt; bash 备份所有数据库：\n1 mysqldump -u root -p --all-databases \u0026gt; /backup_all_databases.sql 如果只需要备份特定数据库，可以指定数据库名称：\n1 mysqldump -u root -p your_database_name \u0026gt; /backup_your_database.sql 将备份文件从旧容器复制到宿主机：\n1 docker cp \u0026lt;旧容器名称或ID\u0026gt;:/backup_all_databases.sql ./backup_all_databases.sql 效果如下图\n2. 将备份文件上传到新机器 将备份文件（如backup_all_databases.sql）上传到目标机器上。可以使用文件传输工具（如SCP、FTP、WinSCP等）。\n我是直接上传到云服务器了\n3. 在新机器上使用docker-compose部署MySQL 确保你的docker-compose.yml文件正确配置，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 services: springboot-app: image: hmdp:v1 # 替换为你的 Spring Boot 应用镜像 ports: - \u0026#34;8083:8083\u0026#34; # 假设 Spring Boot 应用运行在 8080 端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq - mysql networks: - my-network springboot-app-2: image: hmdp:v1 ports: - \u0026#34;8084:8083\u0026#34; # 映射8084端口到容器的8080端口 depends_on: - redis1 - redis2 - redis3 - rabbitmq - mysql networks: - my-network redis1: image: redis:latest ports: - \u0026#34;6379:6379\u0026#34; # 映射 6379 端口 networks: - my-network redis2: image: redis:latest ports: - \u0026#34;6380:6379\u0026#34; # 映射 6380 端口 networks: - my-network redis3: image: redis:latest ports: - \u0026#34;6381:6379\u0026#34; # 映射 6381 端口 networks: - my-network rabbitmq: image: rabbitmq:3.12-management ports: - \u0026#34;5672:5672\u0026#34; # AMQP协议端口 - \u0026#34;15672:15672\u0026#34; # 管理界面端口 environment: RABBITMQ_DEFAULT_USER: LuciusWan RABBITMQ_DEFAULT_PASS: Wwwaxk12345@ #volumes: # - ./rabbitmq/data:/var/lib/rabbitmq networks: - my-network mysql: image: mysql:8.0 container_name: mysql ports: - \u0026#34;3306:3306\u0026#34; environment: MYSQL_ROOT_PASSWORD: 123456 MYSQL_DATABASE: hmdp #MYSQL_USER: your_username #MYSQL_PASSWORD: your_password volumes: - ./mysql/data:/var/lib/mysql networks: - my-network networks: my-network: 运行以下命令启动服务：\n1 docker-compose -p hmdp up -d 在宝塔面板里面进入包含这个yml文件的文件夹中\n1 2 3 4 cd /www cd wwwroot cd hmdp docker-compose -p hmdp up -d 这样,容器就在新的宿主机启动了\n4. 将备份数据恢复到新容器 将备份文件复制到新容器：\n1 docker cp ./backup_all_databases.sql mysql-container:/backup_all_databases.sql 进入新容器并恢复数据：\n1 docker exec -it mysql-container bash 在容器内部，运行以下命令恢复数据：\n1 mysql -u root -p \u0026lt; /backup_all_databases.sql 输入root用户的密码后，数据将被恢复到新容器中。\n然后我们的数据就同步在新的宿主机了\n5. 验证数据 在新容器中登录MySQL，检查数据是否正确恢复：\n1 docker exec -it mysql-container mysql -u root -p 输入密码后，执行以下命令查看数据库列表：\n1 SHOW DATABASES; 确保你的数据库和数据已经正确恢复。\n然后项目就可以正常跑起来了,如果遇到java代码无法连接MySQL,并且原因是MySQL不支持publicKey,可以在配置MySQL连接方式处这么修改\n然后我们这个项目在哪里跑都一样了\n","date":"2025-04-08T14:25:17+08:00","permalink":"https://LuciusWan.github.io/p/docker%E5%88%9D%E4%BD%93%E9%AA%8C/","title":"Docker初体验"},{"content":"Linux实战 OpenEuler安装 可以参考这个up主的视频 B站视频链接 下载VirtualBox虚拟机 在浏览器官网搜索virtualBox官网Oracle VirtualBox然后直接下载即可\n打开VirtualBox后发现并没有操作系统(),那么我们就再去浏览器下载openEuler操作系统\n下载OpenEuler操作系统 在浏览器上搜索OpenEuler社区openEuler | 开源社区 | openEuler社区官网\n点开后找到Offline Everything ISO，下载就好了\n事实上并没有删除()\n在VirtualBox中加载OpenEuler 点击注册,然后按照下图配置\n然后新建虚拟电脑的时候配置一下\n全都配置好就可以使用了\n注意!!!一定要记住自己的root密码 OpenEuler实践报告 一、实验环境 操作系统：OpenEuler（通过VirtualBox虚拟机运行） 编译器：GCC 二、作业要求的代码 例1：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { fork(); fork(); fork(); printf(\u0026#34;hello\\n\u0026#34;); return 0; } 例2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main() { int x = 1; pid_t p = fork(); if(p \u0026lt; 0){ perror(\u0026#34;fork fail\u0026#34;); exit(1); } else if (p == 0) printf(\u0026#34;Child has x = %d\\n\u0026#34;, ++x); else printf(\u0026#34;Parent has x = %d\\n\u0026#34;, --x); return 0; } 例题一操作 创建文件并输入代码：\n1 vim example1.c 将例1的代码复制到文件中，保存并退出。\n编译代码：\n1 gcc example1.c -o example1 如果没有错误，将生成可执行文件example1。\n运行程序：\n1 ./example1 观察输出结果。\n运行结果及分析 例1运行结果：\n1 2 3 4 5 6 7 8 hello hello hello hello hello hello hello hello 例一分析： 每次fork()调用都会创建一个新的进程，三次fork()会创建8个进程（2^3），每个进程都会执行printf(\u0026quot;hello\\n\u0026quot;);，所以输出8次\u0026quot;hello\u0026quot;。\n例题二操作 创建文件并输入代码：\n1 vim example2.c 将例1的代码复制到文件中，保存并退出。\n编译代码：\n1 gcc example2.c -o example2 如果没有错误，将生成可执行文件example1。\n运行程序：\n1 ./example2 观察输出结果。\n运行结果及分析 例2运行结果：\n例二分析：\n父进程和子进程各自拥有变量x的独立副本。 子进程中x的值被递增（++x），所以输出2。 父进程中x的值被递减（--x），所以输出0。 五、总结 通过本次实践，我掌握了在Linux环境下使用GCC编译C代码的基本流程，理解了fork()系统调用的原理和用法，以及进程控制的基本概念。同时，也熟悉了在OpenEuler操作系统下的开发环境和工具的使用。\nHW3-多线程-git 1. 编写和编译多线程代码 1.1 创建代码文件 在Linux命令行中，使用vi或nano编辑器创建一个名为pthread_hello.c的文件：\n1 vi pthread_hello.c 编写如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; /* Thread function that prints \u0026#34;Hello World\u0026#34; */ void *worker(void *arg) { printf(\u0026#34;Hello World!\\n\u0026#34;); return NULL; /* Thread exits (dies) */ } int main() { pthread_t thread; int ret; /* Create a new thread */ ret = pthread_create(\u0026amp;thread, NULL, worker, NULL); if (ret != 0) { perror(\u0026#34;pthread_create failed\u0026#34;); return 1; } /* Wait for the thread to finish */ pthread_join(thread, NULL); return 0; } 1.2 编译代码 使用gcc编译代码，并链接pthread库：\n1 gcc pthread_hello.c -o pthread_hello -lpthread 1.3 运行程序 运行编译后的程序：\n1 ./pthread_hello 输出结果为：\nHello World!\n2. 使用Git管理项目 2.1 创建项目目录 在主目录下创建一个名为os_practice的项目目录：\n1 2 mkdir os_practice cd os_practice 2.2 初始化Git仓库 初始化Git仓库：\n1 git init 2.3 创建子目录 为每次的实践创建单独的子目录，例如：\n1 2 mkdir hw1 cd hw1 将pthread_hello.c文件复制到该目录下：\n1 cp ~/pthread_hello.c . 2.4 添加文件到Git 将文件添加到Git仓库：\n1 git add pthread_hello.c 2.5 提交更改 提交更改并添加描述信息：\n1 git commit -m \u0026#34;Added pthread Hello World example\u0026#34; 2.6 检查Git状态 检查当前Git仓库的状态：\n1 git status 提交代码至github 在github中注册好之后,创建代码仓库 创建好之后,使用github给的bash代码 1 2 3 4 5 6 7 echo \u0026#34;# OS-HomeWork\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/LuciusWan/OS-HomeWork.git git push -u origin main 然后本地仓库就和github连上了.\n我们可以在本地编译,提交代码至github仓库\n分别使用下面bash语句\n1 2 3 git add . git commit -m \u0026#34;update\u0026#34; git push git add .\n将当前工作区中的所有更改（包括新文件、修改的文件和删除的文件）添加到 Git 的暂存区\ngit commit -m \u0026ldquo;update\u0026rdquo;\n将暂存区中的更改正式提交到本地仓库，并添加一条提交信息。\n提交（commit）是 Git 的一个快照，记录了当前暂存区中的所有更改。\n-m \u0026quot;update\u0026quot; 是提交信息，用来描述这次提交的内容或目的。\n提交信息是可选的，但强烈建议添加，以便以后能够清楚地了解每次提交的更改内容。\ngit push\n很好理解,把本地仓库修改内容和修改信息一并推送到远程仓库\n提交后,我们的仓库就会发生变化 ","date":"2025-03-21T14:01:52+08:00","permalink":"https://LuciusWan.github.io/p/linux%E5%AE%9E%E6%88%98/","title":"Linux实战"},{"content":"JavaWeb 三层解耦 这里会用到面向对象七大原则中的单一职责原则，即每个程序有自己的任务，而不是有很多任务导致单一程序复杂，耦合度高，复用性差\n我们可以将后端划分为三个部分，MVC框架是Controller，View，Model\n而springboot可以划分为Controller，Service，Dao三层，分别为监听层，逻辑处理层，数据管理层，原来复杂的Controller层是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @RestController public class EmpController { String file= this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; EmpList= XmlParserUtils.parse(file, Emp.class); empList.stream().forEach(emp -\u0026gt; { String gender = emp.getGender(); String job = emp.getJob(); if(gender.equals(\u0026#34;1\u0026#34;)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(gender.equals(\u0026#34;2\u0026#34;)){ emp.setGender(\u0026#34;女\u0026#34;); } if(job.equals(\u0026#34;1\u0026#34;)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(job.equals(\u0026#34;2\u0026#34;)){ emp.setJob(\u0026#34;班主任\u0026#34;); } else if (job.equals(\u0026#34;3\u0026#34;)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } });); List\u0026lt;Emp\u0026gt; empList=empServiceA.list(); System.out.println(empList); return Result.success(empList); } } 现在可以使用三层架构来分别放置 Controller，Service，Dao三层\nDao层的接口及实现如下 1 2 3 public interface EmpDao { public List\u0026lt;Emp\u0026gt; listEmp(); } 1 2 3 4 5 6 7 8 9 10 11 public class EmpDaoA implements EmpDao { @Override public List\u0026lt;Emp\u0026gt; listEmp() { //加载并解析XML文件 String file= this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; EmpList= XmlParserUtils.parse(file, Emp.class); return EmpList; } } Service层的接口及实现如下 1 2 3 public interface EmpService { public List\u0026lt;Emp\u0026gt; list(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.List; public class EmpServiceA implements EmpService { private EmpDao empDao=new EmpDaoA(); @Override public List\u0026lt;Emp\u0026gt; list() { //对数据进行转化处理 List\u0026lt;Emp\u0026gt; empList=empDao.listEmp(); empList.stream().forEach(emp -\u0026gt; { String gender = emp.getGender(); String job = emp.getJob(); if(gender.equals(\u0026#34;1\u0026#34;)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(gender.equals(\u0026#34;2\u0026#34;)){ emp.setGender(\u0026#34;女\u0026#34;); } if(job.equals(\u0026#34;1\u0026#34;)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(job.equals(\u0026#34;2\u0026#34;)){ emp.setJob(\u0026#34;班主任\u0026#34;); } else if (job.equals(\u0026#34;3\u0026#34;)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } 这里通过创建Dao层对象然后调用其方法来获取数据，但这会让Dao层和Service层紧耦合\nController代码如下 1 2 3 4 5 6 7 8 9 10 @RestController public class EmpController { private EmpServiceA empServiceA =new EmpServiceA(); @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list() { List\u0026lt;Emp\u0026gt; empList=empServiceA.list(); System.out.println(empList); return Result.success(empList); } } 同样的，这里的创建对象也会让Service层和Controller层紧耦合\n我们可以考虑使用设计模式中的工厂模式来解决这个紧耦合办法，但是springboot已经想好了解决对策，那就是\n控制反转与依赖注入 控制反转:Inversion Of control，简称IOC。对象的创建控制权由程序自身转移到外部(容器)，这种思想称为控制反转\n依赖注入: Dependency Injection，简称DI。容器为应用程序提供运行时所依赖的资源，称之为依赖注入。\nBean对象:IOC容器中创建、管理的对象，称之为Bean\n解耦之后的代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //Dao层 @Component public class EmpDaoA implements EmpDao { @Override public List\u0026lt;Emp\u0026gt; listEmp() { //加载并解析XML文件 String file= this.getClass().getClassLoader().getResource(\u0026#34;emp.xml\u0026#34;).getFile(); System.out.println(file); List\u0026lt;Emp\u0026gt; EmpList= XmlParserUtils.parse(file, Emp.class); return EmpList; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //Service层 @Component public class EmpServiceA implements EmpService { @Autowired private EmpDao empDao; @Override public List\u0026lt;Emp\u0026gt; list() { //对数据进行转化处理 List\u0026lt;Emp\u0026gt; empList=empDao.listEmp(); empList.stream().forEach(emp -\u0026gt; { String gender = emp.getGender(); String job = emp.getJob(); if(gender.equals(\u0026#34;1\u0026#34;)){ emp.setGender(\u0026#34;男\u0026#34;); }else if(gender.equals(\u0026#34;2\u0026#34;)){ emp.setGender(\u0026#34;女\u0026#34;); } if(job.equals(\u0026#34;1\u0026#34;)){ emp.setJob(\u0026#34;讲师\u0026#34;); }else if(job.equals(\u0026#34;2\u0026#34;)){ emp.setJob(\u0026#34;班主任\u0026#34;); } else if (job.equals(\u0026#34;3\u0026#34;)) { emp.setJob(\u0026#34;就业指导\u0026#34;); } }); return empList; } } 1 2 3 4 5 6 7 8 9 10 11 12 //Controller层 @RestController public class EmpController { @Autowired private EmpService empService; @RequestMapping(\u0026#34;/listEmp\u0026#34;) public Result list() { List\u0026lt;Emp\u0026gt; empList=empService.list(); System.out.println(empList); return Result.success(empList); } } 如果我此时要加入EmpDaoB（通过MySQL等数据库传送数据），那就吧EmpDaoA的@Component注释了\nspringboot给三层架构分别出了三个衍生注解@Repository，@Service，@Controller\n后续基本上都用数据库传输，并且springboot继承了Mybatis，Mybatis可以使用注解@Mapper来替代@Repository，而Controller层自带@RestController注解，因此可以不用@Controller\n@Component注解可以在不属于这三层，但是很有用的工具类上加这个注解\nPojo文件 pojo文件中存放各种JavaBean\nSpringboot特有的JavaBean写法，使用前要引入Lombok依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.test.springboottest03_crud.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.time.LocalDate; import java.time.LocalDateTime; @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entryDate; private Integer deptId; private LocalDateTime createTime;//创建时间 private LocalDateTime updateTime;//修改时间 } 这里用到了三个注解 @Data 同时包含了toString方法，HashCode，所有get，set方法\n@NoArgsConstructor 是无参构造\n@AllArgsConstructor 是全参构造\nMybatis的增删改查(注解写法) 在文件中创建mapper文件夹，创建对应的Mapper接口\n使用注解@Mapper\n1 2 3 4 5 6 7 8 9 @Mapper//程序开始时会自动创建代理对象 public interface EmpMapper { @Delete(\u0026#34;delete from emp where id=#{id}\u0026#34;) public int delete(Integer id); @Options(useGeneratedKeys = true,keyProperty = \u0026#34;id\u0026#34;) @Insert(\u0026#34;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)\u0026#34; + \u0026#34; values (#{username},#{name},#{gender},#{image},#{job},#{entryDate},#{deptId},#{createTime},#{updateTime})\u0026#34;) public void insert(Emp emp); } 第一个是删除操作，@Delete里面写SQL语句，d=#{id}是Mybatis的占位符 使用Integer是因为int不支持不输入就是null，与SQL语句不吻合\n该删除操作删除的是指定id对象\n第二个是插入操作 写正常的insert语句，然后每个占位符都是JavaBean里面的，注意驼峰命名法\n插入操作的形参是JavaBean对象\nTest类的写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SpringBootTest03CrudApplicationTests { @Autowired EmpMapper empMapper; @Test public void testDelete() { int a = empMapper.delete(17); System.out.println(a); } public void testInsert() { //构造员工对象 Emp emp = new Emp(); emp.setUsername(\u0026#34;Tom7\u0026#34;); emp.setName(\u0026#34;汤姆3\u0026#34;); emp.setImage(\u0026#34;1.jpg\u0026#34;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntryDate(LocalDate.of(2000,1,1)); emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); //执行新增员工信息操作 empMapper.insert(emp); System.out.println(emp.getId()); } } 在测试类中，先用抽象父类创建对象，然后使用依赖注入@Autowire，等价于EmpMapper empMapp=new EmpMapperA()，把和数据库连接好的bean对象传过来，这样就可以对数据库或者xml等数据载体进行操作了。\n删除操作 前面定义了delete接口是int返回值，这里a返回为删除多少个对象\n1 2 3 public void testDelete() { int a = empMapper.delete(17); System.out.println(a); 插入操作 insert方法要将创建好的对象初始化后使用empMapper.insert(emp)来插入\n如果直接输出emp.getId()是没有结果的，在定义接口的时候使用注解@Options\n1 @Options(useGeneratedKeys = true,keyProperty = \u0026#34; 这样就可以返回Id了\n使用LocalDateTime.now()这个方法最后的返回值符合MySQL的date格式\n修改操作 mapper中的代码\n1 2 3 @Update(\u0026#34;update emp set username =#{username},name=#{name},gender=#{gender},image=#{image},\u0026#34; + \u0026#34;job=#{job},entrydate=#{entryDate},dept_id=#{deptId},update_time=#{updateTime} where id=#{id}\u0026#34;) public void update(Emp emp); Test中的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void testUpdate() { Emp emp = new Emp(); emp.setId(1); emp.setUsername(\u0026#34;Tom12\u0026#34;); emp.setName(\u0026#34;汤姆1\u0026#34;); emp.setImage(\u0026#34;1.jpg\u0026#34;); emp.setGender((short)1); emp.setJob((short)1); emp.setEntryDate(LocalDate.of(2000,1,1)); emp.setUpdateTime(LocalDateTime.now()); emp.setDeptId(1); empMapper.update(emp); } 查询操作 mapper中的代码\n1 2 @Select(\u0026#34;select * from emp where id=#{id}\u0026#34;) public Emp selectById(Integer id); Test中的代码\n1 2 3 4 5 6 public void testSelect() { Integer id=12; Emp emp= new Emp(); emp=empMapper.selectById(id); System.out.println(emp); } 这里是根据id来对数据查询，但是在注入对象empMapper对应的代理对象赋值的时候，数据库中的下划线命名法和java中的驼峰命名法冲突，导致后面使用驼峰命名法的字段赋值失败\n这时候可以在application.properties中输入camel+Tab 1 2 #Mybatis的驼峰命名法映射开关打开 mybatis.configuration.map-underscore-to-camel-case=true 这时候所有输出就对味了\n查询操作ProMax：模糊查询 对员工姓名进行模糊查询，对应的SQL语句是\n1 select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender=#{gender} and entrydate between #{begin} and #{end} order by update_time desc 其中‘%张%’的意思是其中有一个字是张就行了，前面和后面都有字也在查询范围里面，张无忌，我是张三等名字都可以被查询到，模糊查询要用关键词like，时间范围可以用between\n但是在@Select注解中不能直接这么写，‘%#{name}%’，其中#{name}不能放到引号里面，因为#{name}会在预编译期间变为？，如果是%?%那么任何一个索引都可以被查询到\n1 2 @Select(\u0026#34;select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender=#{} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by updateTime desc\u0026#34;) 可以调用函数concat(\u0026rsquo;%\u0026rsquo;,#{name},\u0026rsquo;%')\nTest代码为\n1 2 3 4 public void testSelectPlus() { List\u0026lt;Emp\u0026gt; empList=empMapper.selectAll(\u0026#34;张\u0026#34;,(short)1,LocalDate.of(2010,01,01),LocalDate.of(2020,01,01)); System.out.println(empList); } LocalDate.of(2010,01,01)可以输入时间\nMybatis的XML写法 要想使用XML映射来实现增删改查需要在resources中添加一致包名和xml文件\n注：在resources里面创建的不是软件包，是资源包，分隔符不是\u0026rsquo;.\u0026lsquo;而是\u0026rsquo;/\u0026rsquo;，之后会自动转化为\u0026rsquo;.\u0026rsquo;,并且之后创建的xml文件要和接口文档命名一致\n两种方法对比：\n1 2 3 4 //条件查询注解法 @Select(\u0026#34;select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender=#{gender} and \u0026#34; + \u0026#34;entrydate between #{begin} and #{end} order by update_time desc\u0026#34;) public List\u0026lt;Emp\u0026gt; selectAll(String name, Short gender, LocalDate begin, LocalDate end); 1 2 //xml法 public List\u0026lt;Emp\u0026gt; selectAll(String name, Short gender, LocalDate begin, LocalDate end); 1 2 3 4 5 6 7 8 9 10 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.test.springboottest03_crud.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.test.springboottest03_crud.pojo.Emp\u0026#34;\u0026gt; select * from emp where name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) and gender=#{gender} and entrydate between #{begin} and #{end} order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; XML法的前面部分是固定语句，可以直接从官网复制\n创建一个接口的xml语句可以先创建好接口，然后按下Alt+Enter点击最上面的选项\n然后就可以在xml文件里编辑了\n想通过这种方式创建得按照下面方式下载MybatisX插件\n在XML文件中，SQL语句很长，可以选中所有SQL语句然后按下Ctrl+Alt+L格式化\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update emp set username =#{username}, name=#{name}, gender=#{gender}, image=#{image}, job=#{job}, entrydate=#{entryDate}, dept_id=#{deptId}, update_time=#{updateTime} where id = #{id} \u0026lt;/update\u0026gt; 注：Ctrl+Alt+L可能被网易云音乐或者QQ占用，需要去对应的软件中关闭此快捷键\n不管哪一种方法，都要有方法体，只是说把SQL语句移到了xml文件中\n可以在IDEA中下载MybatisX插件，跳转非常方便\n官方提示 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。\n动态SQL语句 实际业务需求:\n所有搜索条件都是null，此时服务器发送数据为查找所有。\n当有搜索条件的时候，也有条件为null\n若直接写刚才的select语句很容易就搜索不到数据，因为搜索对应的值为null和无搜索条件逻辑不符，此时可以引入动态SQL语句\nSelect动态SQL语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.test.springboottest03_crud.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.test.springboottest03_crud.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender = #{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 其中语句可以判断是否有这个条件，如果没有则跳过这条语句。\n可以动态判断是否该加and，如果搜索条件为后面两个条件，那么SQL语句开头就是and导致语法错误，但是where可以解决这个问题\nUpdate的动态SQL语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username!=null\u0026#34;\u0026gt;username =#{username},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt;name=#{name},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt;gender=#{gender},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image!=null\u0026#34;\u0026gt;image=#{image},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job!=null\u0026#34;\u0026gt;job=#{job},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;entryDate!=null\u0026#34;\u0026gt;entrydate=#{entryDate},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId!=null\u0026#34;\u0026gt;dept_id=#{deptId},\u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime!=null\u0026#34;\u0026gt;update_time=#{updateTime}\u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id} \u0026lt;/update\u0026gt; 这里同样用到了if来设置默认搜索条件，并且引入来判断逗号是否多余导致的SQL语句错误，与的用法一致\n在上述xml写好后，修改条件就可以如下\n1 2 3 4 5 6 7 8 9 public void testUpdate() { Emp emp = new Emp(); emp.setId(12); emp.setUsername(\u0026#34;Sam54235\u0026#34;); /*emp.setName(\u0026#34;萨姆1\u0026#34;); emp.setImage(\u0026#34;1.jpg\u0026#34;); emp.setUpdateTime(LocalDateTime.now());*/ empMapper.update2(emp); } 动态SQL\u0026mdash;批量删除操作 一次性删除多个对象可以这样写SQL语句\n1 delete from emp where id in(18,21); 1 2 3 4 5 6 7 //接口部分这么写 public void deleteById(List\u0026lt;Integer\u0026gt; list); //Test类中这样写 public void deleteTest() { List\u0026lt;Integer\u0026gt; list = Arrays.asList(10, 11); empMapper.deleteById(list); } 因为要删除多个，所以此时传参以集合的方式传递，并且后面集合的名称要和xml中的一致\n在xml中需要这么写\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;deleteById\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;list\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 其中foreach操作可以遍历传递过来的集合list，然后拼凑出所要的sql语句\n其中collection是集合的名称，item是告诉sql语句这时候要按照什么进行删除，separator是SQL语句的分隔符，open和close分别是开始和结尾的字符#{id}通过占位符来加入数据，最后就可以形成(10,11)这样的语句，和之前的delete from emp where id in结合起来就是完整的SQL语句\nSQL代码复用 在企业中直接使用select * from emp速度没有全参访问速度快\n1 2 select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp 1 2 3 4 \u0026lt;sql id=\u0026#34;commonSelect\u0026#34;\u0026gt; select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp \u0026lt;/sql\u0026gt; 这时候可以使用动态SQL语句sql来封装SQL代码\nid就是以后调用的时候的名称\n要调用的时候就这样写\n1 2 3 4 \u0026lt;select id=\u0026#34;selectAll\u0026#34; resultType=\u0026#34;com.test.springboottest03_crud.pojo.Emp\u0026#34;\u0026gt; \u0026lt;include refid=\u0026#34;commonSelect\u0026#34;/\u0026gt; /**/ \u0026lt;/select\u0026gt; 简易Web网站开发 前端部分已经写好，我们只用对照产品经理写的API文档接口来写后端程序即可\n创建springboot项目，勾选springweb依赖，lombok依赖，mybaties和MySQL依赖\n在application.properties中配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 spring.application.name=SpringBootProject01 #????? spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver #??????url spring.datasource.url=jdbc:mysql://localhost:3306/springboottest #????????? spring.datasource.username=root #???????? spring.datasource.password=123456 #??mybatis???, ???????? mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #??mybatis??????????? a_column ------\u0026gt; aCloumn mybatis.configuration.map-underscore-to-camel-case=true----\u0026gt; aCloumn 配置MySQL信息，MySQL用户名，密码，还有Mybatis的驼峰命名法转蛇形命名法\n内容是查询所有部门，要求这里是Get请求，可以使用@GetMapping 使用三层架构，分别是DeptController，DeptService，DeptMapper\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @Slf4j @RestController @RequestMapping(\u0026#34;/depts\u0026#34;) public class DeptController { Dept dp=new Dept(); @Autowired private DeptService deptService; /*@RequestMapping(value = \u0026#34;/depts\u0026#34;,method = RequestMethod.GET)*/ @GetMapping() public Result list(){ log.info(\u0026#34;查询所有部门数据\u0026#34;); List\u0026lt;Dept\u0026gt; depts= deptService.list(); return Result.success(depts); } @DeleteMapping(\u0026#34;/{id}\u0026#34;) public Result delete(@PathVariable Integer id){ log.info(\u0026#34;删除所选部门数据\u0026#34;); deptService.delete(id); return Result.success(); } @PostMapping() public Result save(@RequestBody Dept dept){ log.info(\u0026#34;添加部门{}\u0026#34;, dept); deptService.save(dept); return Result.success(); } @GetMapping(\u0026#34;/{id}\u0026#34;) public Result select(@PathVariable Integer id){ log.info(\u0026#34;根据ID{}查询部门\u0026#34;, id); dp=deptService.select(id); return Result.success(dp); } @PutMapping() public Result update(@RequestBody Dept dept){ log.info(\u0026#34;修改部门{}\u0026#34;, dept); deptService.update(dept); return Result.success(); } } 这是DeptController的代码有@RequestMapping(\u0026quot;/depts)后可以在后面定义类似GetMapping(\u0026quot;/depts/{id}\u0026quot;)时直接省略前面的/depts\nResult类可以以统一格式把数据上传到前端，并且是JSON格式(这是个工具类，直接导入pojo包下即可)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.test.springbootproject01.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应信息 描述字符串 private Object data; //返回的数据 //增删改 成功响应 public static Result success(){ return new Result(1,\u0026#34;success\u0026#34;,null); } //查询 成功响应 public static Result success(Object data){ return new Result(1,\u0026#34;success\u0026#34;,data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } Service层用来处理数据，需要用到注解@Service\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; public List\u0026lt;Dept\u0026gt; list(){ List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); return deptList; } public void delete(Integer id){ deptMapper.delete(id); } public void save(Dept dept){ dept.setCreateTime(LocalDateTime.now()); dept.setUpdateTime(LocalDateTime.now()); deptMapper.save(dept); } @Override public void update(Dept dept) { dept.setUpdateTime(LocalDateTime.now()); deptMapper.update(dept); } @Override public Dept select(Integer id) { return deptMapper.list1(id); } } 最后到Mapper层用来和数据库对接，Mapper可以用XML来和数据库对接，也可以使用注解的方式，这里演示全用xml格式\n1 2 3 4 5 6 7 8 9 @Mapper public interface DeptMapper { /* @Select(\u0026#34;select * from springboottest.dept\u0026#34;)*/ public List\u0026lt;Dept\u0026gt; list(); public void delete(Integer id); public void save(Dept dept); public void update(Dept dept); public Dept list1(Integer id); } xml文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;insert id=\u0026#34;save\u0026#34;\u0026gt; insert into springboottest.dept(springboottest.dept.name,springboottest.dept.create_time,springboottest.dept.update_time) values(#{name},#{createTime},#{updateTime}) \u0026lt;/insert\u0026gt; \u0026lt;update id=\u0026#34;update\u0026#34;\u0026gt; update springboottest.dept set springboottest.dept.name=#{name},springboottest.dept.update_time=#{updateTime} where springboottest.dept.id=#{id} \u0026lt;/update\u0026gt; \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from springboottest.dept where id=#{id} \u0026lt;/delete\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.test.springbootproject01.pojo.Dept\u0026#34;\u0026gt; select * from springboottest.dept \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;list1\u0026#34; resultType=\u0026#34;com.test.springbootproject01.pojo.Dept\u0026#34;\u0026gt; select * from springboottest.dept where id=#{id} \u0026lt;/select\u0026gt; 这样Get请求从前端发送过来后，由后端Controller层接受请求，然后调用service层处理数据，然后service层再调用mapper层获取数据，最终处理完数据后返回给前端\n注意到这里update接口应当先根据ID查询到对应的数据，然后再将更改后的数据发送给服务端存储\n点击编辑按钮后，前端发送get请求，将查询到的数据发送到这个窗口页面上\n然后我们可以对其进行修改，然后将改正后的数据通过post请求发送给后端，然后后端对这个数据进行存储，完成了一次更新操作\n@PathVariable注解的使用 当前端发送数据且根据id给后端时，前端的id和后端的id不一定相同\n但是数据库中的内容并不是如此\n所以这里可以通过@PathVariable注解来寻找到之前数据库传过来的正确的id，格式如下\n1 2 3 4 5 6 @GetMapping(\u0026#34;/{id}\u0026#34;) public Result select(@PathVariable(\u0026#34;id\u0026#34;) Integer id) { log.info(\u0026#34;根据id{}查询数据\u0026#34;,id); Emp emp1=empService.selectId(id); return Result.success(emp1); } @RequestBody注解的使用 前端此时传回来的数据是JSON格式，并不能直接把这个数据转化为对象传给数据库做select或者存储，此时可以通过注解@RequestBody来转化为Java对象,格式如下\n1 2 3 4 5 6 @PutMapping public Result update(@RequestBody Emp emp){ log.info(\u0026#34;{}修改数据\u0026#34;,emp.getUsername()); empService.update(emp); return Result.success(); } 查询emp部分稍有麻烦\n分页查询员工 根据API接口文档\n前端返回的数据为当前页数和每页有多少个数据\n此时后端应当给前端返回的是当前页所查询到的数据和总共数据库中有多少条数据\n后面的查询很简单，可以直接用个select语句来完成\n1 select count(*) from springboottest.emp 前面的数据得用到分页查询，条件为limit #{page},#{pageSize}，\n此时EmpService得设置page和pageSize\n1 2 3 4 5 6 7 8 9 @Override public PojoBean select(String name, Short gender, LocalDate begin, LocalDate end, Integer page, Integer pageSize) { PojoBean pojoBean = new PojoBean(); pojoBean.setTotal(empMapper.count()); pojoBean.setRows(empMapper.list(name,gender,begin,end,(page-1)*pageSize,pageSize)); System.out.println((page-1)*pageSize); System.out.println(pageSize); return pojoBean; } 在数据库中limit 0,5代表第0索引开始，且每页有5个元素，前端应该是第1页，每页有5个元素，因此索引数和前端页码对上的话，索引为(page-1)*pageSize\n分页条件查询员工 此时前端可能会给出查询条件，姓名name，性别gender，入职时间，entryDate\n这些条件可能给，也可能全给，也可能给部分，也可能一个都不给，可以用之前提到的动态SQL语句来解决这个问题，这种复杂的sql语句不能用注解来写，只能通过XML文件配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.test.springbootproject01.pojo.Emp\u0026#34;\u0026gt; select * from springboottest.emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name!=null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;,#{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender!=null\u0026#34;\u0026gt; and gender=#{gender} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin!=null and end!=null\u0026#34;\u0026gt; and entrydate between #{begin} and #{end} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; limit #{page},#{pageSize} \u0026lt;/select\u0026gt; 前端总共返回的数据如下\n1 2 3 4 5 6 7 @GetMapping public Result emp(String name, Short gender, LocalDate begin, LocalDate end, @RequestParam(defaultValue = \u0026#34;1\u0026#34;) Integer page, @RequestParam(defaultValue = \u0026#34;10\u0026#34;) Integer pageSize) { PojoBean pb=empService.select(name,gender,begin,end,page,pageSize); return Result.success(pb); } @RequestParam 注解的使用 @RequestParam注解可以让参数有默认值，这样用户不使用任何条件查询就可以查询到默认的10条记录\n最终给前端因为要返回两种数据，一个是总页数，一个是查询到的员工的list集合\n因此这时候创建一个PojoBean类\n最后把数据封装好后以Result的标准JSON格式返回给前端\n批量删除员工 前端返回的删除指令可能有多条，这时候返回来的是个数组\n1 2 3 4 5 6 @DeleteMapping(\u0026#34;/{ids}\u0026#34;) public Result delete(@PathVariable(\u0026#34;ids\u0026#34;) Integer [] ids) { log.info(\u0026#34;删除所选员工数据\u0026#34;); empService.delete(ids); return Result.success(); } 接受到前端的数据后可以去service层,然后再把数组交给Mapper层\n最后的xml语句为\n1 2 3 4 5 6 \u0026lt;delete id=\u0026#34;delete\u0026#34;\u0026gt; delete from springboottest.emp where springboottest.emp.id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt; 安全性与认证 API接口使用JWT（JSON Web Token）进行认证，确保请求的安全性。如果登录成功就获得一个令牌，每次访问网站都会检查jwt令牌是否有效，同时可以给jwt令牌设置有效时限。\nJWT认证示例（Spring Security集成JWT）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; public class JwtTokenFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException { String token = request.getHeader(\u0026#34;Authorization\u0026#34;); if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { // Validate and parse JWT token here UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user, null, authorities); SecurityContextHolder.getContext().setAuthentication(authentication); } chain.doFilter(request, response); } } SpringBoot手搓jwt令牌认证 在使用前要在pom.xml中引入jwt的依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这是jwt令牌的工具类直接CV到pojo包下即可,key是秘钥，Time是令牌有效期，过期自动登出网站\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.test.springbootproject01.pojo; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import java.util.Date; public class JwtHelper { private String key = \u0026#34;Lucius\u0026#34;; private Integer Time=3600*1000; public String getJwt(Claims claims){ String jwt= Jwts.builder() .setClaims(claims) .signWith(SignatureAlgorithm.HS256,key) .setExpiration(new Date(System.currentTimeMillis()+Time)) .compact(); return jwt; } public Claims parseJwt(String jwt){ Claims claims=Jwts.parser() //输入秘钥 .setSigningKey(key) //给jwt令牌解码 .parseClaimsJws(jwt) //获取claims对象 .getBody(); return claims; } } 为了让没有jwt令牌的用户无法访问网站，我们得使用拦截器，下面是springboot中的拦截器\n我们要先配置这个拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package com.test.springbootproject01.interceptor; import ... @Component @Slf4j public class LoginCheckInterceptor implements HandlerInterceptor { @Override//目标方法运行前执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1获取请求路径 String url = request.getRequestURI(); log.info(\u0026#34;拦截到请求：{}\u0026#34;,url); //如果是登录请求，放行 if(url.equals(\u0026#34;/login\u0026#34;)){ log.info(\u0026#34;登录放行\u0026#34;); return true; } //2判断是否登录 String jwt=request.getHeader(\u0026#34;token\u0026#34;); if(jwt==null){ log.info(\u0026#34;未登录，拦截\u0026#34;); Result error=Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notlogin= JSONObject.toJSONString(error); response.getWriter().write(notlogin); //返回false不放行 return false; } JwtHelper jwtHelper=new JwtHelper(); //3判断jwt是否合法 //解析jwt令牌时，如果解析失败，抛出异常，捕获异常，返回错误信息，如果解析成功，就可以放行 try { jwtHelper.parseJwt(jwt); } catch (Exception e) { log.info(\u0026#34;jwt无效\u0026#34;); Result error=Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notlogin=JSONObject.toJSONString(error); response.getWriter().write(notlogin); return false; } log.info(\u0026#34;jwt有效\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 正常写的话需要实现HandlerInterceptor接口中的preHandle方法，这个方法是在调用controller方法前执行的，在后端未向前端发送数据时拦截检查jwt令牌，jwt令牌的逻辑请看注释\n写一个类名为WebConfig,然后配置拦截器的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.test.springbootproject01.config; import ... @Configuration//@Configuration注解表示当前类是一个配置类 public class WebConfig implements WebMvcConfigurer { @Autowired //注入拦截器对象 private LoginCheckInterceptor loginCheckInterceptor; @Override //注册/添加拦截器 public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginCheckInterceptor) //添加拦截器拦截路径 .addPathPatterns(\u0026#34;/**\u0026#34;) //除了/login以外的路径都要被拦截 .excludePathPatterns(\u0026#34;/login\u0026#34;); } } 然后回到登录的controller层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.test.springbootproject01.Controller; import ... @Slf4j @RestController @RequestMapping(\u0026#34;/login\u0026#34;) public class LoginController { @Autowired private EmpService empService; @PostMapping public Result Login(@RequestBody Emp emp){ log.info(\u0026#34;{}请求登录\u0026#34;,emp); Emp emp1=empService.login(emp); //如果查有此人就开始准备制作令牌 if(emp1!=null){ JwtHelper jh=new JwtHelper(); Claims claims=new DefaultClaims(); claims.put(\u0026#34;id\u0026#34;,emp1.getId()); claims.put(\u0026#34;username\u0026#34;,emp1.getUsername()); claims.put(\u0026#34;password\u0026#34;,emp1.getPassword()); log.info(\u0026#34;请求人用户名：{}\u0026#34;,emp.getUsername()); log.info(\u0026#34;请求人密码{}\u0026#34;,emp.getPassword()); String jwt=jh.getJwt(claims); return Result.success(jwt); } return Result.error(\u0026#34;NOT_LOGIN\u0026#34;); } } AOP 面向切面/方法编程 要在使用AOP之前先引入依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 一个简单的AOP入门示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.test.springbootproject01.AOP; import ... @Slf4j @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution(* com.test.springbootproject01.Service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable { //方法启动时间 long startTime = System.currentTimeMillis(); //执行方法 Object result = joinPoint.proceed(); //方法结束时间 long endTime = System.currentTimeMillis(); log.info(joinPoint.getSignature()+\u0026#34;方法执行时间为\u0026#34;+(endTime - startTime) + \u0026#34;ms\u0026#34;); return result; } } 1 @Around(\u0026#34;execution(* com.test.springbootproject01.Service.*.*(..))\u0026#34;) execution是用来提示后面是切入点，第一个*指的是返回值为任意类型，com.test.springbootproject01.Service第二个是指任何类，第三个是任何方法，(..)表示匹配任何数量和类型的参数\nNginx的反向代理 后端部署在服务器上默认占用8080端口，前端若也要在服务器上部署，最好不要也选择8080，此时就要用到反向代理。\n打开\nnginx配置界面、\n然后修改这里的代码\nlisten代表前端服务器占用的端口\nlocation /api/ 块说明 1 2 3 location /api/ { proxy_pass http://localhost:8080/emprequest/; } location 指令（/api/ 路径情况）： 这里的 location /api/ 表示匹配所有以 /api/ 开头的客户端请求 URI。例如，像 http://localhost:100/api/user、http://localhost:100/api/order 这样的请求都会进入到这个 location 块中进行后续处理。 proxy_pass 指令： 用于设置反向代理，即将匹配到 /api/ 开头的请求转发到指定的后端服务器地址及路径上。在这里，它会把请求转发到 http://localhost:8080/emprequest/。具体来说，比如前端页面发起了一个 http://localhost:100/api/some-api 的请求，Nginx 会把这个请求去掉 /api/ 这部分前缀后，转发到 http://localhost:8080/emprequest/some-api 这个路径上，让运行在 8080 端口的后端服务器去处理对应的请求，然后后端服务器返回的响应结果又会通过 Nginx 再传递回发起请求的客户端（比如浏览器）。 总体来讲，这段 Nginx 配置定义了一个监听在 100 端口的服务器，针对根路径请求会查找并返回 html 目录下的相关文件，而针对以 /api/ 开头的请求则会将其代理转发到本地 8080 端口下的特定路径上让后端服务进行处理。 此时前端的代码为\n以后设计接口最好这样搞\nTODO标签代表还没做完的事，后面可以查看TODO标签对没写完的代码进行完善\n","date":"2025-03-16T15:38:21+08:00","permalink":"https://LuciusWan.github.io/p/javaweb%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/","title":"JavaWeb部分笔记"},{"content":"API接口文档 1. 文档概述 产品经理的任务 产品经理定义每个版本需要实现的具体功能和细节，通常通过撰写产品需求文档来明确需求。并且撰写API接口文档告诉前后端工程师，怎样开发才能在双方完成任务后，前后端能够完美对接。\n文档目的 API接口文档旨在帮助开发人员了解如何调用和使用本系统提供的API。文档包括了接口的定义、请求与响应格式、错误处理机制等内容。\n系统架构 前端：原生JS 或 Vue.js 后端：Java原生 或 SpringBoot框架 API接口文档示例 部门管理 1.1 部门列表查询 1.1.1 基本信息 请求路径：/depts\n请求方式：GET\n接口描述：该接口用于部门列表数据查询\n1.1.2 请求参数 无\n1.1.3 响应数据 参数格式：application/json\n参数说明：\n参数名 类型 是否必须 备注 code number 必须 响应码，1 代表成功，0 代表失败 msg string 非必须 提示信息 data object[ ] 非必须 返回的数据 \\ - id number 非必须 \\ - name string 非必须 \\ - createTime string 非必须 \\ - updateTime string 非必须 响应数据样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;code\u0026#34;: 1, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;学工部\u0026#34;, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;教研部\u0026#34;, \u0026#34;createTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34;, \u0026#34;updateTime\u0026#34;: \u0026#34;2022-09-01T23:06:29\u0026#34; } ] } 2. 前端使用说明 前端框架选择 1. JS原生代码（使用fetch） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fetch(\u0026#39;/depts\u0026#39;, { method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, } }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { if (data.code === 1) { console.log(\u0026#34;部门列表:\u0026#34;, data.data); } else { console.log(\u0026#34;请求失败:\u0026#34;, data.msg); } }) .catch(error =\u0026gt; { console.error(\u0026#39;Error:\u0026#39;, error); }); Vue.js 在Vue组件中，可以使用Axios来简化API调用。\n示例代码（使用Axios发送GET请求）：\n错误处理 前端应对API请求中的常见错误进行处理，如404（未找到），500（服务器错误）等。\n错误处理示例：\n1 2 3 4 5 6 7 8 9 10 fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; { if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }) .catch(error =\u0026gt; { console.error(\u0026#39;API call failed:\u0026#39;, error); }); 3. 后端实现说明 后端语言/框架选择 Java原生 使用Java原生编写API接口，通常通过HttpServlet处理请求。\n示例代码（Java原生实现GET请求）：\n1 2 3 4 5 6 7 8 9 10 11 import javax.servlet.*; import javax.servlet.http.*; import java.io.*; public class DataServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\u0026#34;application/json\u0026#34;); PrintWriter out = response.getWriter(); out.println(\u0026#34;{\\\u0026#34;message\\\u0026#34;:\\\u0026#34;Hello, World!\\\u0026#34;}\u0026#34;); } } SpringBoot 使用SpringBoot框架，MySQL数据库，Mybatis框架来实现后端数据的提供\n示例代码（SpringBoot实现前端Get的请求）：\n内容是查询所有部门，要求这里是Get请求，可以使用@GetMapping\n使用三层架构，DeptController，DeptService，DeptMapper,响应，处理数据，调取数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //日志输出的注解 @Slf4j //controller层必带的注解 @RestController @RequestMapping(\u0026#34;/dept\u0026#34;) public class DeptController { Dept dp=new Dept(); //依赖注入 @Autowired private DeptService deptService; @GetMapping() public Result list(){ log.info(\u0026#34;查询所有部门数据\u0026#34;); List\u0026lt;Dept\u0026gt; depts= deptService.list(); return Result.success(depts); } } 这是DeptController的代码有@RequestMapping(\u0026quot;/dept\u0026quot;)后可以在后面定义类似GetMapping(\u0026quot;/dept\u0026quot;)时直接省略前面的/dept\nResult类可以以统一格式把数据上传到前端，并且是JSON格式(这是个工具类，直接导入pojo包下即可)\n统一返回格式大致如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.test.springbootproject01.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; @Data @NoArgsConstructor @AllArgsConstructor public class Result { private Integer code;//响应码，1 代表成功; 0 代表失败 private String msg; //响应信息 描述字符串 private Object data; //返回的数据 //增删改 成功响应 public static Result success(){ return new Result(1,\u0026#34;success\u0026#34;,null); } //查询 成功响应 public static Result success(Object data){ return new Result(1,\u0026#34;success\u0026#34;,data); } //失败响应 public static Result error(String msg){ return new Result(0,msg,null); } } Service层用来处理数据，需要用到注解@Service\n1 2 3 4 5 6 7 8 9 @Service public class DeptServiceImpl implements DeptService { @Autowired private DeptMapper deptMapper; public List\u0026lt;Dept\u0026gt; list(){ List\u0026lt;Dept\u0026gt; deptList = deptMapper.list(); return deptList; } } 最后到Mapper层用来和数据库对接，Mapper可以用XML来和数据库对接，也可以使用注解的方式，这里演示Mapper层配合xml格式调用数据\n1 2 3 4 @Mapper public interface DeptMapper { public List\u0026lt;Dept\u0026gt; list(); } xml文件如下\n1 2 3 \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.test.springbootproject01.pojo.Dept\u0026#34;\u0026gt; select * from springboottest.dept \u0026lt;/select\u0026gt; 这样Get请求从前端发送过来后，由后端Controller层接受请求，然后调用service层处理数据，然后service层再调用mapper层获取数据，最终处理完数据后返回给前端\n安全性与认证 API接口使用JWT（JSON Web Token）进行认证，确保请求的安全性。如果登录成功就获得一个令牌，每次访问网站都会检查jwt令牌是否有效，同时可以给jwt令牌设置有效时限。\nJWT认证示例（Spring Security集成JWT）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; public class JwtTokenFilter extends OncePerRequestFilter { @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException { String token = request.getHeader(\u0026#34;Authorization\u0026#34;); if (token != null \u0026amp;\u0026amp; token.startsWith(\u0026#34;Bearer \u0026#34;)) { // Validate and parse JWT token here UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(user, null, authorities); SecurityContextHolder.getContext().setAuthentication(authentication); } chain.doFilter(request, response); } } SpringBoot手搓jwt令牌认证 在使用前要在pom.xml中引入依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这是jwt令牌的工具类直接CV到pojo包下即可,key是秘钥，Time是令牌有效期，过期自动登出网站\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package com.test.springbootproject01.pojo; import io.jsonwebtoken.Claims; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import java.util.Date; public class JwtHelper { private String key = \u0026#34;Lucius\u0026#34;; private Integer Time=3600*1000; public String getJwt(Claims claims){ String jwt= Jwts.builder() .setClaims(claims) .signWith(SignatureAlgorithm.HS256,key) .setExpiration(new Date(System.currentTimeMillis()+Time)) .compact(); return jwt; } public Claims parseJwt(String jwt){ Claims claims=Jwts.parser() //输入秘钥 .setSigningKey(key) //给jwt令牌解码 .parseClaimsJws(jwt) //获取claims对象 .getBody(); return claims; } } 为了让没有jwt令牌的用户无法访问网站，我们得使用拦截器，下面是springboot中的拦截器\n我们要先配置这个拦截器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package com.test.springbootproject01.interceptor; import com.alibaba.fastjson.JSONObject; import com.test.springbootproject01.pojo.JwtHelper; import com.test.springbootproject01.pojo.Result; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import lombok.extern.slf4j.Slf4j; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; @Component @Slf4j public class LoginCheckInterceptor implements HandlerInterceptor { @Override//目标方法运行前执行 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //1获取请求路径 String url = request.getRequestURI(); log.info(\u0026#34;拦截到请求：{}\u0026#34;,url); //如果是登录请求，放行 if(url.equals(\u0026#34;/login\u0026#34;)){ log.info(\u0026#34;登录放行\u0026#34;); return true; } //2判断是否登录 String jwt=request.getHeader(\u0026#34;token\u0026#34;); if(jwt==null){ log.info(\u0026#34;未登录，拦截\u0026#34;); Result error=Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notlogin= JSONObject.toJSONString(error); response.getWriter().write(notlogin); //返回false不放行 return false; } JwtHelper jwtHelper=new JwtHelper(); //3判断jwt是否合法 //解析jwt令牌时，如果解析失败，抛出异常，捕获异常，返回错误信息，如果解析成功，就可以放行 try { jwtHelper.parseJwt(jwt); } catch (Exception e) { log.info(\u0026#34;jwt无效\u0026#34;); Result error=Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notlogin=JSONObject.toJSONString(error); response.getWriter().write(notlogin); return false; } log.info(\u0026#34;jwt有效\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } 正常写的话需要实现HandlerInterceptor接口中的preHandle方法，这个方法是在调用controller方法前执行的，在后端未向前端发送数据时拦截检查jwt令牌，jwt令牌的逻辑请看注释\n写一个类名为WebConfig,然后配置拦截器的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package com.test.springbootproject01.config; import com.test.springbootproject01.interceptor.LoginCheckInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration//@Configuration注解表示当前类是一个配置类 public class WebConfig implements WebMvcConfigurer { @Autowired //注入拦截器对象 private LoginCheckInterceptor loginCheckInterceptor; @Override //注册/添加拦截器 public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginCheckInterceptor) //添加拦截器拦截路径 .addPathPatterns(\u0026#34;/**\u0026#34;) //除了/login以外的路径都要被拦截 .excludePathPatterns(\u0026#34;/login\u0026#34;); } } 然后回到登录的controller层\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 package com.test.springbootproject01.Controller; import com.test.springbootproject01.Service.EmpService; import com.test.springbootproject01.pojo.Emp; import com.test.springbootproject01.pojo.JwtHelper; import com.test.springbootproject01.pojo.Result; import io.jsonwebtoken.Claims; import io.jsonwebtoken.impl.DefaultClaims; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @Slf4j @RestController @RequestMapping(\u0026#34;/login\u0026#34;) public class LoginController { @Autowired private EmpService empService; @PostMapping public Result Login(@RequestBody Emp emp){ log.info(\u0026#34;{}请求登录\u0026#34;,emp); Emp emp1=empService.login(emp); //如果查有此人就开始准备制作令牌 if(emp1!=null){ JwtHelper jh=new JwtHelper(); Claims claims=new DefaultClaims(); claims.put(\u0026#34;id\u0026#34;,emp1.getId()); claims.put(\u0026#34;username\u0026#34;,emp1.getUsername()); claims.put(\u0026#34;password\u0026#34;,emp1.getPassword()); log.info(\u0026#34;请求人用户名：{}\u0026#34;,emp.getUsername()); log.info(\u0026#34;请求人密码{}\u0026#34;,emp.getPassword()); String jwt=jh.getJwt(claims); return Result.success(jwt); } return Result.error(\u0026#34;NOT_LOGIN\u0026#34;); } } java代码是这样的(\n","date":"2025-03-16T15:29:26+08:00","permalink":"https://LuciusWan.github.io/p/api%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","title":"API接口文档使用教程"}]